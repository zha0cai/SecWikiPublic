
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <title>CPP - 02 重载 · Windows 高级攻防</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.0">
        <meta name="author" content="zha0cai">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-versions-select/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-flexible-alerts/style.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-advanced-emoji/emoji-website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="CPP - 03 继承.html" />
    
    
    <link rel="prev" href="CPP - 01 面向对象基础.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://github.com/zha0cai" target="_blank" class="custom-link">My github</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Windows 高级攻防
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">0x01 基础阶段</li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    C 语言程序设计基础
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../C 语言程序设计基础/01 - 环境和编译.html">
            
                <a href="../C 语言程序设计基础/01 - 环境和编译.html">
            
                    
                    01 环境和编译
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../C 语言程序设计基础/02 - 基础数据类型与输入输出.html">
            
                <a href="../C 语言程序设计基础/02 - 基础数据类型与输入输出.html">
            
                    
                    02 基础数据类型与输入输出
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="../C 语言程序设计基础/03 - 运算符.html">
            
                <a href="../C 语言程序设计基础/03 - 运算符.html">
            
                    
                    03 运算符
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.4" data-path="../C 语言程序设计基础/04 - 选择结构与顺序结构.html">
            
                <a href="../C 语言程序设计基础/04 - 选择结构与顺序结构.html">
            
                    
                    04 选择结构与顺序结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.5" data-path="../C 语言程序设计基础/05 - 函数、数组与指针.html">
            
                <a href="../C 语言程序设计基础/05 - 函数、数组与指针.html">
            
                    
                    05 函数、数组与指针
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.6" data-path="../C 语言程序设计基础/06 - 复杂数据类型与文件操作.html">
            
                <a href="../C 语言程序设计基础/06 - 复杂数据类型与文件操作.html">
            
                    
                    06 复杂数据类型与文件操作
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2.2" >
            
                <span>
            
                    
                    C ++ 基础
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.2.1" data-path="CPP - 01 面向对象基础.html">
            
                <a href="CPP - 01 面向对象基础.html">
            
                    
                    CPP - 01 面向对象基础
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.2.2" data-path="CPP - 02 重载.html">
            
                <a href="CPP - 02 重载.html">
            
                    
                    CPP - 02 重载
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.3" data-path="CPP - 03 继承.html">
            
                <a href="CPP - 03 继承.html">
            
                    
                    CPP - 03 继承
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.4" data-path="CPP - 04 多态.html">
            
                <a href="CPP - 04 多态.html">
            
                    
                    CPP - 04 多态
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.5" data-path="CPP - 05 探索类对象模型（一）.html">
            
                <a href="CPP - 05 探索类对象模型（一）.html">
            
                    
                    CPP - 05 探索类对象模型（一）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.6" data-path="CPP - 06 探索类对象模型（二）.html">
            
                <a href="CPP - 06 探索类对象模型（二）.html">
            
                    
                    CPP - 06 探索类对象模型（二）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.7" data-path="CPP - 07 探索类对象模型（三）.html">
            
                <a href="CPP - 07 探索类对象模型（三）.html">
            
                    
                    CPP - 07 探索类对象模型（三）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.8" data-path="CPP - 08 寄存器基础与函数调用约定.html">
            
                <a href="CPP - 08 寄存器基础与函数调用约定.html">
            
                    
                    CPP - 08 寄存器基础与函数调用约定
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.9" data-path="CPP - 09 探索对象模型（四）.html">
            
                <a href="CPP - 09 探索对象模型（四）.html">
            
                    
                    CPP - 09 探索对象模型（四）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.10" data-path="CPP - 10 探索对象模型（五）.html">
            
                <a href="CPP - 10 探索对象模型（五）.html">
            
                    
                    CPP - 10 探索对象模型（五）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.11" data-path="CPP - 11 函数模板和类模板.html">
            
                <a href="CPP - 11 函数模板和类模板.html">
            
                    
                    CPP - 11 函数模板和类模板
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.12" data-path="CPP - 12 函数模板和类模板（总结）.html">
            
                <a href="CPP - 12 函数模板和类模板（总结）.html">
            
                    
                    CPP - 12 函数模板和类模板（总结）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.13" data-path="CPP - 现代 C++ 基础（一）.html">
            
                <a href="CPP - 现代 C++ 基础（一）.html">
            
                    
                    CPP - 现代 C++ 基础（一）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.14" data-path="CPP - 现代 C++ 基础（二）.html">
            
                <a href="CPP - 现代 C++ 基础（二）.html">
            
                    
                    CPP - 现代 C++ 基础（二）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.15" data-path="CPP - 现代 C++ 基础（三）.html">
            
                <a href="CPP - 现代 C++ 基础（三）.html">
            
                    
                    CPP - 现代 C++ 基础（三）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">MASM 汇编语言（待更新）</li>
        
        
    

    
        
        <li class="header">0x02 高级安全</li>
        
        
    

    
        
        <li class="header">0x03 内网攻防</li>
        
        
    

    
        
        <li class="header">0x04 CTF（浅）</li>
        
        
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            本书使用 HonKit 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >CPP - 02 重载</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#函数重载"><b></b>函数重载</a></li><li><span class="title-icon "></span><a href="#运算符重载"><b></b>运算符重载</a></li><ul><li><span class="title-icon "></span><a href="#可重载的运算符列表"><b></b>可重载的运算符列表</a></li><li><span class="title-icon "></span><a href="#不可重载的运算符列表"><b></b>不可重载的运算符列表</a></li><li><span class="title-icon "></span><a href="#单目运算符，类内（成员函数）重载"><b></b>单目运算符，类内（成员函数）重载</a></li><li><span class="title-icon "></span><a href="#前置--和-后置-"><b></b>前置 ++ 和 后置 ++</a></li><li><span class="title-icon "></span><a href="#下标运算符---重载"><b></b>下标运算符 [ ] 重载</a></li><li><span class="title-icon "></span><a href="#运算符重载_1"><b></b>() 运算符重载</a></li><li><span class="title-icon "></span><a href="#输入（）输出（）运算符重载"><b></b>输入（&gt;&gt;）输出（&lt;&lt;）运算符重载</a></li></ul><li><span class="title-icon "></span><a href="#拷贝构造"><b></b>拷贝构造</a></li><ul><li><span class="title-icon "></span><a href="#浅拷贝"><b></b>浅拷贝</a></li><li><span class="title-icon "></span><a href="#深拷贝"><b></b>深拷贝</a></li></ul><li><span class="title-icon "></span><a href="#练习"><b></b>练习</a></li><li><span class="title-icon "></span><a href="#前人栽树"><b></b>前人栽树</a></li></ul></div><a href="#函数重载" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><blockquote>
<p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong> 。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有<strong>相同名称</strong>的声明，但是它们的<strong>参数列表</strong>和<strong>定义（实现）</strong>不相同。</p>
<p><a href="https://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank">C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h1 id="函数重载"><a name="函数重载" class="anchor-navigation-ex-anchor" href="#函数重载"><i class="fa fa-link" aria-hidden="true"></i></a>函数重载</h1>
<blockquote>
<p>这些同名函数的<strong>形式参数</strong>（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。</p>
</blockquote>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c[])</span> </span>{}
</code></pre>
<h1 id="运算符重载"><a name="运算符重载" class="anchor-navigation-ex-anchor" href="#运算符重载"><i class="fa fa-link" aria-hidden="true"></i></a>运算符重载</h1>
<blockquote>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 <code>operator</code> <strong>和其后要重载的运算符符号构成的。</strong>与其他函数一样，重载运算符有一个返回类型和一个参数列表。<strong>operator 是关键字，它与重载的运算符一起构成函数名。</strong></p>
</blockquote>
<pre><code class="lang-cpp">Box <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Box&amp;);
---------
返回值类型 类名::<span class="hljs-keyword">operator</span>重载的运算符(参数表) {
   ……
}
</code></pre>
<h2 id="可重载的运算符列表"><a name="可重载的运算符列表" class="anchor-navigation-ex-anchor" href="#可重载的运算符列表"><i class="fa fa-link" aria-hidden="true"></i></a>可重载的运算符列表</h2>
<table>
<thead>
<tr>
<th>双目算术运算符</th>
<th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th>
</tr>
</thead>
<tbody>
<tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td></td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，--(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td></td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , %= , &amp;=,</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td><strong>()</strong>(函数调用)，<strong>-&gt;</strong>(成员访问) “-&gt;”运算符是成员访问运算符，这种单目运算符只能被重载为成员函数，<strong>,</strong>(逗号)，<strong>[]</strong>(下标)</td>
</tr>
</tbody>
</table>
<ul>
<li><code>数据类型 类名::operator-&gt;();</code></li>
<li><code>new</code> 和 <code>delete</code> <strong>只能被重载为类的成员函数，不能重载为友元。</strong>而且，无论是否使用关键字 <code>static</code> 进行修饰，重载了的 <code>new</code> 和 <code>delete</code> 均为类的<strong>静态成员函数</strong>。</li>
</ul>
<h2 id="不可重载的运算符列表"><a name="不可重载的运算符列表" class="anchor-navigation-ex-anchor" href="#不可重载的运算符列表"><i class="fa fa-link" aria-hidden="true"></i></a>不可重载的运算符列表</h2>
<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>.*, -&gt;*</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
<li><strong>类外/内重载</strong>：this 指针的区别。</li>
</ul>
<h2 id="单目运算符，类内（成员函数）重载"><a name="单目运算符，类内（成员函数）重载" class="anchor-navigation-ex-anchor" href="#单目运算符，类内（成员函数）重载"><i class="fa fa-link" aria-hidden="true"></i></a>单目运算符，类内（成员函数）重载</h2>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;exception&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> m_nNumberA;
    <span class="hljs-keyword">int</span> m_nNumberB;
    <span class="hljs-keyword">char</span> * szStr;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyString</span>() {};
    <span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">int</span> nNumberA, <span class="hljs-keyword">int</span> nNumberB): <span class="hljs-built_in">m_nNumberA</span>(nNumberA), <span class="hljs-built_in">m_nNumberB</span>(nNumberB) {};
    <span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">char</span> * szStr);;
    MyString <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyString &amp;objB);
};
</code></pre>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">MyString <span class="hljs-title">objA</span><span class="hljs-params">(<span class="hljs-number">11</span>, <span class="hljs-number">22</span>)</span></span>;
    <span class="hljs-function">MyString <span class="hljs-title">objB</span><span class="hljs-params">(<span class="hljs-number">33</span>, <span class="hljs-number">44</span>)</span></span>;

    MyString objC = objA + objB;
    cout &lt;&lt; objC.m_nNumberA &lt;&lt; endl;
    cout &lt;&lt; objC.m_nNumberB &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

MyString::<span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">char</span> *szStr) {
    <span class="hljs-keyword">this</span>-&gt;szStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-built_in">strlen</span>(szStr) + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;szStr, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(szStr) + <span class="hljs-number">1</span>);
    <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;szStr, szStr);
}

MyString MyString::<span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyString &amp;objB) { <span class="hljs-comment">// 有一个隐含的 this 指针</span>
    MyString tmpObj;
    tmpObj.m_nNumberA = <span class="hljs-keyword">this</span>-&gt;m_nNumberA + objB.m_nNumberA;
    tmpObj.m_nNumberB = <span class="hljs-keyword">this</span>-&gt;m_nNumberB + objB.m_nNumberB;
    <span class="hljs-keyword">return</span> tmpObj;
}
</code></pre>
<ul>
<li><a href="https://stackoverflow.com/questions/13554320/overloaded-operator-must-be-a-unary-or-binary-operator-error" target="_blank">c++ - overloaded &apos;operator+&apos; must be a unary or binary operator error - Stack Overflow</a></li>
<li><p>重载 <code>&apos;operator+&apos;</code> 必须是一元或二元运算符错误。</p>
<p>overloaded &apos;operator+&apos; must be a unary or binary operator (has 3 parameters)</p>
</li>
<li><p>听起来您已将运算符声明为成员函数。成员函数采用隐式第一个参数，这意味着您的运算符现在采用三个参数。以下两个办法可以解决此错误：</p>
<ul>
<li>可以通过将其设为非成员函数。</li>
<li>或者减少一个参数。</li>
</ul>
</li>
</ul>
<h2 id="前置--和-后置-"><a name="前置--和-后置-" class="anchor-navigation-ex-anchor" href="#前置--和-后置-"><i class="fa fa-link" aria-hidden="true"></i></a>前置 ++ 和 后置 ++</h2>
<p>若想要实现 <code>++(++a)</code> 这种连续自加，<strong>就要返回其对象的引用，这样才能保证操作的是同一块内存空间</strong>，否则就只是单纯的赋值操作，原来的对象并未被修改。</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;exception&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> m_nNumberA;
    <span class="hljs-keyword">int</span> m_nNumberB;
    <span class="hljs-keyword">char</span> * szStr;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyString</span>() {};
    <span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">int</span> nNumberA, <span class="hljs-keyword">int</span> nNumberB): <span class="hljs-built_in">m_nNumberA</span>(nNumberA), <span class="hljs-built_in">m_nNumberB</span>(nNumberB) {};
    <span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">char</span> * szStr);;

    MyString <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyString &amp;objB);
    MyString <span class="hljs-keyword">operator</span>++();  <span class="hljs-comment">// 前置 ++</span>
    MyString <span class="hljs-keyword">operator</span>--();

    MyString <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>);  <span class="hljs-comment">// 后置 ++</span>
    MyString <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>);
};
</code></pre>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">MyString <span class="hljs-title">objA</span><span class="hljs-params">(<span class="hljs-number">11</span>, <span class="hljs-number">22</span>)</span></span>;
    <span class="hljs-function">MyString <span class="hljs-title">objB</span><span class="hljs-params">(<span class="hljs-number">33</span>, <span class="hljs-number">44</span>)</span></span>;

    MyString objC = objA + objB;
    cout &lt;&lt; objC.m_nNumberA &lt;&lt; endl;
    cout &lt;&lt; objC.m_nNumberB &lt;&lt; endl;

    cout &lt;&lt; --objC.m_nNumberA &lt;&lt; endl;
    cout &lt;&lt; --objC.m_nNumberB &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

MyString::<span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">char</span> *szStr) {
    <span class="hljs-keyword">this</span>-&gt;szStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-built_in">strlen</span>(szStr) + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;szStr, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(szStr) + <span class="hljs-number">1</span>);
    <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;szStr, szStr);
}

MyString MyString::<span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> MyString &amp;objB) {
    MyString tmpObj;
    tmpObj.m_nNumberA = <span class="hljs-keyword">this</span>-&gt;m_nNumberA + objB.m_nNumberA;
    tmpObj.m_nNumberB = <span class="hljs-keyword">this</span>-&gt;m_nNumberB + objB.m_nNumberB;
    <span class="hljs-keyword">return</span> tmpObj;
}

<span class="hljs-comment">// 前置 ++，先加后用</span>
MyString MyString::<span class="hljs-keyword">operator</span>++() {
    <span class="hljs-keyword">this</span>-&gt;m_nNumberA++;
    <span class="hljs-keyword">this</span>-&gt;m_nNumberB++;

    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-comment">// 后置 ++，先用后加</span>
MyString MyString::<span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) {
    MyString tmp = *<span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>-&gt;m_nNumberA++;
    <span class="hljs-keyword">this</span>-&gt;m_nNumberB++;

    <span class="hljs-keyword">return</span> tmp;
}

MyString MyString::<span class="hljs-keyword">operator</span>--() {
    <span class="hljs-keyword">this</span>-&gt;m_nNumberA--;
    <span class="hljs-keyword">this</span>-&gt;m_nNumberB--;

    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

MyString MyString::<span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>) {
    MyString tmp = *<span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>-&gt;m_nNumberA--;
    <span class="hljs-keyword">this</span>-&gt;m_nNumberB--;

    <span class="hljs-keyword">return</span> tmp;
}
</code></pre>
<h2 id="下标运算符---重载"><a name="下标运算符---重载" class="anchor-navigation-ex-anchor" href="#下标运算符---重载"><i class="fa fa-link" aria-hidden="true"></i></a>下标运算符 [ ] 重载</h2>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// [] 重载测试</span>
    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>] = {<span class="hljs-number">2</span>, <span class="hljs-number">5</span>}; <span class="hljs-comment">// 从下标 2 开始，往后 3 个。</span>
    <span class="hljs-keyword">char</span> szBuffer1[] = <span class="hljs-string">&quot;zhaocai&quot;</span>;
    <span class="hljs-function">MyString <span class="hljs-title">objF</span><span class="hljs-params">(szBuffer1)</span></span>;
    MyString objG;
    objG = objF[arr];
    cout &lt;&lt; objG.szStr &lt;&lt;endl; <span class="hljs-comment">// aoc</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 实现字符串切片</span>
MyString MyString::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>]) {
    <span class="hljs-keyword">size_t</span> nLength = arr[<span class="hljs-number">1</span>] - arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 5 - 2 = 3</span>

    MyString tmpStr;
    tmpStr.szStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[nLength + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(tmpStr.szStr, <span class="hljs-number">0</span>, nLength + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i; i&lt;nLength; i++) {
        tmpStr.szStr[i] = <span class="hljs-keyword">this</span>-&gt;szStr[i + arr[<span class="hljs-number">0</span>]];
    }

    <span class="hljs-keyword">return</span> tmpStr;
}
</code></pre>
<h2 id="运算符重载_1"><a name="运算符重载_1" class="anchor-navigation-ex-anchor" href="#运算符重载_1"><i class="fa fa-link" aria-hidden="true"></i></a>() 运算符重载</h2>
<p><strong>函数调用运算符</strong> <code>()</code> 可以被重载用于类的对象。当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个<strong>可以传递任意数目参数</strong>的运算符函数。</p>
<ul>
<li>只能说明成类的非静态成员函数</li>
<li><code>函数类型 类名::operator()(参数表)</code></li>
<li><a href="https://blog.csdn.net/sober0314/article/details/104477425" target="_blank">常量与指针间的转换 warning: ISO C++ forbids converting a string constant to &apos;char*&apos; [-Wwrite-strings]_sober0314的博客-CSDN博客</a></li>
<li><p><a href="https://www.cnblogs.com/zkfopen/p/10521715.html" target="_blank">warning: ISO C++ forbids converting a string constant to &apos;char*&apos; [-Wwrite-strings] - zkfopen - 博客园 (cnblogs.com)</a></p>
<pre><code class="lang-cpp"><span class="hljs-comment">// 在C++中，</span>
<span class="hljs-keyword">char</span>* p = <span class="hljs-string">&quot;abc&quot;</span>;　　<span class="hljs-comment">// valid in C, invalid in C++</span>
<span class="hljs-comment">// 会跳出警告：warning: ISO C++ forbids converting a string constant to &apos;char*&apos; [-Wwrite-strings]</span>

<span class="hljs-comment">//改成下面会通过 warning</span>
<span class="hljs-keyword">char</span>* p = (<span class="hljs-keyword">char</span>*)<span class="hljs-string">&quot;abc&quot;</span>;  <span class="hljs-comment">// OK</span>

<span class="hljs-comment">//或者改成下面：</span>
<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *p = <span class="hljs-string">&quot;abc&quot;</span>;　　<span class="hljs-comment">// OK</span>
</code></pre>
</li>
<li><p>字符串常量是不能转化为指针变量的。指针数组中存放的是指针变量，指针变量存放的是右边每一个字符串常量的内存首地址，是指示器。右边则只是字符串常量即字面上“how r u ?&quot; 这些。指针即地址和常量有本质性的区别。编译器虽然可以编译，但是会给出警告，表明这是不符合规定的。</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">char</span> *p[<span class="hljs-number">3</span>] = {  <span class="hljs-string">&quot;how r u ?&quot;</span>,
        <span class="hljs-string">&quot;i&apos;m fine,thanks.&quot;</span>,
        <span class="hljs-string">&quot;and u ?&quot;</span>};

<span class="hljs-comment">// 建议写成 const char *p[3] = {};</span>
</code></pre>
</li>
<li><a href="https://www.runoob.com/cplusplus/function-call-operator-overloading.html" target="_blank">C++ 函数调用运算符 () 重载 | 菜鸟教程 (runoob.com)</a></li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// () 重载测试</span>
    <span class="hljs-keyword">char</span> szBuffer1[] = <span class="hljs-string">&quot;zhaocai&quot;</span>;
    <span class="hljs-function">MyString <span class="hljs-title">objH</span><span class="hljs-params">(szBuffer1)</span></span>;
    MyString objI;
    objI = <span class="hljs-built_in">objH</span>(<span class="hljs-string">&quot;mao&quot;</span>);

    cout &lt;&lt; objH.szStr &lt;&lt;endl;
    cout &lt;&lt; objI.szStr &lt;&lt;endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">MyString <span class="hljs-title">MyString::operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *szBuffer)</span> </span>{
    MyString tmp;
    <span class="hljs-keyword">size_t</span> nLength = <span class="hljs-built_in">strlen</span>(szBuffer);
    <span class="hljs-keyword">size_t</span> nSumLength = <span class="hljs-built_in">strlen</span>(<span class="hljs-keyword">this</span>-&gt;szStr) + nLength + <span class="hljs-number">1</span>;
    tmp.szStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [nSumLength];
    <span class="hljs-built_in">memset</span>(tmp.szStr, <span class="hljs-number">0</span>, nSumLength);

    <span class="hljs-built_in">strcat</span>(tmp.szStr, <span class="hljs-keyword">this</span>-&gt;szStr);
    <span class="hljs-built_in">strcat</span>(tmp.szStr, szBuffer);

    <span class="hljs-keyword">return</span> tmp;
}
</code></pre>
<h2 id="输入（）输出（）运算符重载"><a name="输入（）输出（）运算符重载" class="anchor-navigation-ex-anchor" href="#输入（）输出（）运算符重载"><i class="fa fa-link" aria-hidden="true"></i></a>输入（&gt;&gt;）输出（&lt;&lt;）运算符重载</h2>
<ul>
<li>需要把运算符重载函数声明为类的<strong>友元函数</strong>，这样我们就能不用创建对象而直接调用函数。【当然你想创建对象再调用也是可以的~】</li>
<li><a href="https://www.runoob.com/cplusplus/input-output-operators-overloading.html" target="_blank">C++ 输入输出运算符重载 | 菜鸟教程 (runoob.com)</a></li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 输入输出重载测试</span>
    MyString objA;

    cin &gt;&gt;  objA;
    cout &lt;&lt; objA &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">MyString <span class="hljs-title">MyString::operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *szBuffer)</span> </span>{
    MyString tmp;
    <span class="hljs-keyword">size_t</span> nLength = <span class="hljs-built_in">strlen</span>(szBuffer);
    <span class="hljs-keyword">size_t</span> nSumLength = <span class="hljs-built_in">strlen</span>(<span class="hljs-keyword">this</span>-&gt;szStr) + nLength + <span class="hljs-number">1</span>;
    tmp.szStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [nSumLength];
    <span class="hljs-built_in">memset</span>(tmp.szStr, <span class="hljs-number">0</span>, nSumLength);

    <span class="hljs-built_in">strcat</span>(tmp.szStr, <span class="hljs-keyword">this</span>-&gt;szStr);
    <span class="hljs-built_in">strcat</span>(tmp.szStr, szBuffer);

    <span class="hljs-keyword">return</span> tmp;
}

<span class="hljs-comment">// &gt;&gt; 参数需要传地址，不然修改了你也传不出来。形参和实参~</span>
istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;cin, MyString &amp;obj) {
    cin &gt;&gt; obj.m_nNumberA &gt;&gt; obj.m_nNumberB;

    <span class="hljs-keyword">return</span> cin;
}

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout, MyString obj) {
    cout &lt;&lt; obj.m_nNumberA &lt;&lt; endl;
    cout &lt;&lt; obj.m_nNumberB &lt;&lt; endl;

    <span class="hljs-keyword">return</span> cout;
}
</code></pre>
<p>【注意】：如果需要连续使用 <code>&gt;&gt;</code> 或者 <code>&lt;&lt;</code> 则需要返回流对象。若函数的返回值为 void 则会出现一下错误。</p>
<p><img src="assets/Snipaste_2022-10-18_11-03-24-20221018110346-3meowx6.png" alt="Snipaste_2022-10-18_11-03-24">​</p>
<h1 id="拷贝构造"><a name="拷贝构造" class="anchor-navigation-ex-anchor" href="#拷贝构造"><i class="fa fa-link" aria-hidden="true"></i></a>拷贝构造</h1>
<p>深拷贝和浅拷贝的区别是在<strong>对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，</strong>则是深拷贝，否则是浅拷贝。</p>
<p>浅拷贝只是对象数据之间的简单赋值（如：b.size = a.size, b.data = a.data）。</p>
<p>如果对象中没有其他的资源（如：堆，文件，系统资源等），即成员不包括指针和引用时，则深拷贝和浅拷贝没有什么区别。==【因为涉及指针的时候，那你简单赋值，指针指向的也是同一个地址。（指针的本质不就是存的值是一个地址吗？那么他们存的值（地址）就是一样的），所以指向同一内存空间】==</p>
<p><strong>如你设计了一个没有类而没有提供它的拷贝构造函数，当用该类的一个对象去给令一个对象赋值时所执行的过程就是浅拷贝。</strong></p>
<h2 id="浅拷贝"><a name="浅拷贝" class="anchor-navigation-ex-anchor" href="#浅拷贝"><i class="fa fa-link" aria-hidden="true"></i></a>浅拷贝</h2>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;exception&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> m_nNumberA;
    <span class="hljs-keyword">int</span> m_nNumberB;
    <span class="hljs-keyword">char</span> * szStr;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyString</span>() {};
    <span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">int</span> nNumberA, <span class="hljs-keyword">int</span> nNumberB): <span class="hljs-built_in">m_nNumberA</span>(nNumberA), <span class="hljs-built_in">m_nNumberB</span>(nNumberB) {};
    <span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">char</span> * szStr);;

    MyString <span class="hljs-keyword">operator</span>=(MyString obj); <span class="hljs-comment">// 浅拷贝</span>
};
</code></pre>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 拷贝测试</span>
    <span class="hljs-keyword">char</span> szBuffer[] = <span class="hljs-string">&quot;zhaocai&quot;</span>;
    <span class="hljs-function">MyString <span class="hljs-title">objD</span><span class="hljs-params">(szBuffer)</span></span>;
    MyString objE = objD;


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

MyString::<span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">char</span> *szStr) {
    <span class="hljs-keyword">this</span>-&gt;szStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-built_in">strlen</span>(szStr) + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;szStr, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(szStr) + <span class="hljs-number">1</span>);
    <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;szStr, szStr);
}

<span class="hljs-comment">// 浅拷贝</span>
MyString MyString::<span class="hljs-keyword">operator</span>=(MyString obj) {
    <span class="hljs-keyword">this</span>-&gt;m_nNumberA = obj.m_nNumberA;
    <span class="hljs-keyword">this</span>-&gt;m_nNumberB = obj.m_nNumberB;

    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<p><img src="assets/Snipaste_2022-10-17_23-19-32-20221017232155-h7r55of.png" alt="Snipaste_2022-10-17_23-19-32"></p>
<p><img src="assets/Snipaste_2022-10-17_23-29-39-20221017232948-o25fvvg.png" alt="Snipaste_2022-10-17_23-29-39">​</p>
<p><img src="assets/Snipaste_2022-10-17_23-36-14-20221017233630-1k93en2.png" alt="Snipaste_2022-10-17_23-36-14"></p>
<p>这里 b 的指针 data 和 a 的指针指向了<strong>堆</strong>上的同一块内存，a 和 b 析构时，b 先把其 data 指向的动态分配的内存释放了一次，而后 a 析构时又将这块已经释放过的内存再释放一次。【对同一块内存多次释放问题】</p>
<p><a href="https://blog.csdn.net/joshgu958/article/details/35302413" target="_blank">对同一块内存释放执行 2 次及 2 次以上的释放会造成内存泄露或者是程序 crash！</a></p>
<h2 id="深拷贝"><a name="深拷贝" class="anchor-navigation-ex-anchor" href="#深拷贝"><i class="fa fa-link" aria-hidden="true"></i></a>深拷贝</h2>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 深拷贝测试</span>
    <span class="hljs-keyword">char</span> szBuffer[] = <span class="hljs-string">&quot;zhaocai&quot;</span>;
    <span class="hljs-function">MyString <span class="hljs-title">objD</span><span class="hljs-params">(szBuffer)</span></span>;
    <span class="hljs-comment">// MyString objE = objD; // 这样的话不会调用重载的 = 深拷贝操作，因为这样调用的是拷贝构造函数，而默认情况下拷贝构造函数就是浅拷贝。【规定就是这样的】</span>
    <span class="hljs-comment">// 所以要分开写，先初始化，再赋值。</span>
    MyString objE;
    objE = objD;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

MyString::<span class="hljs-built_in">MyString</span>(<span class="hljs-keyword">char</span> *szStr) {
    <span class="hljs-keyword">this</span>-&gt;szStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-built_in">strlen</span>(szStr) + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;szStr, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(szStr) + <span class="hljs-number">1</span>);
    <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;szStr, szStr);
}

<span class="hljs-comment">// 深拷贝</span>
MyString MyString::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyString &amp;obj) {
    <span class="hljs-keyword">this</span>-&gt;m_nNumberA = obj.m_nNumberA;
    <span class="hljs-keyword">this</span>-&gt;m_nNumberB = obj.m_nNumberB;
    <span class="hljs-keyword">this</span>-&gt;szStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-built_in">strlen</span>(obj.szStr) + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;szStr, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(obj.szStr) + <span class="hljs-number">1</span>);
    <span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;szStr, obj.szStr);

    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<p><img src="assets/Snipaste_2022-10-17_23-59-35-20221017235956-o29nwt7.png" alt="Snipaste_2022-10-17_23-59-35">​</p>
<p><strong>= 运算符重载不调用问题</strong></p>
<ul>
<li><a href="https://blog.csdn.net/u014583317/article/details/109217780" target="_blank">https://blog.csdn.net/u014583317/article/details/109217780</a></li>
</ul>
<h1 id="练习"><a name="练习" class="anchor-navigation-ex-anchor" href="#练习"><i class="fa fa-link" aria-hidden="true"></i></a>练习</h1>
<p>实现一个字符串类，重载运算符</p>
<ul>
<li>+（拼接）</li>
<li>-（减去子串）</li>
<li>*（复制拼接）</li>
<li>= （赋值）</li>
<li>== （判断相等）</li>
</ul>
<h1 id="前人栽树"><a name="前人栽树" class="anchor-navigation-ex-anchor" href="#前人栽树"><i class="fa fa-link" aria-hidden="true"></i></a>前人栽树</h1>
<ul>
<li><a href="https://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank">C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com)</a></li>
</ul>
<p>‍</p>
<footer class="page-footer"><span class="copyright">Copyright &amp; Copy zha0cai all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2022-11-08 05:10:56
</span></footer></body></html>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="CPP - 01 面向对象基础.html" class="navigation navigation-prev " aria-label="Previous page: CPP - 01 面向对象基础">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="CPP - 03 继承.html" class="navigation navigation-next " aria-label="Next page: CPP - 03 继承">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"CPP - 02 重载","level":"2.2.2","depth":2,"next":{"title":"CPP - 03 继承","level":"2.2.3","depth":2,"path":"C++ 基础/CPP - 03 继承.md","ref":"C++ 基础/CPP - 03 继承.md","articles":[]},"previous":{"title":"CPP - 01 面向对象基础","level":"2.2.1","depth":2,"path":"C++ 基础/CPP - 01 面向对象基础.md","ref":"C++ 基础/CPP - 01 面向对象基础.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","search-pro","highlight","code","theme-comscore","-splitter","-summary","anchor-navigation-ex","expandable-chapters","versions-select","tbfed-pagefooter","flexible-alerts","advanced-emoji"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright & Copy zha0cai","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"search-pro":{},"code":{"copyButtons":true},"versions-select":{"type":"branches"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"anchor-navigation-ex":{"showLevel":false,"associatedWithSummary":true,"mode":"float","showGoTop":true,"printLog":false,"multipleH1":true,"float":{"floatIcon":"fa fa-navicon","showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"theme-comscore":{},"flexible-alerts":{"style":"callout","note":{"label":"Hinweis","icon":"fa fa-info-circle","className":"info"},"tip":{"label":"Tipp","icon":"fa fa-lightbulb-o","className":"tip"},"warning":{"label":"Warnung","icon":"fa fa-exclamation-triangle","className":"warning"},"danger":{"label":"Achtung","icon":"fa fa-ban","className":"danger"}},"versions":{"gitbookConfigURL":"book.json","options":[{"value":"https://zha0cai.github.io/gitbookPublic/gitbook-Windows 高级攻防/","text":"Windows 高级攻防","selected":true},{"value":"https://zha0cai.github.io/gitbookPublic/home/","text":"Home Page","selected":true}]},"advanced-emoji":{"embedEmojis":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"chart":{"type":"c3"},"expandable-chapters":{}},"theme":"default","author":"zha0cai","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Windows 高级攻防","language":"zh-hans","links":{"sidebar":{"My github":"https://github.com/zha0cai"}},"gitbook":"*"},"file":{"path":"C++ 基础/CPP - 02 重载.md","mtime":"2022-11-07T21:10:56.000Z","type":"markdown"},"gitbook":{"version":"4.0.0","time":"2022-11-08T06:00:50.224Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-versions-select/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-flexible-alerts/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    </body>
</html>

