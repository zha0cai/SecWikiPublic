
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <title>06 复杂数据类型与文件操作 · Windows 高级攻防</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.0">
        <meta name="author" content="zha0cai">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-versions-select/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-flexible-alerts/style.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-advanced-emoji/emoji-website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="05 - 函数、数组与指针.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://github.com/zha0cai" target="_blank" class="custom-link">My github</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Windows 高级攻防
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">0x01 基础阶段</li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    C 语言程序设计基础
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="01 - 环境和编译.html">
            
                <a href="01 - 环境和编译.html">
            
                    
                    01 环境和编译
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="02 - 基础数据类型与输入输出.html">
            
                <a href="02 - 基础数据类型与输入输出.html">
            
                    
                    02 基础数据类型与输入输出
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="03 - 运算符.html">
            
                <a href="03 - 运算符.html">
            
                    
                    03 运算符
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.4" data-path="04 - 选择结构与顺序结构.html">
            
                <a href="04 - 选择结构与顺序结构.html">
            
                    
                    04 选择结构与顺序结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.5" data-path="05 - 函数、数组与指针.html">
            
                <a href="05 - 函数、数组与指针.html">
            
                    
                    05 函数、数组与指针
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.1.6" data-path="06 - 复杂数据类型与文件操作.html">
            
                <a href="06 - 复杂数据类型与文件操作.html">
            
                    
                    06 复杂数据类型与文件操作
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2.2" >
            
                <span>
            
                    
                    C ++ 基础
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.2.1" data-path="../C++ 基础/CPP - 01 面向对象基础.html">
            
                <a href="../C++ 基础/CPP - 01 面向对象基础.html">
            
                    
                    CPP - 01 面向对象基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.2" data-path="../C++ 基础/CPP - 02 重载.html">
            
                <a href="../C++ 基础/CPP - 02 重载.html">
            
                    
                    CPP - 02 重载
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.3" data-path="../C++ 基础/CPP - 03 继承.html">
            
                <a href="../C++ 基础/CPP - 03 继承.html">
            
                    
                    CPP - 03 继承
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.4" data-path="../C++ 基础/CPP - 04 多态.html">
            
                <a href="../C++ 基础/CPP - 04 多态.html">
            
                    
                    CPP - 04 多态
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.5" data-path="../C++ 基础/CPP - 05 探索类对象模型（一）.html">
            
                <a href="../C++ 基础/CPP - 05 探索类对象模型（一）.html">
            
                    
                    CPP - 05 探索类对象模型（一）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.6" data-path="../C++ 基础/CPP - 06 探索类对象模型（二）.html">
            
                <a href="../C++ 基础/CPP - 06 探索类对象模型（二）.html">
            
                    
                    CPP - 06 探索类对象模型（二）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.7" data-path="../C++ 基础/CPP - 07 探索类对象模型（三）.html">
            
                <a href="../C++ 基础/CPP - 07 探索类对象模型（三）.html">
            
                    
                    CPP - 07 探索类对象模型（三）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.8" data-path="../C++ 基础/CPP - 08 寄存器基础与函数调用约定.html">
            
                <a href="../C++ 基础/CPP - 08 寄存器基础与函数调用约定.html">
            
                    
                    CPP - 08 寄存器基础与函数调用约定
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.9" data-path="../C++ 基础/CPP - 09 探索对象模型（四）.html">
            
                <a href="../C++ 基础/CPP - 09 探索对象模型（四）.html">
            
                    
                    CPP - 09 探索对象模型（四）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.10" data-path="../C++ 基础/CPP - 10 探索对象模型（五）.html">
            
                <a href="../C++ 基础/CPP - 10 探索对象模型（五）.html">
            
                    
                    CPP - 10 探索对象模型（五）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.11" data-path="../C++ 基础/CPP - 11 函数模板和类模板.html">
            
                <a href="../C++ 基础/CPP - 11 函数模板和类模板.html">
            
                    
                    CPP - 11 函数模板和类模板
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.12" data-path="../C++ 基础/CPP - 12 函数模板和类模板（总结）.html">
            
                <a href="../C++ 基础/CPP - 12 函数模板和类模板（总结）.html">
            
                    
                    CPP - 12 函数模板和类模板（总结）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.13" data-path="../C++ 基础/CPP - 现代 C++ 基础（一）.html">
            
                <a href="../C++ 基础/CPP - 现代 C++ 基础（一）.html">
            
                    
                    CPP - 现代 C++ 基础（一）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.14" data-path="../C++ 基础/CPP - 现代 C++ 基础（二）.html">
            
                <a href="../C++ 基础/CPP - 现代 C++ 基础（二）.html">
            
                    
                    CPP - 现代 C++ 基础（二）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.15" data-path="../C++ 基础/CPP - 现代 C++ 基础（三）.html">
            
                <a href="../C++ 基础/CPP - 现代 C++ 基础（三）.html">
            
                    
                    CPP - 现代 C++ 基础（三）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">MASM 汇编语言（待更新）</li>
        
        
    

    
        
        <li class="header">0x02 高级安全</li>
        
        
    

    
        
        <li class="header">0x03 内网攻防</li>
        
        
    

    
        
        <li class="header">0x04 CTF（浅）</li>
        
        
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            本书使用 HonKit 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >06 复杂数据类型与文件操作</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#预处理"><b></b>预处理</a></li><ul><li><span class="title-icon "></span><a href="#参数化的宏"><b></b>参数化的宏</a></li><li><span class="title-icon "></span><a href="#条件编译"><b></b>条件编译</a></li></ul><li><span class="title-icon "></span><a href="#if、elif、else-和-endif-指令-cc--microsoft-learn"><b></b>if、#elif、#else 和 #endif 指令 (C/C++) | Microsoft Learn</a></li><li><span class="title-icon "></span><a href="#结构体"><b></b>结构体</a></li><ul><li><span class="title-icon "></span><a href="#对数组成员的赋值"><b></b>对数组成员的赋值</a></li><li><span class="title-icon "></span><a href="#内存对齐"><b></b>内存对齐</a></li><li><span class="title-icon "></span><a href="#指针访问结构体"><b></b>指针访问结构体</a></li><li><span class="title-icon "></span><a href="#位域"><b></b>位域</a></li></ul><li><span class="title-icon "></span><a href="#联合体（共用体）"><b></b>联合体（共用体）</a></li><li><span class="title-icon "></span><a href="#枚举"><b></b>枚举</a></li><li><span class="title-icon "></span><a href="#文件操作"><b></b>文件操作</a></li><ul><li><span class="title-icon "></span><a href="#打开文件"><b></b>打开文件</a></li><li><span class="title-icon "></span><a href="#关闭文件"><b></b>关闭文件</a></li><li><span class="title-icon "></span><a href="#写文件"><b></b>写文件</a></li><li><span class="title-icon "></span><a href="#读文件"><b></b>读文件</a></li><ul><li><span class="title-icon "></span><a href="#fseek"><b></b>fseek()</a></li><li><span class="title-icon "></span><a href="#ftell"><b></b>ftell()</a></li><li><span class="title-icon "></span><a href="#rewind"><b></b>rewind()</a></li><li><span class="title-icon "></span><a href="#fgetcfgets"><b></b>fgetc()/fgets()</a></li><li><span class="title-icon "></span><a href="#按字节读取"><b></b>按字节读取</a></li><li><span class="title-icon "></span><a href="#错误调试"><b></b>错误调试</a></li><li><span class="title-icon "></span><a href="#error"><b></b>ERROR</a></li></ul></ul><li><span class="title-icon "></span><a href="#练习"><b></b>练习</a></li><ul><li><span class="title-icon "></span><a href="#练习-1"><b></b>练习 1</a></li><li><span class="title-icon "></span><a href="#练习-2"><b></b>练习 2</a></li></ul><li><span class="title-icon "></span><a href="#前人栽树"><b></b>前人栽树</a></li></ul></div><a href="#预处理" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="预处理"><a name="预处理" class="anchor-navigation-ex-anchor" href="#预处理"><i class="fa fa-link" aria-hidden="true"></i></a>预处理</h1>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>#define</td>
<td>定义宏，简单替换，不会考虑逻辑</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则返回真</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则返回真</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#else</td>
<td>#if 的替代方案</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td>#error</td>
<td>当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td>#pragma</td>
<td>使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="https://www.runoob.com/cprogramming/c-preprocessors.html" target="_blank">C 预处理器 | 菜鸟教程 (runoob.com)</a></li>
</ul>
<h2 id="参数化的宏"><a name="参数化的宏" class="anchor-navigation-ex-anchor" href="#参数化的宏"><i class="fa fa-link" aria-hidden="true"></i></a>参数化的宏</h2>
<p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：</p>
<pre><code>int square(int x) {
   return x * x;
}
</code></pre><p>我们可以使用宏重写上面的代码，如下：</p>
<pre><code>#define square(x) ((x) * (x))
</code></pre><p>在使用带有参数的宏之前，必须使用 <code>#define</code> 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。<strong>宏名称和左圆括号之间不允许有空格。</strong></p>
<h2 id="条件编译"><a name="条件编译" class="anchor-navigation-ex-anchor" href="#条件编译"><i class="fa fa-link" aria-hidden="true"></i></a>条件编译</h2>
<blockquote>
<p>条件编译（conditional compiling）命令指定预处理器依据特定的条件来判断保留或删除某段源代码。<code>条件编译区域以 #if、#ifdef 或 #ifndef 等命令作为开头，以 #endif 命令结尾。条件编译区域可以有任意数量的 #elif 命令，但最多一个 #else 命令。</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>条件编译指令</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>#if</td>
<td>如果条件为真，则执行相应操作</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面条件为假，而该条件为真，则执行相应操作</td>
</tr>
<tr>
<td>#else</td>
<td>如果前面条件均为假，则执行相应操作</td>
</tr>
<tr>
<td>#endif</td>
<td>结束相应的条件编译指令</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果该宏已定义，则执行相应操作</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果该宏没有定义，则执行相应操作</td>
</tr>
</tbody>
</table>
<ul>
<li>作为 #if 或 #elif 命令条件的表达式，必须是整数常量预处理器表达式。</li>
<li>一元运算符 defined 可以出现在 #if 或 #elif 命令的条件中。</li>
<li><h1 id="if、elif、else-和-endif-指令-cc--microsoft-learn"><a name="if、elif、else-和-endif-指令-cc--microsoft-learn" class="anchor-navigation-ex-anchor" href="#if、elif、else-和-endif-指令-cc--microsoft-learn"><i class="fa fa-link" aria-hidden="true"></i></a>if、#<a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=msvc-170" target="_blank">elif、#else 和 #endif 指令 (C/C++) | Microsoft Learn</a></h1>
</li>
</ul>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span></span>
defined 标识符
defined (标识符)
!defined (标识符)
<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span></span>

---------
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _WIN32</span>
<span class="hljs-keyword">int</span> g_OS = <span class="hljs-number">0</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __LINUX__</span>
<span class="hljs-keyword">int</span> g_OS = <span class="hljs-number">1</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\r\n&quot;</span>, g_OS);

    system(<span class="hljs-string">&quot;pause&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h1 id="结构体"><a name="结构体" class="anchor-navigation-ex-anchor" href="#结构体"><i class="fa fa-link" aria-hidden="true"></i></a>结构体</h1>
<pre><code class="lang-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Test</span> {</span>
    xxx
};

<span class="hljs-comment">// 起别名，相当于 </span>
<span class="hljs-comment">// typedef struct _Test Test;</span>
<span class="hljs-comment">// typedef struct _Test* pTest; </span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Test</span> {</span>
    xxx;
}Test, *pTest;

<span class="hljs-comment">// 使用</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Test</span> <span class="hljs-title">test</span> =</span> {xxxx};
<span class="hljs-comment">// 或者使用别名 </span>
Test test = {xxx};

<span class="hljs-comment">// 使用typedef 起别名后以下是等价的</span>
==&gt; struct _Test   == Test 
==&gt; struct _Test * == pTest


<span class="hljs-comment">// C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> BYTE;
<span class="hljs-comment">// 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写</span>
</code></pre>
<h2 id="对数组成员的赋值"><a name="对数组成员的赋值" class="anchor-navigation-ex-anchor" href="#对数组成员的赋值"><i class="fa fa-link" aria-hidden="true"></i></a>对数组成员的赋值</h2>
<p><img src="assets/Snipaste_2022-10-10_11-46-22-20221010114706-s9h0gzk.png" alt="Snipaste_2022-10-10_11-46-22">​</p>
<pre><code class="lang-c">    <span class="hljs-comment">/**
     * 和以下错误一致，由于数组名是数组的首地址。
     * 数组名表示常量，不允许对常量赋值，所以常量不允许出现在 “=” 的左边，作为左值出现，所以不能直接用字符串赋值给数组名。
     * 可以在定义字符数组的同时用字符串给字符数组赋初值。
     */</span>
    <span class="hljs-keyword">char</span> szName[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;zhaocai&quot;</span>;
    szName = <span class="hljs-string">&quot;zhaocaimao&quot;</span>; <span class="hljs-comment">// error</span>
</code></pre>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">BOOK</span> {</span>
    <span class="hljs-keyword">char</span> szBookName[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">double</span> dPrice;
}Book, *pBook;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    Book book1 = {<span class="hljs-string">&quot;自我修养&quot;</span>, <span class="hljs-number">999.99</span>};
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书名: %s\r\n价格: %lf\r\n&quot;</span>, book1.szBookName, book1.dPrice);

    <span class="hljs-comment">// 动态分配内存</span>
    pBook pBook1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Book));
    <span class="hljs-comment">// pBook1-&gt;szBookName = &quot;论优雅&quot;; // error</span>
    <span class="hljs-built_in">strcpy</span>(pBook1-&gt;szBookName,<span class="hljs-string">&quot;论优雅&quot;</span>); <span class="hljs-comment">// ok</span>
    pBook1-&gt;dPrice = <span class="hljs-number">888.88</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书名: %s\r\n价格: %lf\r\n&quot;</span>, pBook1-&gt;szBookName, pBook1-&gt;dPrice);

    system(<span class="hljs-string">&quot;pause&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li>结构体分匹配的内存是连续的</li>
<li>分配内存  <code>malloc(sizeof(struct xxx))</code></li>
<li><p>. 和 -&gt; 的区别</p>
<p>一般指针用 <code>-&gt;</code> 形式访问成员。</p>
<p>相同点：两个都是二元操作符，其右操作符是成员的名称。</p>
<p>不同点：点操作符左边的操作数是一个“结果为结构”的表达式；</p>
<p>箭头操作符左边的操作数是一个指向结构的指针。</p>
</li>
</ul>
<h2 id="内存对齐"><a name="内存对齐" class="anchor-navigation-ex-anchor" href="#内存对齐"><i class="fa fa-link" aria-hidden="true"></i></a>内存对齐</h2>
<blockquote>
<p>指针加法，类型步进【即 +1 就是加一个类型宽度】</p>
<ul>
<li><a href="https://blog.csdn.net/Leoi_Chan/article/details/105278520#comments_20844298" target="_blank">关于 struct 的字节数计算（对齐）___1478 的博客- CSDN 博客 _struct 字节数</a></li>
</ul>
</blockquote>
<p>类型    对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量）
char                偏移量必须为 sizeof(char) 即 1 的倍数
int                偏移量必须为 sizeof(int) 即 4 的倍数
float                偏移量必须为 sizeof(float)即 4 的倍数
double        偏移量必须为 sizeof(double) 即 8 的倍数
short        偏移量必须为 sizeof(short) 即 2 的倍数
long                偏移量必须为 sizeof(long) 即 4 的倍数
long long        偏移量必须为 sizeof(long long) 即 8 的倍数</p>
<blockquote>
<p>编译器为了提高 CPU 的存储速度， <strong>会对变量的起始地址做了对齐处理</strong> 。</p>
<p>结构体成员对齐是可以进行设置的，比如 <code>Visual Studio --&gt; 属性 --&gt; c/c++ --&gt; 代码生成  --&gt; 结构体成员对齐</code>：注意此处修改的必须是 2^ 的整数倍，不然无法对齐。</p>
<ul>
<li>1 字节（/Zp1）</li>
<li>2 字节（/Zp2）</li>
<li>4 字节（/Zp4）</li>
<li>8 字节（/Zp8）</li>
<li>16 字节（/Zp16）</li>
</ul>
</blockquote>
<p>还可以通过 <code>#pragma pack(n)</code> 来设定变量以 n 字节对齐方式。</p>
<p>n 字节对齐就是说变量存放的起始地址的偏移量有两种情况：</p>
<ul>
<li><strong>第一、如果 n 大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式，</strong></li>
<li><strong>第二、如果 n 小于该变量的类型所占用的字节数，那么偏移量为 n 的倍数，不用满足默认的对齐方式。</strong></li>
</ul>
<p>结构的总大小也有个约束条件，分下面两种情况：如果 n 大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为 n 的倍数。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(push) <span class="hljs-comment">//保存对齐状态</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(4)<span class="hljs-comment">//设定为4字节对齐</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span>{</span>
     <span class="hljs-keyword">char</span> m1;
     <span class="hljs-keyword">double</span> m4;
     <span class="hljs-keyword">int</span>  m3;
};
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(pop)<span class="hljs-comment">//恢复对齐状态</span></span>
<span class="hljs-comment">// 1 + 4 + 8 + 4 = 16</span>
</code></pre>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-comment">/**
 * sizeof(Info) = 40
 * 变量总和 = 6 + 4 + 8 + 2 + 4 + 1 = 25
 * 最大对齐 * 成员个数 = 48
 * 为什么是 40 呢？
 * MSVC 默认对齐是 8 字节（/Zp8）
 * 结构体成员对齐公式：（成员偏移，相对于结构体首地址的偏移）
 *      member offset % min(ZpValue, sizeof(member type)) == 0
 * 结构体对齐公式：
 *      对齐后的结构体大小 % max(member type) == 0
 */</span>
<span class="hljs-comment">// 计算结构体的长度</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Info</span> {</span>
    <span class="hljs-keyword">char</span> szValue[<span class="hljs-number">6</span>];  <span class="hljs-comment">// +0 偏移</span>
    <span class="hljs-keyword">float</span> fValue;     <span class="hljs-comment">// +8【理论上 float 偏移为 0+6 = +6 偏移，实际上根据结构体对齐 offset % min(8, 4) == 0，offset 为 6 不行，7 也不行，最小为 8，即 8 % 4 == 0】对齐了 2 字节</span>
    <span class="hljs-keyword">double</span> dbValue;   <span class="hljs-comment">// +16【以此类推，理论上为 8 + 4（float 占 4 字节） = 12 偏移，实际上 offset % min(8, 8) == 0，offset 最小为 12，13，...，16，即 16 % 8 == 0】对齐了 4 字节</span>
    <span class="hljs-keyword">short</span> sValue;     <span class="hljs-comment">// +24【16 + 8（double 占 2 字节） = 24，那么 offset % min(8, 2) == 0，即 24 % 2 == 0】</span>
    <span class="hljs-keyword">int</span> nValue;       <span class="hljs-comment">// +28【24 + 2 = 26，那么 offset % min(8, 4) == 0，即 28 % 4 == 0】对齐了 2 字节</span>
    <span class="hljs-keyword">char</span> cValue;      <span class="hljs-comment">// +32【28 + 4 = 32，那么 offset % min(8, 1) == 0，即 32 % 1 == 0】</span>
}Info, *pInfo;        <span class="hljs-comment">// 那么就是成员之间的对齐就是 32 + 1（最后的 char 占 1 个字节） = 33，【一共对齐了 8 字节】最后整个结构体也需要对齐。</span>
                      <span class="hljs-comment">// 就是 33 % max(member type) == 0，这个结构体最大的是 double 8 字节，即 33 % 8 == 0。33,34,...,40 最小到 40 才能 40 % 8 == 0</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Info info = {<span class="hljs-string">&quot;zhaoc&quot;</span>, <span class="hljs-number">2.22f</span>, <span class="hljs-number">3.33</span>, <span class="hljs-number">222</span>, <span class="hljs-number">0xFFFFFFFF</span>, <span class="hljs-string">&apos;c&apos;</span>};
    Info info1;
<span class="hljs-comment">//    char c = &apos;c&apos;;</span>
<span class="hljs-comment">//    printf(&quot;%x\r\n&quot;, c);</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(info1)); <span class="hljs-comment">// 40</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(info));

    <span class="hljs-comment">/** &amp;info  【&apos;c&apos; 为 63】
     * 7a 68 61 6f  zhao    ==      7a 68 61 6f
     * 63 00 00 00  c\0     ==      63 00 cc cc
     * 7b 14 0e 40  float   ==      7b 14 0e 40
     * f6 7f 00 00  对齐     ==      cc cc cc cc
     * a4 70 3d 0a  double  ==      a4 70 3d 0a
     * d7 a3 0a 40  double  ==      d7 a3 0a 40
     * de 00 00 00  short   ==      de 00 cc cc
     * ff ff ff ff  int     ==      ff ff ff ff
     * 63 10 63 ed  char    ==      63 cc cc cc
     * f6 7f 00 00  对齐     ==      cc cc cc cc
     * ------还是 visual Studio 的对齐方式更好看一些
     * 那么按道理来说一共是 33 字节，为什么是 40 呢？
     */</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>如果上面的 char 数组大小改为 9 呢？结果又是多少【还是 40 ，哈哈哈哈】，怎么对齐的？</p>
<p>成员对齐了 5 字节，结构体也是对齐了 7 字节。<strong>结构体按类型对齐，非数组大小。</strong></p>
<pre><code class="lang-c"><span class="hljs-comment">// 计算结构体的长度</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Info</span> {</span>
    <span class="hljs-keyword">char</span> szValue[<span class="hljs-number">9</span>];  <span class="hljs-comment">// +0 偏移，相对于结构体首地址的偏移</span>
    <span class="hljs-keyword">float</span> fValue;     <span class="hljs-comment">// +12【理论上是 9，对齐了 3 字节】</span>
    <span class="hljs-keyword">double</span> dbValue;   <span class="hljs-comment">// +16【理论上和实际上都是 16，不用对齐】</span>
    <span class="hljs-keyword">short</span> sValue;     <span class="hljs-comment">// +24【理论上和实际上都是 24，不用对齐】</span>
    <span class="hljs-keyword">int</span> nValue;       <span class="hljs-comment">// +28【理论上是 26，对齐了 2 字节】</span>
    <span class="hljs-keyword">char</span> cValue;      <span class="hljs-comment">// +32【理论上和实际上都是 32，不用对齐】</span>
}Info, *pInfo;        <span class="hljs-comment">// 那么就是成员之间的对齐就是 32 + 1（最后的 char 占 1 个字节） = 33，最后整个结构体也需要对齐。</span>
                      <span class="hljs-comment">// 就是 33 % max(member type) == 0，这个结构体最大的类型还是 double 8 字节，即 33 % 8 == 0。33,34,...,40 最小到 40 才能 40 % 8 == 0</span>
如果 <span class="hljs-keyword">double</span> 改成 <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> 那么就是 <span class="hljs-number">33</span> % <span class="hljs-number">16</span> == <span class="hljs-number">0</span>，需要再加 <span class="hljs-number">15</span> 字节，即 <span class="hljs-number">48</span> % <span class="hljs-number">16</span> == <span class="hljs-number">0</span>
</code></pre>
<p><code>char szValue[99]</code> 呢？【128】</p>
<pre><code class="lang-c"><span class="hljs-comment">// 计算结构体的长度</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Info</span> {</span>
    <span class="hljs-keyword">char</span> szValue[<span class="hljs-number">99</span>];  <span class="hljs-comment">// +0 偏移</span>
    <span class="hljs-keyword">float</span> fValue;     <span class="hljs-comment">// +100【理论上是 99，对齐了 1 字节】</span>
    <span class="hljs-keyword">double</span> dbValue;   <span class="hljs-comment">// +104【理论上和实际上都是 104，不用对齐】</span>
    <span class="hljs-keyword">short</span> sValue;     <span class="hljs-comment">// +112【理论上和实际上都是 112，不用对齐】</span>
    <span class="hljs-keyword">int</span> nValue;       <span class="hljs-comment">// +114【理论上和实际上都是 114，不用对齐】</span>
    <span class="hljs-keyword">char</span> cValue;      <span class="hljs-comment">// +120【理论上是 118，对齐了 2 字节】</span>
}Info, *pInfo;        <span class="hljs-comment">// 那么就是成员之间的对齐就是 120 + 1（最后的 char 占 1 个字节） = 121，最后整个结构体也需要对齐。</span>
<span class="hljs-comment">// 就是 121 % max(member type) == 0，这个结构体最大的类型还是 double 8 字节，即 121 % 8 == 0。121,122,...,128 最小到 128 才能 128 % 8 == 0</span>
</code></pre>
<p><strong>补充：嵌套类型（含结构体成员）</strong></p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 *  规则一：结构体中的第一个成员位置在偏移量 0，之后每个变量的偏移量必须是它本身字节数的整数倍。

 *  规则二：如果结构体中嵌套结构体，那么嵌套的结构体的偏移量必须是它最大成员的字节数的整数倍。

 * ★规则三：结构体的总偏移量必须是它最大成员字节数的整数倍（包括嵌套的结构体中的最大成员）。★

 * 如果一个结构体 B 里嵌套另一个结构体 A，还是以最大成员类型的字节对齐，但是结构体 A 存储起点为 A 内部最大成员整数倍的地方。
 * （struct B 里存有 struct A，A 里有 char，int，double 等成员，那 A 应该从 8 的整数倍开始存储。）
 *  结构体 A 中的成员的对齐规则仍满足自身的规则 
 * 注意： 
    1）结构体 A 整体所占的大小为该结构体成员内部最大元素的整数倍，不足补齐。 
    2）不是直接将结构体 A 的成员直接移动到结构体 B 中。
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test1</span>{</span>
     <span class="hljs-keyword">char</span> m1;    <span class="hljs-comment">// +0 【偏移】</span>
     <span class="hljs-keyword">double</span> m4;  <span class="hljs-comment">// +8 【补齐了 7 字节】</span>
     <span class="hljs-keyword">int</span>  m3;    <span class="hljs-comment">// +16  ==&gt; 16 +  1 = 17 % 8 == 0 ==&gt; 24 % 8 == 0</span>
}; <span class="hljs-comment">// 1 + 7 + 8  + 4 = 20 + 4 = 24</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test2</span>{</span>
     <span class="hljs-keyword">char</span> m1;
     <span class="hljs-keyword">double</span> m4; <span class="hljs-comment">// 若改为 int 则为1 + 3 + 4 = 8 + 24 = 32 刚好是8 字节的倍数，因为 test1 的最大字节为8，故 sizeof(test2) 为 32</span>
     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test1</span> <span class="hljs-title">test</span>;</span> 
}; <span class="hljs-comment">// 1 + 7 + 8 = 16 + 24 = 40 为什么不是和 24 对齐？【就好像前面的数组大小一样】</span>
   <span class="hljs-comment">// 对齐了因为结构体 test2 是以 double 字节对齐的（最大）与结构体成员 test1 的整体大小无关 40 刚好是8 的倍数</span>

<span class="hljs-comment">/*
struct test2 {
    char m1;  //1 + 1 + 1 + 1 + 1 + 3 + 4 = 12 + 24 = 36 + 4 == 40 恰好为 double 字节的倍数
    char m2;
    char m3;
    char m4;
    char m5;
    int m6;  
    struct test1 test; 
};
*/</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(test1) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 24 </span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(test2); <span class="hljs-comment">// 40</span>

    system(<span class="hljs-string">&quot;pause&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="指针访问结构体"><a name="指针访问结构体" class="anchor-navigation-ex-anchor" href="#指针访问结构体"><i class="fa fa-link" aria-hidden="true"></i></a>指针访问结构体</h2>
<pre><code class="lang-c"><span class="hljs-comment">/**
     * 比如访问 int nValue 这个成员变量
     * 一般来说指针已经指向结构体的首地址，直接 pInfo1 + 28 就可以找到对应的成员变量。
     * 实际上还得考虑指针的步进问题，指针定义成什么类型 + （步进）就是什么类型。
     * 比如，int * p; p + 28，那么就是 +（步进了） 28 个 int 类型，即 p + 28 * 4
     * pInfo1 + 28 那就是 + 了 28 个结构体类型。就超标了，所以要将指针转换为 char * 类型再步进。
     * (char *)pInfo1 + 28 指向了 int nValue 成员变量，再将指针转换为 int * 指针，即
     * (int *)((char *)pInfo1 + 28)，最后再通过 * 取出对应的值。
     */</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%X\r\n&quot;</span>, *(<span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">char</span> *)pInfo1 + <span class="hljs-number">28</span>));
</code></pre>
<h2 id="位域"><a name="位域" class="anchor-navigation-ex-anchor" href="#位域"><i class="fa fa-link" aria-hidden="true"></i></a>位域</h2>
<p>可以<strong>定义变量的宽度</strong>来告诉编译器，只使用哪些字节。有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为&quot;位域&quot;或&quot;位段&quot;。所谓&quot;位域&quot;是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<pre><code class="lang-c"><span class="hljs-comment">// 位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> 位域结构名 {</span>
    位域列表
};

<span class="hljs-comment">//其中位域列表的形式为：</span>
type [member_name] : width ;

----------
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bs</span> {</span>
    <span class="hljs-keyword">int</span> a:<span class="hljs-number">8</span>;
    <span class="hljs-keyword">int</span> b:<span class="hljs-number">2</span>;
    <span class="hljs-keyword">int</span> c:<span class="hljs-number">6</span>;
}data;
<span class="hljs-comment">// data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</span>

<span class="hljs-comment">// 使用</span>
位域变量名.位域名
位域变量名-&gt;位域名
</code></pre>
<table>
<thead>
<tr>
<th>元素</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。</td>
</tr>
<tr>
<td>member_name</td>
<td>位域的名称。</td>
</tr>
<tr>
<td>width</td>
<td>位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td>
</tr>
</tbody>
</table>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct {
    unsigned int age : 3; // 三位二进制可以表示 8 种状态 2^3 次方 000, 001, 010,...,111
} Age;

int main() {
    Age.age = 4;
    printf(&quot;Sizeof( Age ) : %d\n&quot;, sizeof(Age) );
    printf(&quot;Age.age : %d\n&quot;, Age.age );

    Age.age = 7;
    printf(&quot;Age.age : %d\n&quot;, Age.age );

    Age.age = 8; // 二进制表示为 1000 有四位，超出
    printf(&quot;Age.age : %d\n&quot;, Age.age );

    return 0;
}

----------
warning: unsigned conversion from &apos;int&apos; to &apos;unsigned char:3&apos; changes value from &apos;8&apos; to &apos;0&apos; [-Woverflow]

----------
D:\CPP_Project\Test1\cmake-build-debug\Test1.exe
Sizeof( Age ) : 4
Age.age : 4
Age.age : 7
Age.age : 0
</code></pre>
<p><strong>对于位域的定义尚有以下几点说明：</strong></p>
<ul>
<li><p>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：</p>
<pre><code class="lang-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bs</span> {</span>
    <span class="hljs-keyword">unsigned</span> a:<span class="hljs-number">4</span>;
    <span class="hljs-keyword">unsigned</span>  :<span class="hljs-number">4</span>;    <span class="hljs-comment">/* 空域，该 4 位不能使用*/</span>
    <span class="hljs-keyword">unsigned</span> b:<span class="hljs-number">4</span>;    <span class="hljs-comment">/* 从下一单元开始存放 */</span>
    <span class="hljs-keyword">unsigned</span> c:<span class="hljs-number">4</span>
}
</code></pre>
<p>在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</p>
</li>
<li>位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，<code>:</code> 后面的数字不能超过这个长度。</li>
<li>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。</li>
</ul>
<h1 id="联合体（共用体）"><a name="联合体（共用体）" class="anchor-navigation-ex-anchor" href="#联合体（共用体）"><i class="fa fa-link" aria-hidden="true"></i></a>联合体（共用体）</h1>
<blockquote>
<p><strong>共用体</strong>是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，<strong>但是任何时候只能有一个成员带有值</strong>。共用体提供了一种使用相同的内存位置的有效方式。union</p>
</blockquote>
<p>共用体占用的内存应足够存储共用体中最大的成员。例如，在下面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Data</span> {</span>
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">float</span> f;
    <span class="hljs-keyword">char</span>  str[<span class="hljs-number">20</span>];
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Data</span> <span class="hljs-title">data</span>;</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Memory size occupied by data : %d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(data));

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h1 id="枚举"><a name="枚举" class="anchor-navigation-ex-anchor" href="#枚举"><i class="fa fa-link" aria-hidden="true"></i></a>枚举</h1>
<p>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。</p>
<pre><code class="lang-c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举名 {</span>枚举元素<span class="hljs-number">1</span>,枚举元素<span class="hljs-number">2</span>,……};
</code></pre>
<pre><code>enum DAY {
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
</code></pre><p><strong>注意：</strong> 第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<p>可以在定义枚举类型时改变枚举元素的值：</p>
<pre><code>enum season {
    spring, 
    summer=3, 
    autumn, 
    winter
};

// 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5
</code></pre><h1 id="文件操作"><a name="文件操作" class="anchor-navigation-ex-anchor" href="#文件操作"><i class="fa fa-link" aria-hidden="true"></i></a>文件操作</h1>
<h2 id="打开文件"><a name="打开文件" class="anchor-navigation-ex-anchor" href="#打开文件"><i class="fa fa-link" aria-hidden="true"></i></a>打开文件</h2>
<p>您可以使用 <code>fopen()</code> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <strong>FILE</strong> 的一个对象，类型 <strong>FILE</strong> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p>
<pre><code class="lang-c"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode )</span></span>;
</code></pre>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r</code></td>
<td>打开一个已有的文本文件，允许读取文件。<code>read</code></td>
</tr>
<tr>
<td><code>w</code></td>
<td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件，重新写入。<code>write</code></td>
</tr>
<tr>
<td><code>a</code></td>
<td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。<code>append</code></td>
</tr>
<tr>
<td><code>r+</code></td>
<td>打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td><code>w+</code></td>
<td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td><code>a+</code></td>
<td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody>
</table>
<p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p>
<pre><code class="lang-c"><span class="hljs-string">&quot;rb&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;rb+&quot;</span>, <span class="hljs-string">&quot;r+b&quot;</span>, <span class="hljs-string">&quot;wb+&quot;</span>, <span class="hljs-string">&quot;w+b&quot;</span>, <span class="hljs-string">&quot;ab+&quot;</span>, <span class="hljs-string">&quot;a+b&quot;</span>

<span class="hljs-comment">// 读模式的方式打开第一个文件流，并且以二进制流的方式。由于二进制的方式，C 语言不进行任何转换，所以如果在 windows 下，该方式会看到行结尾符由一个 \r\n 两个字符组成；在 Linux 下则只有一个 \n；在苹果机下面则是 \r；如果以文本方式打开（不加 b 的模式），C 语言在调用 fread 的时候会将文本视图的行尾符统一转化成 \n，然后在调用 fwrite 的时候再根据操作系统转化成相应的行尾符。</span>
</code></pre>
<h2 id="关闭文件"><a name="关闭文件" class="anchor-navigation-ex-anchor" href="#关闭文件"><i class="fa fa-link" aria-hidden="true"></i></a>关闭文件</h2>
<p>为了关闭文件，请使用 <code>fclose( )</code> 函数。函数的原型如下：</p>
<pre><code class="lang-c"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fclose</span><span class="hljs-params">( FILE *fp )</span></span>;
</code></pre>
<p>如果成功关闭文件，<code>fclose()</code> 函数返回<strong>零</strong>，如果关闭文件时发生错误，函数返回  <strong>EOF</strong> 。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <code>stdio.h</code> 中的常量。</p>
<h2 id="写文件"><a name="写文件" class="anchor-navigation-ex-anchor" href="#写文件"><i class="fa fa-link" aria-hidden="true"></i></a>写文件</h2>
<p>下面是把字符写入到流中的最简单的函数：</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputc</span><span class="hljs-params">( <span class="hljs-keyword">int</span> c, FILE *fp )</span></span>;
</code></pre>
<p>函数 <code>fputc()</code> 把参数 c 的<strong>字符值</strong>写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回  <strong>EOF</strong> 。还可以使用下面的函数来把一个以 null 结尾的<strong>字符串</strong>写入到流中：</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s, FILE *fp )</span></span>;
</code></pre>
<p>函数 <code>fputs()</code> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回  <strong>EOF</strong> 。您也可以使用 <code>int fprintf(FILE *fp,const char *format, ...)</code> 函数把一个字符串写入到文件中。尝试下面的实例：</p>
<blockquote>
<p><strong>注意：</strong> 请确保您有可用的 <strong>tmp</strong> 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。</p>
<p><code>/tmp</code> 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: <code>C:\tmp、D:\tmp</code> 等。</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-comment">// 写文件</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">WriteFile</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * szFilePath, <span class="hljs-keyword">char</span> * szBuffer)</span> </span>{
    FILE * pFile = <span class="hljs-literal">NULL</span>;
    pFile = fopen(szFilePath, <span class="hljs-string">&quot;w&quot;</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFile) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open file failed!\r\n&quot;</span>);
        fclose(pFile);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">int</span> nRet = fwrite(szBuffer, (<span class="hljs-built_in">strlen</span>(szBuffer + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)), <span class="hljs-number">1</span>, pFile);
    fclose(pFile);

    <span class="hljs-keyword">return</span> nRet;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// &quot;D:\CPP_Project\Test1\cmake-build-debug\text.txt&quot;</span>
    WriteFile(<span class="hljs-string">&quot;text.txt&quot;</span>, <span class="hljs-string">&quot;zhaocai mao~&quot;</span>);

    system(<span class="hljs-string">&quot;pause&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    FILE *fp = <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">// &quot;D:\tmp\fputsTest.txt&quot;</span>
    fp = fopen(<span class="hljs-string">&quot;d:/tmp/fputsTest.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);
    <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;This is testing for fprintf...\n&quot;</span>);
    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;This is testing for fputs...\n&quot;</span>, fp);
    fclose(fp);
}
</code></pre>
<h2 id="读文件"><a name="读文件" class="anchor-navigation-ex-anchor" href="#读文件"><i class="fa fa-link" aria-hidden="true"></i></a>读文件</h2>
<ul>
<li><a href="https://www.runoob.com/cprogramming/c-function-fseek.html" target="_blank">C 库函数 – fseek() | 菜鸟教程 (runoob.com)</a></li>
</ul>
<h3 id="fseek"><a name="fseek" class="anchor-navigation-ex-anchor" href="#fseek"><i class="fa fa-link" aria-hidden="true"></i></a>fseek()</h3>
<p><strong>描述</strong></p>
<p>C 库函数  <code>int fseek(FILE *stream, long int offset, int whence)</code> 设置流 <strong>stream</strong> 的文件位置为给定的偏移  <strong>offset</strong> ，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<p><strong>声明</strong></p>
<p>下面是 fseek() 函数的声明。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> whence)</span>
</span></code></pre>
<p><strong>参数</strong></p>
<ul>
<li><strong>stream</strong> -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li><strong>offset</strong> -- 这是相对 whence 的偏移量，以字节为单位。为正时，向后移动；为负时，向前移动。</li>
<li><p><strong>whence</strong> -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</p>
<p>|常量|描述|
| :---------| :-------------------|
|SEEK_SET|文件的开头|
|SEEK_CUR|文件指针的当前位置|
|SEEK_END|文件的末尾|</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<p>如果成功，则该函数返回零，否则返回非零值。</p>
<h3 id="ftell"><a name="ftell" class="anchor-navigation-ex-anchor" href="#ftell"><i class="fa fa-link" aria-hidden="true"></i></a>ftell()</h3>
<p><strong>描述</strong></p>
<p>C 库函数 <code>long int ftell(FILE *stream)</code> 返回给定流 stream 的当前文件位置，用来获取文件内部指针(位置指针)距离文件开头的字节数。【返回文件一共有多少个字节】</p>
<p><strong>声明</strong></p>
<p>下面是 ftell() 函数的声明。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ftell</span><span class="hljs-params">(FILE *stream)</span>
</span></code></pre>
<p><strong>参数</strong></p>
<ul>
<li><strong>stream</strong> -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
</ul>
<p><strong>返回值</strong></p>
<p>该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
   FILE *fp;
   <span class="hljs-keyword">int</span> len;

   fp = fopen(<span class="hljs-string">&quot;text.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
   <span class="hljs-keyword">if</span>( fp == <span class="hljs-literal">NULL</span> ) {
      perror (<span class="hljs-string">&quot;打开文件错误&quot;</span>);
      <span class="hljs-keyword">return</span>(<span class="hljs-number">-1</span>);
   }
   fseek(fp, <span class="hljs-number">0</span>, SEEK_END);

   len = ftell(fp);
   fclose(fp);

   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;text.txt 的总大小 = %d 字节\n&quot;</span>, len);

   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}

<span class="hljs-comment">// 换行符占 1 字节 \n</span>
----------
假设我们有一个文本文件 text.txt，它的内容如下：
zhaocai mao
----------
D:\CPP_Project\Test1\cmake-build-debug\Test1.exe
text.txt 的总大小 = <span class="hljs-number">11</span> 字节
</code></pre>
<h3 id="rewind"><a name="rewind" class="anchor-navigation-ex-anchor" href="#rewind"><i class="fa fa-link" aria-hidden="true"></i></a>rewind()</h3>
<p><strong>描述</strong></p>
<p>C 库函数 <code>void rewind(FILE *stream)</code> 设置文件位置为给定流 <strong>stream</strong> 的文件的开头。用来将位置指针移动到文件开头。</p>
<p><strong>声明</strong></p>
<p>下面是 rewind() 函数的声明。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewind</span><span class="hljs-params">(FILE *stream)</span>
</span></code></pre>
<p><strong>参数</strong></p>
<ul>
<li><strong>stream</strong> -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
</ul>
<p><strong>返回值</strong></p>
<p>该函数不返回任何值。</p>
<h3 id="fgetcfgets"><a name="fgetcfgets" class="anchor-navigation-ex-anchor" href="#fgetcfgets"><i class="fa fa-link" aria-hidden="true"></i></a>fgetc()/fgets()</h3>
<p>下面是从文件读取单个字符的最简单的函数：</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetc</span><span class="hljs-params">( FILE * fp )</span></span>;
</code></pre>
<p><code>fgetc()</code> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回  <code>EOF</code> 。下面的函数允许您从流中读取一个字符串：</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">( <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">int</span> n, FILE *fp )</span></span>;
</code></pre>
<p>函数 <code>fgets()</code> 从 fp 所指向的输入流中读取 <code>n - 1</code> 个字符。它会把读取的字符串复制到缓冲区  <strong>buf</strong> ，并在最后追加一个 <code>null</code> 字符来终止字符串。</p>
<p>如果这个函数在读取最后一个字符之前就遇到一个换行符 <code>&apos;\n&apos;</code> 或文件的末尾 <code>EOF</code>，则只会返回读取到的字符，包括换行符。您也可以使用 <code>int fscanf(FILE *fp, const char *format, ...)</code> 函数来从文件中读取字符串，但是在<strong>遇到第一个空格和换行符时，它会停止读取。</strong></p>
<h3 id="按字节读取"><a name="按字节读取" class="anchor-navigation-ex-anchor" href="#按字节读取"><i class="fa fa-link" aria-hidden="true"></i></a>按字节读取</h3>
<p><strong>只能读取单字节的字母</strong></p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-comment">// 读文件</span>
<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * szFilePath)</span> </span>{
   FILE *pFile = <span class="hljs-literal">NULL</span>;
   <span class="hljs-keyword">char</span> * szReadBuffer = <span class="hljs-literal">NULL</span>;
   <span class="hljs-keyword">int</span> nReadFileSize = <span class="hljs-number">0</span>;

   <span class="hljs-comment">// 打开文件，需要传入绝对路径</span>
   pFile = fopen(szFilePath, <span class="hljs-string">&quot;rb&quot;</span>);
   <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFile) {
       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Open file failed!\r\n&quot;</span>);
       fclose(pFile);
       <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
   }

   <span class="hljs-comment">// 计算文件长度</span>
   fseek(pFile, <span class="hljs-number">0</span>, SEEK_END);
   nReadFileSize = ftell(pFile);
   rewind(pFile);
   <span class="hljs-comment">//fseek(pFile, 0, SEEK_SET);</span>

   <span class="hljs-comment">// 分配读取缓存大小</span>
   szReadBuffer = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>((<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * nReadFileSize) + <span class="hljs-number">1</span>);
   <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == szReadBuffer) {
       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc memory failed!\r\n&quot;</span>);
       fclose(pFile);
       <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
   }
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;分配了 %d 字节\r\n&quot;</span>, (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * (nReadFileSize)) + <span class="hljs-number">1</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件一共 %d 字节\r\n&quot;</span>, nReadFileSize);

   <span class="hljs-comment">// 初始化内存</span>
   <span class="hljs-comment">/**
    * 38 和 28 会有不一样的结果
    * 38：zhaocai mao dd dd dddd ddddd
    * 28：zhaocai mao dd dd dddd dddddrogramData
    *
    * 为什么就会打印 38 个字符呢？明明只申请了 28 个。
    */</span>
   <span class="hljs-built_in">memset</span>(szReadBuffer, <span class="hljs-number">0</span>, nReadFileSize + <span class="hljs-number">1</span>);
   <span class="hljs-keyword">int</span> nResLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录实际读到的长度</span>
   nResLength = fread(szReadBuffer,  <span class="hljs-number">1</span>, nReadFileSize,pFile); <span class="hljs-comment">// 按 1 字节读取</span>
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;读取了 %d 字节\r\n&quot;</span>, <span class="hljs-built_in">strlen</span>(szReadBuffer));

   <span class="hljs-comment">/**
    * 注意这个长度计算在有换行符号的情况下：
    * - fread() 会计算成 1 字节
    * - ftell() 会计算成 2 字节
    *
    * 搞了半天原来是我的 memset 初始化的时候 size 设置为了 nReadFileSize，忘记 + 1 了。
    */</span>
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ftell : %d 字节\r\n&quot;</span>, nReadFileSize);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fread : %d 字节\r\n&quot;</span>, nResLength);

   <span class="hljs-comment">// 现在的写法在有换行的情况下会读取失败</span>
   <span class="hljs-keyword">if</span> (nResLength != nReadFileSize) {
       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read file failed !\r\n&quot;</span>);
       fclose(pFile);
       <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
   }
   fclose(pFile);

   <span class="hljs-keyword">return</span> szReadBuffer;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">char</span> * szReadBufferRet = <span class="hljs-literal">NULL</span>;

    szReadBufferRet = ReadFile(<span class="hljs-string">&quot;D:\\tmp\\text.txt&quot;</span>);
    <span class="hljs-comment">//printf(&quot;%d\r\n&quot;, strlen(szReadBufferRet));</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, szReadBufferRet);
    <span class="hljs-built_in">free</span>(szReadBufferRet);

    <span class="hljs-comment">//system(&quot;pause&quot;);</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code class="lang-c"><span class="hljs-comment">// 按照字符和行标识读取文本</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-comment">// 读文件</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * szFilePath)</span> </span>{
   FILE *pFile = <span class="hljs-literal">NULL</span>;
   <span class="hljs-keyword">char</span> c;
   <span class="hljs-keyword">int</span> nLine = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于统计行数</span>

   <span class="hljs-comment">// 打开文件</span>
   pFile = fopen(szFilePath, <span class="hljs-string">&quot;rb&quot;</span>);
   <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFile) {
       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Open file failed!\r\n&quot;</span>);
       fclose(pFile);
       <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
   }

   <span class="hljs-keyword">while</span> ((c = fgetc(pFile)) != EOF) {
       <span class="hljs-keyword">if</span> (<span class="hljs-string">&apos;\n&apos;</span> == c) {
           nLine ++;
       }
       <span class="hljs-comment">//putchar(c);</span>
       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,c);
   }

   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n该文本一共 %d 行~\r\n&quot;</span>, nLine);

   fclose(pFile);
   <span class="hljs-keyword">return</span> ;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    ReadFile(<span class="hljs-string">&quot;D:\\tmp\\text.txt&quot;</span>);

    <span class="hljs-comment">//system(&quot;pause&quot;);</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>按行读取文本</strong></p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-comment">// 读文件</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *szFilePath)</span> </span>{
    FILE *pFile = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">int</span> nReadFileSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> nLines = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于统计行数</span>
    <span class="hljs-keyword">char</span> * szReadBuffer = <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">// 打开文件</span>
    pFile = fopen(szFilePath, <span class="hljs-string">&quot;rb&quot;</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFile) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Open file failed!\r\n&quot;</span>);
        fclose(pFile);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">// 计算要读取文本的大小</span>
    fseek(pFile, <span class="hljs-number">0</span>, SEEK_END);
    nReadFileSize = ftell(pFile);
    rewind(pFile); <span class="hljs-comment">// 将文件内部指针恢复到文件头</span>

    <span class="hljs-comment">// 分配内存，这里是不是可以优化一下每行最多分配多少空间呢？我也不知道</span>
    szReadBuffer = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>((<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * nReadFileSize) + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == szReadBuffer) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc memory failed!\r\n&quot;</span>);
        fclose(pFile);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;分配了 %d 字节\r\n&quot;</span>, (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * (nReadFileSize)) + <span class="hljs-number">1</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件一共 %d 字节\r\n&quot;</span>, nReadFileSize);

    <span class="hljs-comment">// 初始化内存空间</span>
    <span class="hljs-built_in">memset</span>(szReadBuffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(szReadBuffer) + <span class="hljs-number">1</span>);

    <span class="hljs-keyword">while</span> (fgets(szReadBuffer, nReadFileSize + <span class="hljs-number">1</span>, pFile) != <span class="hljs-literal">NULL</span>) {
        nLines ++; <span class="hljs-comment">// 统计行数</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, szReadBuffer);<span class="hljs-comment">// 打印文本</span>
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n该文本一共 %d 行~\r\n&quot;</span>, nLines);

    fclose(pFile);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    ReadFile(<span class="hljs-string">&quot;D:\\tmp\\text.txt&quot;</span>);

    <span class="hljs-comment">//system(&quot;pause&quot;);</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>‍</p>
<p>‍</p>
<h3 id="错误调试"><a name="错误调试" class="anchor-navigation-ex-anchor" href="#错误调试"><i class="fa fa-link" aria-hidden="true"></i></a>错误调试</h3>
<ul>
<li><p>Debug -- 监视 -- 输入 <code>err,hr</code> 就可以进行调试</p>
<p><img src="assets/image-20221012115036-u7r8ect.png" alt="image">​</p>
</li>
<li><p>修改文件读取权限</p>
<p><img src="assets/image-20221012115950-i7a6fel.png" alt="image">​</p>
</li>
</ul>
<h3 id="error"><a name="error" class="anchor-navigation-ex-anchor" href="#error"><i class="fa fa-link" aria-hidden="true"></i></a>ERROR</h3>
<ul>
<li><p><strong>输出乱码</strong>：程序的入口处 <code>main()</code> 函数中，添加 <code>system(&quot;chcp 65001 &gt; nul&quot;);</code> 【可以在渗透的时候使用，比如 CS 输入：<code>chcp 65001</code> 改变编码格式】</p>
<p>将 txt 文本编码格式改成 ANSI：打开记事本-&gt; 文件-&gt; 另存为-&gt; 更改编码格式为 ANSI-&gt; 保存。</p>
</li>
<li><p><a href="https://blog.csdn.net/hhduyc/article/details/83856821" target="_blank">(44 条消息) Debug Assertion Failed 问题怎么解决_很萌很蠢的博客-CSDN 博客</a></p>
<p><img src="assets/Snipaste_2022-10-11_17-41-00-20221011174143-kdvmgg9.png" alt="Snipaste_2022-10-11_17-41-00"></p>
<pre><code class="lang-c"><span class="hljs-number">1</span>、按 F5 运行你的程序 
<span class="hljs-number">2</span>、在出错时，选择“重试” 
<span class="hljs-number">3</span>、按 ALT+<span class="hljs-number">7</span> 调出“调用栈”窗口 
<span class="hljs-number">4</span>、双击从上往下的最近一个自己定义的函数，系统会自动把该函数所在的文件显示出来，此时程序就暂停在光标处。一般来说错误就出在这附近。你可以通过查看变量的值来确认。
</code></pre>
</li>
<li><p>无法查找或打开 PDB 文件问题：<a href="http://c.biancheng.net/view/474.html" target="_blank">VS“无法查找或打开 PDB 文件”是怎么回事？如何解决 (biancheng.net)</a></p>
<ul>
<li>调试 -- 选项 -- 调试 -- 常规 -- 启用服务器资源支持</li>
<li>调试 -- 选项 -- 调试 -- 字符 -- Microsoft 符号服务器</li>
</ul>
<p><img src="assets/image-20221012093521-sd7th9i.png" alt="image">​</p>
<p><img src="assets/image-20221012093530-fhq66ql.png" alt="image">​</p>
</li>
</ul>
<h1 id="练习"><a name="练习" class="anchor-navigation-ex-anchor" href="#练习"><i class="fa fa-link" aria-hidden="true"></i></a>练习</h1>
<h2 id="练习-1"><a name="练习-1" class="anchor-navigation-ex-anchor" href="#练习-1"><i class="fa fa-link" aria-hidden="true"></i></a>练习 1</h2>
<ol>
<li><p>构造一个书籍信息结构体，并且使用<strong>结构体数组</strong>声明 100 个元素，编写增删改查 4 个函数</p>
<p> <strong>头文件</strong></p>
<pre><code class="lang-c"> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

 <span class="hljs-comment">// 定义书的链表结构</span>
 <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">BookNode</span> {</span>
     <span class="hljs-keyword">char</span> szBookName[<span class="hljs-number">100</span>];
     <span class="hljs-keyword">int</span> nBookNumber;
     <span class="hljs-keyword">double</span> dPrice;
     <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">BookNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 指向下一节点</span>
 }BookNode, *pBookNode;

 <span class="hljs-comment">// 定义添加书籍函数（简陋版先以书名作为唯一标识吧！）</span>
 <span class="hljs-function">pBookNode <span class="hljs-title">AppendBook</span><span class="hljs-params">(pBookNode head, <span class="hljs-keyword">char</span> *pBookName, <span class="hljs-keyword">int</span> nBookNumber, <span class="hljs-keyword">double</span> dPrice)</span></span>;

 <span class="hljs-comment">// 查询书籍</span>
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SearchBook</span><span class="hljs-params">(pBookNode head, <span class="hljs-keyword">char</span> * szBookName)</span></span>;

 <span class="hljs-comment">// 显示所有书籍</span>
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayAllBook</span><span class="hljs-params">(pBookNode head)</span></span>;

 <span class="hljs-comment">// 修改书籍信息(定价)</span>
 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ModifyBookInfo</span><span class="hljs-params">(pBookNode head, <span class="hljs-keyword">char</span> * szBookName, <span class="hljs-keyword">double</span> dPrice)</span></span>;

 <span class="hljs-comment">// 删除书籍</span>
 <span class="hljs-function">pBookNode <span class="hljs-title">DeleteBook</span><span class="hljs-params">(pBookNode head, <span class="hljs-keyword">char</span> * szBookName)</span></span>;
</code></pre>
<p> <strong>源码</strong></p>
<pre><code class="lang-c"> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span>

 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-comment">//pBookNode == BookNode *</span>
     pBookNode head = <span class="hljs-literal">NULL</span>;

     <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
         <span class="hljs-keyword">int</span> nOperate;
         <span class="hljs-keyword">char</span> szBookName[<span class="hljs-number">100</span>];
         <span class="hljs-keyword">int</span> nBookNumber;
         <span class="hljs-keyword">double</span> dBookPrice;

         <span class="hljs-comment">// 提示信息</span>
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请选择需要进行的操作：\r\n&quot;</span>);
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1. 添加书籍\r\n&quot;</span>);
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2. 所有书籍\r\n&quot;</span>);
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3. 查找书籍\r\n&quot;</span>);
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. 修改书籍\r\n&quot;</span>);
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5. 删除书籍\r\n&quot;</span>);

         <span class="hljs-comment">// 选择操作</span>
         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nOperate);
         <span class="hljs-keyword">switch</span> (nOperate) {
             <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: {
                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入书名：&quot;</span>);
                 <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, szBookName);
                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入书号：&quot;</span>);
                 <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nBookNumber);
                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入定价：&quot;</span>);
                 <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;dBookPrice);
                 head = AppendBook(head, szBookName, nBookNumber, dBookPrice);
                 <span class="hljs-keyword">break</span>;
             }
             <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: {
                 DisplayAllBook(head);
                 <span class="hljs-keyword">break</span>;
             }
             <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: {
                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入书名进行查询：&quot;</span>);
                 <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, szBookName);
                 SearchBook(head, szBookName);
                 <span class="hljs-keyword">break</span>;
             }
             <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: {
                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要修改的书籍名称：&quot;</span>);
                 <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, szBookName);
                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入更新的定价：&quot;</span>);
                 <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;dBookPrice);
                 ModifyBookInfo(head, szBookName, dBookPrice);
                 <span class="hljs-keyword">break</span>;
             }
             <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: {
                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要删除的书籍名称：&quot;</span>);
                 <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, szBookName);
                 DeleteBook(head, szBookName);
                 <span class="hljs-keyword">break</span>;
             }
             <span class="hljs-keyword">default</span>:
                 <span class="hljs-keyword">break</span>;
         }
     }

     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }

 <span class="hljs-comment">// 添加书籍，后续可以让书号唯一~</span>
 <span class="hljs-function">pBookNode <span class="hljs-title">AppendBook</span><span class="hljs-params">(pBookNode head, <span class="hljs-keyword">char</span> *pBookName, <span class="hljs-keyword">int</span> nBookNumber, <span class="hljs-keyword">double</span> dPrice)</span> </span>{
     <span class="hljs-comment">// 定义新的节点和头结点</span>
     pBookNode pNewBookNode = <span class="hljs-literal">NULL</span>;
     pBookNode pHeadBookNode= head;

     <span class="hljs-comment">// 分配内存</span>
     pNewBookNode = (pBookNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BookNode));
     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pNewBookNode) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memory malloc failed!\r\n&quot;</span>);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }

     <span class="hljs-comment">// 如果链表一开始为空，那么新建的就是头节点</span>
     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pHeadBookNode) {
         head = pNewBookNode;
     } <span class="hljs-keyword">else</span> {
         <span class="hljs-comment">// 将指针移动到后面进行添加</span>
         <span class="hljs-keyword">while</span> (pHeadBookNode-&gt;next != <span class="hljs-literal">NULL</span>) {
             pHeadBookNode = pHeadBookNode-&gt;next;
         }
         pHeadBookNode-&gt;next = pNewBookNode;
     }

     <span class="hljs-comment">// 添加书籍信息</span>
     <span class="hljs-built_in">strcpy</span>(pNewBookNode-&gt;szBookName, pBookName);
     pNewBookNode-&gt;nBookNumber = nBookNumber;
     pNewBookNode-&gt;dPrice = dPrice;
     pNewBookNode-&gt;next = <span class="hljs-literal">NULL</span>;

     <span class="hljs-keyword">return</span> head;
 }

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SearchBook</span><span class="hljs-params">(pBookNode head, <span class="hljs-keyword">char</span> *szBookName)</span> </span>{
     pBookNode pHeadBookNode= head;
     <span class="hljs-keyword">int</span> nFlag = <span class="hljs-number">0</span>;
     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pHeadBookNode) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书库为空，请添加书籍后查询~\r\n&quot;</span>);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }

     <span class="hljs-keyword">while</span> (pHeadBookNode != <span class="hljs-literal">NULL</span>) {
         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(pHeadBookNode-&gt;szBookName, szBookName) == <span class="hljs-number">0</span>) {
             nFlag = <span class="hljs-number">1</span>;
             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书名：%s\r\n书号：%d\r\n价格：%lf\r\n&quot;</span>, pHeadBookNode-&gt;szBookName, pHeadBookNode-&gt;nBookNumber, pHeadBookNode-&gt;dPrice);
         }
         pHeadBookNode = pHeadBookNode-&gt;next;
     }
     <span class="hljs-keyword">if</span> (nFlag == <span class="hljs-number">0</span>) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书库中不存在名为《%s》的书籍~\r\n&quot;</span>, szBookName);
     }

     <span class="hljs-built_in">free</span>(pHeadBookNode);

     <span class="hljs-keyword">return</span> ;
 }

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayAllBook</span><span class="hljs-params">(pBookNode head)</span> </span>{
     pBookNode tmpBookInfoNode = head;
     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == tmpBookInfoNode) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书库为空，请添加书籍后查看~\r\n&quot;</span>);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }

     <span class="hljs-keyword">while</span> (tmpBookInfoNode != <span class="hljs-literal">NULL</span>) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=============================\r\n&quot;</span>);
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书名：%s\r\n书号：%d\r\n价格：%lf\r\n&quot;</span>, tmpBookInfoNode-&gt;szBookName, tmpBookInfoNode-&gt;nBookNumber, tmpBookInfoNode-&gt;dPrice);
         tmpBookInfoNode = tmpBookInfoNode-&gt;next;
     }
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=============================\r\n&quot;</span>);

     <span class="hljs-built_in">free</span>(tmpBookInfoNode);

     <span class="hljs-keyword">return</span> ;
 }

 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ModifyBookInfo</span><span class="hljs-params">(pBookNode head, <span class="hljs-keyword">char</span> *szBookName, <span class="hljs-keyword">double</span> dNewPrice)</span> </span>{
     pBookNode tmpBookInfoNode = head;
     <span class="hljs-keyword">double</span> dOldPrice = <span class="hljs-number">0</span>;
     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == tmpBookInfoNode) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书库为空，请添加书籍后修改~\r\n&quot;</span>);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }

     <span class="hljs-keyword">while</span> (tmpBookInfoNode != <span class="hljs-literal">NULL</span>) {
         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(tmpBookInfoNode-&gt;szBookName, szBookName) == <span class="hljs-number">0</span>) {
             dOldPrice = tmpBookInfoNode-&gt;dPrice;
             tmpBookInfoNode-&gt;dPrice = dNewPrice;
             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;《%s》价格由 %lf 更新为 %lf！\r\n&quot;</span>, szBookName, dOldPrice, dNewPrice);
             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;====================\r\n&quot;</span>);
             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;书名：%s\r\n书号：%d\r\n价格：%lf\r\n&quot;</span>, tmpBookInfoNode-&gt;szBookName, tmpBookInfoNode-&gt;nBookNumber, tmpBookInfoNode-&gt;dPrice);
             <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
         }
         tmpBookInfoNode = tmpBookInfoNode-&gt;next;
     }

     <span class="hljs-built_in">free</span>(tmpBookInfoNode);

     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }

 <span class="hljs-function">pBookNode <span class="hljs-title">DeleteBook</span><span class="hljs-params">(pBookNode head, <span class="hljs-keyword">char</span> *szBookName)</span> </span>{
     pBookNode tmpBookInfoNode = head;
     pBookNode tmp = <span class="hljs-literal">NULL</span>;
     pBookNode pre = <span class="hljs-literal">NULL</span>;

     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == tmpBookInfoNode) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;操作失败，书库为空~\r\n&quot;</span>);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }

     <span class="hljs-keyword">while</span> (tmpBookInfoNode!= <span class="hljs-literal">NULL</span>) {
         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(tmpBookInfoNode-&gt;szBookName, szBookName) == <span class="hljs-number">0</span>) {
             tmp = tmpBookInfoNode-&gt;next;
             pre-&gt;next = tmp;
             tmpBookInfoNode-&gt;next = <span class="hljs-literal">NULL</span>;

             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;《%s》已成功从书库中删除~\r\n&quot;</span>, szBookName);

             <span class="hljs-keyword">return</span> head;
         }
         pre = tmpBookInfoNode;
         tmpBookInfoNode = tmpBookInfoNode-&gt;next;
     }

     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除失败，《%s》不存在~\r\n&quot;</span>, szBookName);

     <span class="hljs-built_in">free</span>(tmpBookInfoNode);
     <span class="hljs-built_in">free</span>(pre);

     <span class="hljs-keyword">return</span> head;
 }
</code></pre>
</li>
<li>使用预处理指令判断当前处于什么操作系统环境下</li>
<li><p>编写一个文件加解密程序（Linux）（权限 w:sudo）【异或加密】</p>
<pre><code class="lang-c"> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

 <span class="hljs-comment">// 写文件</span>
 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">WriteFile</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * szFilePath, <span class="hljs-keyword">char</span> * szBuffer)</span> </span>{
     FILE * pFile = <span class="hljs-literal">NULL</span>;
     pFile = fopen(szFilePath, <span class="hljs-string">&quot;w&quot;</span>);

     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFile) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open file failed!\r\n&quot;</span>);
         fclose(pFile);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }

     <span class="hljs-keyword">int</span> nRet = fwrite(szBuffer, (<span class="hljs-built_in">strlen</span>(szBuffer + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)), <span class="hljs-number">1</span>, pFile);
     fclose(pFile);

     <span class="hljs-keyword">return</span> nRet;
 }

 <span class="hljs-comment">// 读文件</span>
 <span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">ReadFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * szFilePath)</span> </span>{
     FILE *pFile = <span class="hljs-literal">NULL</span>;
     <span class="hljs-keyword">char</span> * szReadBuffer = <span class="hljs-literal">NULL</span>;
     <span class="hljs-keyword">int</span> nReadFileSize = <span class="hljs-number">0</span>;

     <span class="hljs-comment">// 打开文件，需要传入绝对路径</span>
     pFile = fopen(szFilePath, <span class="hljs-string">&quot;rb&quot;</span>);
     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFile) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Open file failed!\r\n&quot;</span>);
         fclose(pFile);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }

     <span class="hljs-comment">// 计算文件长度</span>
     fseek(pFile, <span class="hljs-number">0</span>, SEEK_END);
     nReadFileSize = ftell(pFile);
     rewind(pFile);
     <span class="hljs-comment">//fseek(pFile, 0, SEEK_SET);</span>

     <span class="hljs-comment">// 分配读取缓存大小</span>
     szReadBuffer = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>((<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * nReadFileSize) + <span class="hljs-number">1</span>);
     <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == szReadBuffer) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc memory failed!\r\n&quot;</span>);
         fclose(pFile);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;分配了 %d 字节\r\n&quot;</span>, (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * (nReadFileSize)) + <span class="hljs-number">1</span>);
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件一共 %d 字节\r\n&quot;</span>, nReadFileSize);

     <span class="hljs-comment">// 初始化内存</span>
     <span class="hljs-built_in">memset</span>(szReadBuffer, <span class="hljs-number">0</span>, nReadFileSize + <span class="hljs-number">1</span>);
     <span class="hljs-keyword">int</span> nResLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录实际读到的长度</span>
     nResLength = fread(szReadBuffer,  <span class="hljs-number">1</span>, nReadFileSize,pFile); <span class="hljs-comment">// 按 1 字节读取</span>
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;读取了 %d 字节\r\n&quot;</span>, <span class="hljs-built_in">strlen</span>(szReadBuffer));
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ftell : %d 字节\r\n&quot;</span>, nReadFileSize);
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fread : %d 字节\r\n&quot;</span>, nResLength);

     <span class="hljs-keyword">if</span> (nResLength != nReadFileSize) {
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read file failed !\r\n&quot;</span>);
         fclose(pFile);
         <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
     }
     fclose(pFile);

     <span class="hljs-keyword">return</span> szReadBuffer;
 }

 <span class="hljs-comment">// 异或加密</span>
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">XorCode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buffer, <span class="hljs-keyword">int</span> nSize, <span class="hljs-keyword">char</span> key)</span> </span>{
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i&lt;nSize; i++) {
         buffer[i] ^= key;
     }
 }

 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">char</span> * szSrcBuffer = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * <span class="hljs-number">20</span>);
     <span class="hljs-built_in">memset</span>(szSrcBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);

     <span class="hljs-built_in">memcpy</span>(szSrcBuffer, <span class="hljs-string">&quot;zhaocai mao ~~&quot;</span>, <span class="hljs-number">15</span>);
     XorCode(szSrcBuffer, <span class="hljs-number">15</span>, <span class="hljs-number">0x56</span>);
     <span class="hljs-comment">// &quot;D:\CPP_Project\Test1\cmake-build-debug\text.txt&quot;</span>
     WriteFile(<span class="hljs-string">&quot;D:\\tmp\\text.txt&quot;</span>, szSrcBuffer);

     <span class="hljs-keyword">char</span> * szBuffer = <span class="hljs-literal">NULL</span>;
     szBuffer = ReadFile(<span class="hljs-string">&quot;D:\\tmp\\text.txt&quot;</span>);
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;异或加密后的字符串：%s\r\n&quot;</span>, szBuffer);
     XorCode(szBuffer, <span class="hljs-built_in">strlen</span>(szBuffer), <span class="hljs-number">0x56</span>);
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;异或解密后的字符串：%s\r\n&quot;</span>, szBuffer);

     <span class="hljs-built_in">free</span>(szSrcBuffer);
     <span class="hljs-built_in">free</span>(szBuffer);

     system(<span class="hljs-string">&quot;pause&quot;</span>);
     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }

 ----------
 D:\CPP_Project\Test1\cmake-build-debug\Test1.exe
 分配了 <span class="hljs-number">15</span> 字节
 文件一共 <span class="hljs-number">14</span> 字节
 读取了 <span class="hljs-number">14</span> 字节
 ftell : <span class="hljs-number">14</span> 字节
 fread : <span class="hljs-number">14</span> 字节
 异或加密后的字符串：,&gt;<span class="hljs-number">7957</span>?v;<span class="hljs-number">79</span>v((
 异或解密后的字符串：zhaocai mao ~~
</code></pre>
</li>
</ol>
<h2 id="练习-2"><a name="练习-2" class="anchor-navigation-ex-anchor" href="#练习-2"><i class="fa fa-link" aria-hidden="true"></i></a>练习 2</h2>
<ol>
<li>初步完成贪吃蛇游戏的代码</li>
</ol>
<h1 id="前人栽树"><a name="前人栽树" class="anchor-navigation-ex-anchor" href="#前人栽树"><i class="fa fa-link" aria-hidden="true"></i></a>前人栽树</h1>
<ul>
<li><a href="https://www.runoob.com/cprogramming/c-file-io.html" target="_blank">C 文件读写 | 菜鸟教程 (runoob.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_48991062/article/details/123655965" target="_blank">C 语言实现对文件流的读写工作_W\Y.的博客-CSDN 博客_c 语言文件流读写</a></li>
<li><a href="https://blog.csdn.net/Jiajikang_jjk/article/details/86681145" target="_blank">【C 语言】C 语言读取文本文件_贾继康的博客-CSDN 博客_c 读取文本</a></li>
</ul>
<p>‍</p>
<footer class="page-footer"><span class="copyright">Copyright &amp; Copy zha0cai all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2022-11-08 04:59:08
</span></footer></body></html>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="05 - 函数、数组与指针.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: 05 函数、数组与指针">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"06 复杂数据类型与文件操作","level":"2.1.6","depth":2,"next":{"title":"C ++ 基础","level":"2.2","depth":1,"ref":"","articles":[{"title":"CPP - 01 面向对象基础","level":"2.2.1","depth":2,"path":"C++ 基础/CPP - 01 面向对象基础.md","ref":"C++ 基础/CPP - 01 面向对象基础.md","articles":[]},{"title":"CPP - 02 重载","level":"2.2.2","depth":2,"path":"C++ 基础/CPP - 02 重载.md","ref":"C++ 基础/CPP - 02 重载.md","articles":[]},{"title":"CPP - 03 继承","level":"2.2.3","depth":2,"path":"C++ 基础/CPP - 03 继承.md","ref":"C++ 基础/CPP - 03 继承.md","articles":[]},{"title":"CPP - 04 多态","level":"2.2.4","depth":2,"path":"C++ 基础/CPP - 04 多态.md","ref":"C++ 基础/CPP - 04 多态.md","articles":[]},{"title":"CPP - 05 探索类对象模型（一）","level":"2.2.5","depth":2,"path":"C++ 基础/CPP - 05 探索类对象模型（一）.md","ref":"C++ 基础/CPP - 05 探索类对象模型（一）.md","articles":[]},{"title":"CPP - 06 探索类对象模型（二）","level":"2.2.6","depth":2,"path":"C++ 基础/CPP - 06 探索类对象模型（二）.md","ref":"C++ 基础/CPP - 06 探索类对象模型（二）.md","articles":[]},{"title":"CPP - 07 探索类对象模型（三）","level":"2.2.7","depth":2,"path":"C++ 基础/CPP - 07 探索类对象模型（三）.md","ref":"C++ 基础/CPP - 07 探索类对象模型（三）.md","articles":[]},{"title":"CPP - 08 寄存器基础与函数调用约定","level":"2.2.8","depth":2,"path":"C++ 基础/CPP - 08 寄存器基础与函数调用约定.md","ref":"C++ 基础/CPP - 08 寄存器基础与函数调用约定.md","articles":[]},{"title":"CPP - 09 探索对象模型（四）","level":"2.2.9","depth":2,"path":"C++ 基础/CPP - 09 探索对象模型（四）.md","ref":"C++ 基础/CPP - 09 探索对象模型（四）.md","articles":[]},{"title":"CPP - 10 探索对象模型（五）","level":"2.2.10","depth":2,"path":"C++ 基础/CPP - 10 探索对象模型（五）.md","ref":"C++ 基础/CPP - 10 探索对象模型（五）.md","articles":[]},{"title":"CPP - 11 函数模板和类模板","level":"2.2.11","depth":2,"path":"C++ 基础/CPP - 11 函数模板和类模板.md","ref":"C++ 基础/CPP - 11 函数模板和类模板.md","articles":[]},{"title":"CPP - 12 函数模板和类模板（总结）","level":"2.2.12","depth":2,"path":"C++ 基础/CPP - 12 函数模板和类模板（总结）.md","ref":"C++ 基础/CPP - 12 函数模板和类模板（总结）.md","articles":[]},{"title":"CPP - 现代 C++ 基础（一）","level":"2.2.13","depth":2,"path":"C++ 基础/CPP - 现代 C++ 基础（一）.md","ref":"C++ 基础/CPP - 现代 C++ 基础（一）.md","articles":[]},{"title":"CPP - 现代 C++ 基础（二）","level":"2.2.14","depth":2,"path":"C++ 基础/CPP - 现代 C++ 基础（二）.md","ref":"C++ 基础/CPP - 现代 C++ 基础（二）.md","articles":[]},{"title":"CPP - 现代 C++ 基础（三）","level":"2.2.15","depth":2,"path":"C++ 基础/CPP - 现代 C++ 基础（三）.md","ref":"C++ 基础/CPP - 现代 C++ 基础（三）.md","articles":[]}]},"previous":{"title":"05 函数、数组与指针","level":"2.1.5","depth":2,"path":"C 语言程序设计基础/05 - 函数、数组与指针.md","ref":"C 语言程序设计基础/05 - 函数、数组与指针.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","search-pro","highlight","code","theme-comscore","-splitter","-summary","anchor-navigation-ex","expandable-chapters","versions-select","tbfed-pagefooter","flexible-alerts","advanced-emoji"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright & Copy zha0cai","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"search-pro":{},"code":{"copyButtons":true},"versions-select":{"type":"branches"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"anchor-navigation-ex":{"showLevel":false,"associatedWithSummary":true,"mode":"float","showGoTop":true,"printLog":false,"multipleH1":true,"float":{"floatIcon":"fa fa-navicon","showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"theme-comscore":{},"flexible-alerts":{"style":"callout","note":{"label":"Hinweis","icon":"fa fa-info-circle","className":"info"},"tip":{"label":"Tipp","icon":"fa fa-lightbulb-o","className":"tip"},"warning":{"label":"Warnung","icon":"fa fa-exclamation-triangle","className":"warning"},"danger":{"label":"Achtung","icon":"fa fa-ban","className":"danger"}},"versions":{"gitbookConfigURL":"book.json","options":[{"value":"https://zha0cai.github.io/gitbookPublic/gitbook-Windows 高级攻防/","text":"Windows 高级攻防","selected":true},{"value":"https://zha0cai.github.io/gitbookPublic/home/","text":"Home Page","selected":true}]},"advanced-emoji":{"embedEmojis":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"chart":{"type":"c3"},"expandable-chapters":{}},"theme":"default","author":"zha0cai","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Windows 高级攻防","language":"zh-hans","links":{"sidebar":{"My github":"https://github.com/zha0cai"}},"gitbook":"*"},"file":{"path":"C 语言程序设计基础/06 - 复杂数据类型与文件操作.md","mtime":"2022-11-07T20:59:08.000Z","type":"markdown"},"gitbook":{"version":"4.0.0","time":"2022-11-08T06:00:50.224Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-versions-select/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-flexible-alerts/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    </body>
</html>

