{"./":{"url":"./","title":"Windows 高级攻防","keywords":"","body":"前言 这个 readme 我还没想好怎么写。。。 ​基础阶段 C/C++ 程序设计 数据结构与算法基础 MASM 汇编语言 WIN32 SDK MFC 系统编程 网络编程 Python 高级安全 PE 结构 软件逆向 调试原理 对抗技术 恶意代码 漏洞分析 内网攻防 Windows Server PowerShell Active Directory 常规手段 域安全 CTF Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 13:07:32 "},"C 语言程序设计基础/01 - 环境和编译.html":{"url":"C 语言程序设计基础/01 - 环境和编译.html","title":"01 环境和编译","keywords":"","body":"环境 Win 10 专业版虚拟机 激活地址：https://www.bbsmax.com/A/QW5Y0pneJm/ 系统安装完毕后，首先以管理员身份打开 CMD 命令行窗口，按下 Win +X，选择命令提示符(管理员)。 说明：kms.xspace.in 是 kms 服务器地址，可能会失效，如果激活失败，可以自行搜索 kms 服务器地址，将 kms.xspace.in 替换成新的地址即可，比如换 kms.03k.org，参考可用的 kms 激活服务器有哪些。 # 公开地址有： kms.loli.best kms.cangshui.net kms.iaini.net kms.huengyamm.xyz kms.kuretru.com kms.03k.org 还有其他服务器，可以自行查找。 Win10 专业版用户请依次输入： slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato 觉得不安全激活后可以随便修改 kms 激活服务器地址：如 slmgr /skms zhaocai 按 Win + R 键，输入框输入 slmgr.vbs -xpr 打开，查看激活到期时间的相关信息 slmgr /upk，是卸载keyslmgr /ckms，是密钥管理服务计算机名称清除slmgr /rearm，是重置计算机的授权状态 https://baike.baidu.com/item/KMS/66195 https://zhuanlan.zhihu.com/p/152269085 7zip\\010Editor\\OllyICE\\x96dbg 7zip 直接解压安装 010Editor 直接运行 OllyICE 直接解压运行 ‪C:\\Tools\\OllyICE\\OllyDBG.EXE x96dbg 直接解压运行 ‪C:\\Tools\\x96dbg\\release\\x32\\x32dbg.exe C:\\Tools\\x96dbg\\release\\x64\\x64dbg.exe IDA 解压 -- 安装 -- 输入 SN 一直下一步就 ok。 SN：qY2jts9hEJGy ​ ​ Visual Studio 2017 Enterprise: NJVYC-BMHX2-G77MM-4XJMR-6Q8QF Professional: KBJFW-NXHK6-W4WJM-CRMQB-G3CDH 工作负荷 ​ 选择安装 使用 C++ 的桌面开发 √ ​ 通用 Windows 平台开发 （后期再使用） Visual Studio 扩展开发 √ 默认勾选即可 单个组件（默认即可） ​ ​ 等待安装完成，输入帮助 -- 注册产品。 MFC 应用创建 基于对话框 - 静态库中使用 MFC ​ 运行库安装 解压安装，默认推荐即可。 汇编金手指 直接使用 Kali 安装 略 前言 使用 C 语言的理由和应用领域 一些 C 的历史、标准、特性介绍。 可移植、更强的操作性、广泛 操作系统、编译器、游戏、嵌入式、桌面程序 C 语言的标准 K&RC 标准 C89/C90 C99 C11 编译过程 C 语言编译 源码（.c/.cpp）：编写 c or cpp 源码 编译（.obj/.o）源程序通过翻译程序加工以后生成的机器语言程序。【编译器（Compiler）】 连接（.exe）：其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件【系统提供的组件（比如标准库）结合起来，这些组件都是程序运行所必须的。】。完成链接的过程也需要一个特殊的软件，叫做 链接器（Linker） 。例如我们要在屏幕中输出字符，这必须调用系统提供的库才能够实现。可执行程序。 完整的编译步骤 ​ GCC 参数详解 | 菜鸟教程 (runoob.com) 预处理（预处理头文件、宏） sudo gcc -E hello.c -o hello.i 编译（c --> 汇编） sudo gcc -S hello.i -o hello.s 汇编（汇编语言 --> 二进制） sudo gcc -c hello.s -o hello.o 【注】-C 和 -c 的区别，前者会直接完成链接变成可执行文件。 链接（二进制文件 --> 可执行文件） sudo gcc hello.o -o hello 在 Linux 中是没有文件后缀这样的概念的（一切皆文件），只是起标识作用。 进制和位 进制 十六进制：0 ~ 9 A B C D E F 十进制：0~ 9 八进制：0 ~ 7 二进制：0 ~ 1 直接上计算器就完事了 ~ 位 操作系统位数：x86、x64 分别对应 32 位和 64 位。 QWORD 64 位 FWORD 48 位 DWORD 32 位 WORD 16 位 BYTE 8 位 BIT 1 位 Visual Studio & CLion 基本使用 四种运行库编译选项的区别 静态编译、动态编译（编译出来可能会缺少 xx 库） Visual Studio 中 MD 与 MT 的区别及运行库类型选择 - 知乎 (zhihu.com) MT 与 MD 的区别 /MT： 是 multithread-static version，是多线程静态版本的意思，项目会使用运行时库的多线程静态版本，编译器会将 LIBCMT.lib 放入 .obj 文件中，以便链接器使用 LIBCMT.lib 解析外部符号； /MTd： 是定义了 _DEBUG 和 /MT，是 /MT 类型的 debug 版本； /MD： 是 multithread-dll version，是多线程 dll 版本的意思，项目会使用运行时库的多线程动态 dll 版本，编译器会将 MSVCRT.lib 放入 .obj 文件中，在编译项目时，它会静态链接 MSVCRT.lib，但在实际运行过程中，它会链接使用 MSVCR90.dll； MDd： 是定义了 _DEBUG 和 /MD，是 /MD 类型的 debug 版本； 总起来说，/MD 类型表示运行时库不集成，生成的文件小，程序运行时动态加载对应的 dll；/MT 类型表示运行时库**集成**，生成的文件较大，在链接时将 C/C++ 运行时库集成到程序中。【写 那东西 的时候静态编译就好了】 ​ ​ 运行、Debug 就是常规调试了。就是可以看内存、变量值、运行步骤、调用关系之类的。 碎碎念 <> 在系统标准库里面寻找 \" \" 优先在本目录寻找，就比如自己写的宏 # pragma once 库预处理，多次包含也只会编译保留一份。 调试 F5 运行 F9 下断点 F10 单步执行 F11 单步步入 编译器 编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。一个现代编译器的主要工作流程：源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables) 连接器 在 C 语言中，一个重要的思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。但是连接器一般是与 C 编译器分离的，连接器如何做到把若干个 C 源程序合并成一个整体呢？链接过程就是空间分配过程。 连接器的输入是一组目标模块和库文件。连接器的输出是一个载入模块。连接器读入目标模块和库文件，同时生成载入模块。对每个目标模块中的每个外部对象，连接器都要检查载入模块，看是否已有同名的外部对象。如果没有，连接器就将该外部对象添加到载入模块中；如果有，连接器就要开始处理命名冲突。除了外部对象之外，目标模块还可能包括了对其他模块中的外部对象的引用。 CLion 参考 IDEA 使用。 前人栽树 编译链接过程YancyKahn 的博客-CSDN 博客编译链接过程 什么是编译、链接、编译程序 - 知乎 (zhihu.com) ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-07 18:32:28 "},"C 语言程序设计基础/02 - 基础数据类型与输入输出.html":{"url":"C 语言程序设计基础/02 - 基础数据类型与输入输出.html","title":"02 基础数据类型与输入输出","keywords":"","body":"数据类型 序号 类型与描述 1 基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。 2 枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 3 void 类型：类型说明符 void 表明没有可用的值。 4 派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。数组类型和结构类型统称为聚合类型。 整数 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小： #include #include int main() { printf(\"int 存储大小 : %lu \\n\", sizeof(int)); return 0; } %lu 为 32 位无符号整数，详细说明查看 C 库函数 - printf()。 当您在 Linux 上编译并执行上面的程序时，它会产生下列结果： int 存储大小 : 4 浮点类型 下表列出了关于标准浮点类型的存储大小、值范围和精度的细节： 类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位有效位 double 8 字节 2.3E-308 到 1.7E+308 15 位有效位 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位有效位 头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值： #include #include int main() { printf(\"float 存储最大字节数 : %lu \\n\", sizeof(float)); printf(\"float 最小值: %E\\n\", FLT_MIN ); printf(\"float 最大值: %E\\n\", FLT_MAX ); printf(\"精度值: %d\\n\", FLT_DIG ); return 0; } %E 为以指数形式输出单、双精度实数，详细说明查看 C 库函数 - printf()。 void 类型 void 类型指定没有可用的值。它通常用于以下三种情况下： 序号 类型与描述 1 函数返回为空C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void类型为 void 的指针代表对象的地址，而不是类型。**例如，内存分配函数 void malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。** 字符串 字符串是使用空字符 \\0 结尾的一维字符数组。因此，\\0 是用于标记字符串的结束。空字符（Null character ）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。 char szString[8] = \"zhaocai\"; // 内存 7a 68 61 6f 63 61 69 00 （对应的是字母的 ascii 码） // 可以对比一下 szBuffer[7] 和 szBuffer[8] 输出的区别。 char szBuffer[7] = \"zhaocai\"; // 会显示乱码 char *szBuffer = \"zhaocai\"; char site[8] = {'z', 'h', 'a', 'o', 'c', 'a', 'i', '\\0'}; wchar_t szWbuffer[] = L\"zhaocai\"; C 编译器会在初始化数组时，自动把 \\0 放在字符串的末尾。 字符串需要有结束符标识，数组需要自行添加结束符 \\00。 调试 -- 窗口 -- 内存 -- 内存，就可以查看内存。 ​ char 1 字节 wchar_t 2 字节 #include #include int main() { // char 1 字节，wchar_t 2 字节 char szBuffer[] = \"zhaocai\"; // 7a 68 61 6f 63 61 69 00 wchar_t szWbuffer[] = L\"zhaocai\"; // 7a 00 68 00 61 00 6f 00 63 00 61 00 69 00 00 00 // 可以看大 wchar_t 每一个字符都是占两个字节的。7a 00 ... system(\"pause\"); return 0; } ​ 数组的名字就是首地址 == 指针 strlen 计算字符串实际长度（没算结束符） 序号 函数 & 目的 1 strcpy(s1, s2);复制字符串 s2 到字符串 s1。 2 strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1);返回字符串 s1 的长度。 4 strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回大于 0。 5 strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 auto 类型（自动类型） http://c.biancheng.net/view/6984.html 定义变量 变量类型 变量名 = 值; 变量类型 变量名 = 表达式; 命名规则 英文字符或下划线开始 不能包含空格、标点符号、类型说明符和运算符 不能是关键字、大小写区分 推荐驼峰命名法 匈牙利命名法 关键字 auto ：声明自动变量 break：跳出当前循环 case：开关语句分支 char ：声明字符型变量或函数返回值类型 const ：声明只读变量 continue：结束当前循环，开始下一轮循环 default：开关语句中的“默认”分支 do ：循环语句的循环体 double ：声明双精度浮点型变量或函数返回值类型 else ：条件语句否定分支（与 if 连用） enum ：声明枚举类型 extern：声明变量或函数是在其它文件或本文件的其他位置定义 float：声明浮点型变量或函数返回值类型 for：一种循环语句 goto：无条件跳转语句 if:条件语句 int： 声明整型变量或函数 long ：声明长整型变量或函数返回值类型 register：声明寄存器变量 return ：子程序返回语句（可以带参数，也可不带参数） short ：声明短整型变量或函数 signed：声明有符号类型变量或函数 sizeof：计算数据类型或变量长度（即所占字节数） static ：声明静态变量 struct：声明结构体类型 switch :用于开关语句 typedef：用以给数据类型取别名 unsigned：声明无符号类型变量或函数 union：声明共用体类型 void ：声明函数无返回值或无参数，声明无类型指针 volatile：说明变量在程序执行中可被隐含地改变 while ：循环语句的循环条件 bool _Bool & 取地址符 全局变量 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。 保存在内存的全局存储区中，占用静态的存储单元。因为全局变量存储在静态数据区。 在静态数据区，内存中所有的字节默认值都是 0x00 局部变量 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。 形参也是局部变量。 保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。 静态变量（static） 只初始化一次：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。 共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。 常量变量（const） const 是 constant 的简写，用来定义常量，它限定一个变量不允许被改变，产生静态作用。const 最开始推出的目的是为了取代预编译指令，取长补短。是 只读变量，且是在编译运行阶段使用的。 const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。 修饰普通类型变量 如果不想让编译器察觉到上面到对 const 的操作，我们可以在 const 前面加上 volatile 关键字。 volatile 关键字跟 const 对应相反，是易变的，容易改变的意思。所以不会被编译器优化，编译器也就不会改变对 a 变量的操作。那么就可以通过取地址来改变变量的值。 const int a = 7; int *p = (int*)&a; *p = 8; 修饰指针变量 const 修饰指针变量有以下三种情况。【就近原则】 如果 const 后面是一个类型，则跳过最近的原子类型，修饰后面的数据**。**（原子类型是不可再分割的类型，如 int, short , char，以及 typedef 包装后的类型） A: const 修饰指针指向的内容，则内容为不可变量。【值不可变】 const int *p = 8; B: const 修饰指针，则指针为不可变量。【指向的地址不可变】 int a = 8; int* const p = &a; *p = 9; // 正确 int b = 7; p = &b; // 错误 C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。【值和指向的地址都不可变】 int a = 8; const int * const p = &a; 参数传递和函数返回值 普通变量做为形参可以不用 const 修饰，毕竟传过来的只是值而不是内存地址。 参数为指针时，const 可以防止指针被意外篡改 。 对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。 void Cmf(const Test& _tt) const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。 const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。 const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。 修饰类成员函数 const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。 const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。 https://www.runoob.com/w3cnote/cpp-const-keyword.html 初始化局部变量和全局变量 局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。 定义全局变量时，系统会自动对其初始化，如下所示： 数据类型 初始化默认值 int 0 char '\\0' float 0 double 0 pointer NULL 输入输出 格式化输入\\输出 ‍ %c 字符 %s 字符串 %d int %f double %e double %lld long long %x 十六进制 %X 大写的十六进制整数 %p 指针 \\ 转义字符 转义序列 含义 \\\\ \\ 字符 \\' ' 字符 \\\" \" 字符 \\? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 scanf 只能接收 4 字节，double 需要 8 字节，需要 %lf 接收。 scanf 错误：项目 - 属性 - C/C++ - 预处理器 - 预处理器定义 - 编辑。在最后一行加上 _CRT_SECURE_NO_WARNINGS 4996 错误主要是使用了不安全函数造成的(高版本的 vs 会报错) 可以在预处理添加 1. _CRT_SECURE_NO_WARNINGS 也可以可以通过 在文件最开始位置添加，消除错误 #pragma warning(disable:4996) 或者在项目创建的时候取消掉“安全开发生命周期检查”的选项 ​ 练习 前人栽树 菜鸟教程 - C 数据类型 菜鸟教程 - static 关键字 _CRT_SECURE_NO_WARNINGS ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-07 18:32:28 "},"C 语言程序设计基础/03 - 运算符.html":{"url":"C 语言程序设计基础/03 - 运算符.html","title":"03 运算符","keywords":"","body":"算术运算符 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A-- 将得到 9 ++a：先加后用 a++：先用后加 --b：先用后减 b--：先用后减 逻辑运算符 运算符 描述 实例 && 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A && B) 为假。 | | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 （A | | B）为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A && B) 为真。 关系运算符 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 为假。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 > 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A > B) 为假。 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A >= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A >= B) 为假。 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A 位运算符 运算符 描述 实例 & 按位与操作，按二进制位进行\"与\"运算。 | 按位或运算符，按二进制位进行\"或\"运算。 ^ 异或运算符，按二进制位进行\"异或\"运算。0\\^0\\=0;0\\^1\\=1;1\\^0\\=1;1\\^1\\=0;相同取 0，相异与 1。 两个数异或出来的第三个数，这三个数两两异或可以得到另一个数。 ~ 取反运算符，按二进制位进行\"取反\"运算。 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。 >> 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。 高位是 1 就左边补 1，高位是 0 就左边补 0。假设 A = 60，即 A = 0011 1100。A >> 2 ，右移两位 0000 1111 。 与 或 异或：相同取 0，相异与 1。 p q p & q p | q p ^ q 0 0 0 0 0 1 1 1 1 0 0 1 0 1 1 1 0 0 1 1 ‍ 左移：右边补 0 ，如 101011 左移 3 位：011000。 右移：高位是 1 就左边补 1，高位是 0 就左边补 0。 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C = A 相当于 C = C A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A 左移且赋值运算符 C >>= 右移且赋值运算符 C >>= 2 等同于 C = C >> 2 &= 按位与且赋值运算符 C &= 2 等同于 C = C & 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 = 按位或且赋值运算符 三目运算符和 sizeof 运算符 描述 实例 sizeof() 返回变量的大小。 sizeof(a) 将返回 4 字节，其中 a 是整数 int。 & 返回变量的地址。 &a; 将给出变量的实际地址。 * 指向一个变量。 *a; 将指向一个变量。 ? : 条件表达式 如果条件为真 ? 则值为 X : 否则值为 Y C 中运算符的优先级 自己写代码，遇事不决加括号。看别人代码需要注意。 类别 运算符 结合性 后缀 () [] -> . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* & sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 > 从左到右 关系 >= 从左到右 相等 == != 从左到右 位与 AND & 从左到右 位异或 XOR ^ 从左到右 位或 OR 逻辑与 AND && 从左到右 逻辑或 OR 条件 ?: 从右到左 赋值 = += -= *= /= %=>>= = 逗号 , 从左到右 练习 异或加密基本逻辑 #include int main() { // 两两异或可以得到第三个数，那么就可以用其中一个做 key ，得到另一个实现简单异或加密 char a = 'a'; char flag = 'g'; char ret = a ^ flag; printf(\"进行异或出来的值：%X\\r\\n\" \"原来的值和加密值异或得到的加密 key：%c\\r\\n\" \"原来的第一个值：%c \\r\\n\", ret, a ^ ret, flag ^ ret); return 0; } #defind 和 const 的区别 #defind 是常量，是宏在预处理阶段就会被简单的直接替换成对应的值。【若是表达式不会考虑优先级，所以记得加括号】。宏是直接替换，宏定义不会进行类型检查，不额外分配内存。 #include // 宏是直接替换，宏定义不会进行类型检查，不额外分配内存 #define Max(a, b) a > b ? a : b #define Num 2+3 int main() { char arrStr1[10] = { 'm', 'o', 'b', '\\0' }; char arrStr2[10] = \"mob\"; int ret1 = Max(1, 2); // 直接替换，所以等价于 2+3/2.0，并不是预期的 5 / 2.0 float ret2 = Num / 2.0; int const ret3 = 15; // ret3 = 17; const 只读常量不允许修改，修改则会报错 int len1 = strlen(arrStr1); int len2 = strlen(arrStr2); int len3 = sizeof(arrStr1); int len4 = sizeof(arrStr2); printf(\"%d \\n\", len1); printf(\"%d \\n\", len2); printf(\"%d \\n\", len3); printf(\"%d \\n\", len4); printf(\"%s \\n\", arrStr1); printf(\"%s \\n\", arrStr2); printf(\"%d \\n\", ret1); // 输出为 3.500000 printf(\"%f \\n\", ret2); return 0; } // 输出结果如下 3 3 10 10 mob mob 2 3.500000 const 也是常量，是变量的修饰符，是只读变量。 关键字 `const` 定义的是变量不是常量， 而是去改变一个变量的存储类，**把该变量所占的内存变为只读**。这就是变量的值不允许改变的常变量。该常量带有数据类型，编译运行的时候起作用存在**类型检查**。 一年大约有3.156*10^7秒。编写一个程序，提示用户输入年龄，然后显示该年龄对应的秒数。 #include #include #include // 没有考虑出生日期，平年闰年，统一按照 365 天算 int main() { float age = 0; printf(\"请输入您的年龄：\\n\"); scanf(\"%f\", &age); printf(\"您在地球上一共度过了 %f 秒。\\n\", (age * 3.156 * pow(10, 7))); system(\"pause\"); return 0; } 前人栽树 https://www.runoob.com/cprogramming/c-operators.html ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-07 18:32:28 "},"C 语言程序设计基础/04 - 选择结构与顺序结构.html":{"url":"C 语言程序设计基础/04 - 选择结构与顺序结构.html","title":"04 选择结构与顺序结构","keywords":"","body":"判断 ​ 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if...else 语句 一个 if 语句 后可跟一个可选的 else 语句 ，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 【注】上一节的三目运算符 ?: 其实也属于判断。 顺序结构 按照编码顺序执行。 选择结构 switch case 注意 break; switch(表达式) { case 常量表达式 1:语句 1; break; case 常量表达式 2:语句 2; ... default:语句 n + 1; } // 没有 break 的话就会顺序执行接下来的 case // case 的语句最好 {} 起来比较清晰，如下： switch(表达式) { case 常量表达式 1: { 语句 1; } break; case 常量表达式 2: { 语句 2; } ... default: { 语句 n + 1; } } default 默认执行。 循环 ​ ‍ 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。for(索引初始化; 判断条件; 改变条件) {} do...while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。【先执行一次再判断条件，即至少执行一次】 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 size_t for( ; ; ) {} 等价于 while (true) {} 控制语句 控制语句 描述 break 语句 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。 continue 语句 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。【结束本次，继续下次】 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 flag: goto flag; ------------------------------------ #include int main() { zhaocai1: printf(\"去找 zhaocai 1 号。\\r\\n\"); goto zhaocai1; // 向前跳转 // 向后跳转 goto zhaocai; printf(\"去找 zhaocai\\r\\n\"); printf(\"去找 zhaocai\\r\\n\"); printf(\"去找 zhaocai\\r\\n\"); zhaocai: printf(\"没有找到招财 zhaocai\\r\\n\"); return 0; } 练习 循环打印 0 - 100（分别使用 while/dowhile/for/goto 实现） #include #include int main() { for (int i = 0; i 输入三个数，打印最小的那个数 #include #include int main() { printf(\"请输入 3 个数，用空格间隔：\\r\\n\"); int ret = 0; int i, j, k; scanf(\"%d %d %d\", &i, &j, &k); if (i > j) { ret = i; }else { ret = j; } printf(\"最大的数是：%d \\r\\n\", ((ret > k) ? ret : k)); system(\"pause\"); return 0; } 输入小写字母，转换成大写字母输出 #include #include int main() { char a; printf(\"请输入一个小写字母：\"); scanf(\"%c\", &a); //a += 32; a -= 32; printf(\"对应的大写字母是：%c \\r\\n\",a); system(\"pause\"); return 0; } 输入一个字符，判断字符是大写还是小写 #include #include int main() { char a; printf(\"请输入一个字母：\"); scanf(\"%c\", &a); if (a >= 'a' && a = 'A' && a 输入一个数，判断这个数是否为偶数 #include #include int main() { int a; printf(\"请输入一个数字：\"); scanf(\"%d\", &a); if (a % 2 == 0) { printf(\"%d 是偶数。\\r\\n\", a); } else { printf(\"%d 是奇数。\\r\\n\", a); } system(\"pause\"); return 0; } 使用 if 语句与 switch 语句分别实现一个具有加减乘除功能的计算器（略） 计算 0 - 100 的加法(0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 ...) #include #include int main() { int ret = 0, i = 100; while (i > 0) { ret += i; i--; } printf(\"0 ~ 100 的和是：%d\\r\\n\", ret); system(\"pause\"); return 0; } 打印乘法口诀 例如： 1 * 1 = 1 2 * 1 = 2 2* 2 = 4 #include #include int main() { int i = 1; int j = 1; for (i = 1; i 上网查询如何生成随机数，实现一个生成 10 以内随机数，并且猜数字的游戏 打印一个菱形（略） * *** ***** ******* ***** *** * 使用*打印一个三角形（略） * *** ***** ******* ********* 前人栽树 https://www.runoob.com/cprogramming/c-loops.html Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-07 18:32:28 "},"C 语言程序设计基础/05 - 函数、数组与指针.html":{"url":"C 语言程序设计基础/05 - 函数、数组与指针.html","title":"05 函数、数组与指针","keywords":"","body":"函数 函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 return_type function_name( parameter list ); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的。 C 语言的函数需要声明在前，使用在后，一般是将声明写到头文件中。#inlcude “your.h” 函数定义 // 需要改变实参得值的时候形参就需要用指针 * 或者取地址 &。 return_type function_name( parameter list ) { body of the function } 返回类型： 一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void 。 函数名称： 这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数： 参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体： 函数主体包含一组定义函数执行任务的语句。 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 可变参数 #include #include #include // 第一个参数表示参数的个数 int Add(int a, ...) { va_list v1; va_start(v1, a); int tmp = 0; for (int i = 0; i 数组 数组的声明并不是声明一个个单独的变量，比如 zhaocai0、zhaocai1、...、zhaocai99，而是声明一个数组变量，比如 zhaocai，然后使用 zhaocai[0]、zhaocai[1]、...、zhaocai[99] 来代表一个个单独的变量。【当然你也可以声明一个数组，从下标 [1] 开始使用】 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 数组变量名就是首地址，例如 int a[] --> 默认情况下：a == a[0] == 首地址 不管是一维数组还是多维数组其存储结构都是顺序存储形式，即数组中的元素是按一定顺序依次存放在内存中的一块连续的内存空间中(地址连续）。 ​ 数组声明 // 一维数组，arraySize 必须是一个大于零的整数常量 type arrayName [ arraySize ]; // 二维数组，相当于一维数组得每一个元素也是一个一维数组 type arrayName [ arraySize1 ][ arraySize2 ]; // 多维数组 type arrayName [size1][size2]...[sizeN]; ​ int a[3][4] = { {0, 1, 2, 3} , /* 初始化索引号为 0 的行 */ {4, 5, 6, 7} , /* 初始化索引号为 1 的行 */ {8, 9, 10, 11} /* 初始化索引号为 2 的行 */ }; // 访问 int val = a[2][3]; #include #include int main() { // 初始化数组 char szBuffer[8] = {'a', [5] = 'h', 'b'}; char *p = szBuffer; printf(\"数组的首地址是：%p\\r\\n\", p); for (int i=0; i ​ 在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念： 概念 描述 多维数组 C 支持多维数组。多维数组最简单的形式是二维数组。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C 允许从函数返回数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。char *p;char szBuffer[] = {};p = szBuffer; 数组形式的形参声明 // 方式 1 指针形式 void myFunction(int *param) {} // 方式 2 指定大小 void myFunction(int param[size]) {} // 方式 3 不指定大小 void myFunction(int param[]) {} 返回值是数组 C 语言不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。 int * myFunction() {...} #include #include #include /* 要生成和返回随机数的函数 */ int * getRandom( ) { static int r[10]; int i; /* 设置种子 */ srand( (unsigned)time( NULL ) ); for ( i = 0; i 指针 每一个变量都有一个内存位置，每一个内存位置都定义了可使用 & 运算符访问的地址。而指针可以指向任意内存地址。指针也就是内存地址，指针变量是用来存放内存地址的变量。 就像其他变量或常量一样，在使用指针存储其他变量地址之前，必须对其进行声明。 指针声明：type *var_name; type 是指针的基类型，它必须是一个有效的 C 数据类型。 var_name 是指针变量的名称。 用来声明指针的星号 *。 ​ 指针使用：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。【* 是取值的，& 是取地址的】 #include int main () { int var = 20; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ char szBuffer[] = \"zhaocai\"; char *cp = szBuffer; ip = &var; /* 在指针变量中存储 var 的地址 */ printf(\"var 变量的地址：%p\\n\", &var ); /* 在指针变量中存储的地址 */ printf(\"ip 指针变量存储的地址：%p\\n\", ip ); /* 使用指针访问值 */ printf(\"*ip 变量的值：%d\\n\", *ip ); /* 数组的变量名就是首地址 */ printf(\"szBuffer 数组变量的地址: %p\\n\", &szBuffer); /* 在指针变量中存储的地址 */ printf(\"cp 指针变量存储的地址: %p\\n\", cp ); /* 使用指针访问值 */ printf(\"*cp 变量的值: %c\\n\", *cp ); return 0; } NULL 指针：在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯，不然的话会是随机值，很危险。赋为 NULL 值的指针被称为空指针。NULL 指针是一个定义在标准库中的值为零的常量。 概念 描述 指针的算术运算 可以对指针进行四种算术运算：++、--、+、- 指针数组 可以定义用来存储指针的数组。 指向指针的指针 C 允许指向指针的指针。 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 从函数返回指针 C 允许函数返回指针到局部变量、静态变量和动态内存分配。 指针的运算 指针指向（存放）的是一个地址，地址是用数来表示的，既然是数那肯定可以进行算数运算咯。 ++、--、+、-、+=、-=、==、>、 指针的每一次递增，它其实会指向下一个元素的存储单元。 指针的每一次递减，它都会指向前一个元素的存储单元。 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节 #include const int MAX = 3; int main () { int var[] = {10, 100, 200}; int i, *ptr; /* 指针中的数组地址 */ ptr = var; // 也可以这样循环遍历数组 //while (ptr 指针数组 用来存储指针的数组，理论上数组存什么取决于数组定义的类型。 // 指向字符串的指针数组 const char *names[] = {\"Zara Ali\", \"Hina Ali\", \"Nuha Ali\", \"Sara Ali\"} // 指向整型的指针数组 #include const int MAX = 3; int main () { int *var[] = {10, 100, 200}; for (int i = 0; i 指向指针的指针 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。【就是说指针指向的地址里面存的也是地址】 ​ 多级指针声明：type **var_name; #include const int MAX = 3; int main () { int var = 110; int *p1 = &var; int **p2 = &p1; printf(\"直接通过 var 获取变量 var 的值： %d\\r\\n\",var); printf(\"通过一级指针 *p1 获取变量 var 的值： %d\\r\\n\",*p1); printf(\"通过二级指针 **p2 获取变量 var 的值：%d\\r\\n\",**p2); printf(\"===================================\\r\\n\"); printf(\"* 是取值，& 是取地址\\r\\n\"); printf(\"一级指针 *p1 的地址是 p1： %p\\r\\n\",p1); printf(\"二级指针 **p2 的地址是 p2： %p\\r\\n\",p2); printf(\"二级指针 **p2 里面存的值是“一个地址”，该地址就是 p1 的地址： %p\\r\\n\",*p2); return 0; } 指针在函数中的使用 传递指针给函数：只需要简单地声明函数参数为指针类型即可。 从函数返回指针：int * myFunction(){} register 关键字（有机会能使变量使用到寄存器 register int a） --> 寄存器。暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在 CPU 的寄存器中，以加快其存储速度。 // 32 位寄存器 eax ebx ecx edx esi edi esp ebp eip eflags // 64 位寄存器 练习 计算一个一维数组的总和 int nArr[10] = {12,158,14,12,16,8,152,12,3,55}; 计算一个二位数组中每一个一位数组的平均值 int nArr2[4][3] = { {12,15,12}, {15,33,99}, {88,77,44}, {99, 55, 75} }; 找出一个一维数组中最大的值 int nArr[10] = {12,158,14,12,16,8,152,12,3,55}; 使用指针获取该数组中最大的数（int nArr[5] = {12,15,33,555,1};） 计算(char szStr[] = \"this is a c string\";)字符串的长度，并且输出 若封装函数用 sizeof 计算的话注意一个坑，形参和实参。 当将数组作为实参传递到另一个函数中时，另一个函数的形参相当于一个指针变量， 因为将数组的名作为实参时，就是将数字的首地址作为实参，所以在 test 函数中输出的 sizeof(arr) 其实得到的是一个整型数组的长度(所占的字节数)，所以结果是 8, 再用其除以 int 所占的字节数(4), 结果就是 2 。 (这样是得不到准确的数组的长度的，建议的操作是在定义数组的函数中计算数组的长度,，在以实参的形式传递出去，这样其他的函数变可以获得数组的长度) 将下列两个字符串进行拼接，并且输出 char szStrA[] = \"zhaocai\"; char szStrB[] = \"在学 C 语言\"; 输出提示并且接收两个字符串，对比是否一致，并且输出结果 输出提示并且接收用户名和密码，拼接成一个字符串输出 实现加减乘除函数 用递归实现（0 + 1 + 2 ... 100） 使用指针编写字符串处理库 字符串长度计算函数 strlen 字符串对比函数 strcmp 字符串拷贝函数 strcpy 字符串拼接函数 strcat 字符串切割函数 strslic 字符串子串搜索 strstr 字符串子串总数 StrSubCount #include #include const int MAX = 3; // 计算平均值的函数 double getAverage(int *nArr, int size) { int sum = 0; for (int i=0; i // 第五题的内存信息，可以看到数组最后会自动加上 \\00 结束符，也算数组长度。【这点和字符串不一样】 szStr = {char [19]} [0] = {char} 116 't' [1] = {char} 104 'h' [2] = {char} 105 'i' [3] = {char} 115 's' [4] = {char} 32 ' ' [5] = {char} 105 'i' [6] = {char} 115 's' [7] = {char} 32 ' ' [8] = {char} 97 'a' [9] = {char} 32 ' ' [10] = {char} 99 'c' [11] = {char} 32 ' ' [12] = {char} 115 's' [13] = {char} 116 't' [14] = {char} 114 'r' [15] = {char} 105 'i' [16] = {char} 110 'n' [17] = {char} 103 'g' [18] = {char} 0 '\\000' length = {int} 19 #include // 递归求和函数 int sum(int N) { // 结束条件 if (N == 0) { return 0; } else { return N + sum(N-1); } } int main () { // 题目 10 int n = 100; printf(\"0 ~ 100 的和：%d\\r\\n\", sum(n)); return 0; } D:\\Program Files (x86)\\JetBrains\\Toolbox\\apps\\CLion\\ch-0\\222.4167.35\\bin\\mingw\\x86_64-w64-mingw32\\include\\string.h #include // 计算字符串长度，不包括 '\\0' 结束符 size_t myStrlen(const char *szBuffer) { register char *tmp = szBuffer; int count = 0; if (NULL == szBuffer || '\\0' == *tmp) { return 0; } while (*tmp != '\\0') { tmp++; count++; } return count; /*register char *tmp = szBuffer; while (*tmp++); return (tmp - szBuffer -1);*/ } // 字符串比较，str1 > str2 返回正数，str1 0) { return 1; }else if (*str1 - *str2 0); if (n > 0) { if (*s1 == '\\0') return -1; if (*--s2 == '\\0') return 1; return (unsigned char) *s1 - (unsigned char) *s2; } } return 0; } // 字符串复制 char * myStrcpy(char * dest, const char *src) { /*register char * str1 = dest; while (*str1++ = *src++) { } return dest;*/ register char *str1 = dest; if (NULL == str1 || NULL == src) { return NULL; } while ('\\0' != *src) { *str1++ = *src++; } *str1 = '\\0'; return dest; } // 字符串拼接 strcat char *myStrcat(char *dest, const char *str) { /*register char *s1 = dest; while (*s1++ != '\\0') *//*EMPTY*//* ; s1--; while (*s1++ = *str++) *//*EMPTY*//* ; return dest;*/ register char * src = str; if (NULL == str || '\\0' == *str) { return dest; } while (*dest != '\\0') { dest++; } while (*src != '\\0') { *dest++ = *src++; } *dest = '\\0'; return dest; /*int nLength1 = myStrlen(dest); int nLength2 = myStrlen(str); for (size_t i=0; i nLength) { return NULL; } int size = end - start; for (size_t i=0; i nLength) return -1; for (size_t i=0; i D:\\CPP_Project\\Test1\\cmake-build-debug\\Test1.exe 通过 myStrcat 拼接的结果是：catcatcatcatdddddddddddd szBuffer9 的值是：dddddddddddd szBuffer6 的值是：dddddddddd szBuffer7 的值是：ddddddddddd Process finished with exit code 0 ----------------------- 在 Clion 下运行会发生内存覆盖 ------------------------- // 因为编译器分配内存可能是连续的，也可能是不连续的。 Clion 会将相邻的变量分配到连续的地址。由于 szBuffer6、szBuffer7、szBuffer8、szBuffer9 定义的时候都没有分配指定的内存，GCC 会分配覆盖。 - Clion --> GCC - Visual Studio --> MSVC ---------------------------------------------------------------------------- #include char *myStrcat(char *dest, const char *str) { int nLength1 = myStrlen(dest); int nLength2 = myStrlen(str); for (size_t i=0; i 前人栽树 C 指针 | 菜鸟教程 (runoob.com) C 数组 | 菜鸟教程 (runoob.com) C 函数 | 菜鸟教程 (runoob.com) C 语言如何计算数组的长度_i.czy 的博客-CSDN 博客_c 语言求数组长度 length How do I read the source code for a C library in CLion - Stack Overflow C 标准库 实现-阿里云开发者社区 (aliyun.com) C 标准库 实现 - wuyudong - 博客园 (cnblogs.com) 在调试器中查看变量的内存 - Visual Studio (Windows) | Microsoft Docs Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-07 18:32:28 "},"C 语言程序设计基础/06 - 复杂数据类型与文件操作.html":{"url":"C 语言程序设计基础/06 - 复杂数据类型与文件操作.html","title":"06 复杂数据类型与文件操作","keywords":"","body":"预处理 指令 描述 #define 定义宏，简单替换，不会考虑逻辑 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 C 预处理器 | 菜鸟教程 (runoob.com) 参数化的宏 CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方： int square(int x) { return x * x; } 我们可以使用宏重写上面的代码，如下： #define square(x) ((x) * (x)) 在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。 条件编译 条件编译（conditional compiling）命令指定预处理器依据特定的条件来判断保留或删除某段源代码。条件编译区域以 #if、#ifdef 或 #ifndef 等命令作为开头，以 #endif 命令结尾。条件编译区域可以有任意数量的 #elif 命令，但最多一个 #else 命令。 条件编译指令 说 明 #if 如果条件为真，则执行相应操作 #elif 如果前面条件为假，而该条件为真，则执行相应操作 #else 如果前面条件均为假，则执行相应操作 #endif 结束相应的条件编译指令 #ifdef 如果该宏已定义，则执行相应操作 #ifndef 如果该宏没有定义，则执行相应操作 作为 #if 或 #elif 命令条件的表达式，必须是整数常量预处理器表达式。 一元运算符 defined 可以出现在 #if 或 #elif 命令的条件中。 if、#elif、#else 和 #endif 指令 (C/C++) | Microsoft Learn #if defined 标识符 defined (标识符) !defined (标识符) #elif #else #endif #ifdef #ifndef --------- #include #include #if _WIN32 int g_OS = 0; #elif __LINUX__ int g_OS = 1; #endif int main () { printf(\"%d\\r\\n\", g_OS); system(\"pause\"); return 0; } 结构体 struct _Test { xxx }; // 起别名，相当于 // typedef struct _Test Test; // typedef struct _Test* pTest; typedef struct _Test { xxx; }Test, *pTest; // 使用 struct _Test test = {xxxx}; // 或者使用别名 Test test = {xxx}; // 使用typedef 起别名后以下是等价的 ==> struct _Test == Test ==> struct _Test * == pTest // C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE： typedef unsigned char BYTE; // 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写 对数组成员的赋值 ​ /** * 和以下错误一致，由于数组名是数组的首地址。 * 数组名表示常量，不允许对常量赋值，所以常量不允许出现在 “=” 的左边，作为左值出现，所以不能直接用字符串赋值给数组名。 * 可以在定义字符数组的同时用字符串给字符数组赋初值。 */ char szName[20] = \"zhaocai\"; szName = \"zhaocaimao\"; // error #include #include #include typedef struct _BOOK { char szBookName[100]; double dPrice; }Book, *pBook; int main () { Book book1 = {\"自我修养\", 999.99}; printf(\"书名: %s\\r\\n价格: %lf\\r\\n\", book1.szBookName, book1.dPrice); // 动态分配内存 pBook pBook1 = malloc(sizeof(Book)); // pBook1->szBookName = \"论优雅\"; // error strcpy(pBook1->szBookName,\"论优雅\"); // ok pBook1->dPrice = 888.88; printf(\"书名: %s\\r\\n价格: %lf\\r\\n\", pBook1->szBookName, pBook1->dPrice); system(\"pause\"); return 0; } 结构体分匹配的内存是连续的 分配内存 malloc(sizeof(struct xxx)) . 和 -> 的区别 一般指针用 -> 形式访问成员。 相同点：两个都是二元操作符，其右操作符是成员的名称。 不同点：点操作符左边的操作数是一个“结果为结构”的表达式； 箭头操作符左边的操作数是一个指向结构的指针。 内存对齐 指针加法，类型步进【即 +1 就是加一个类型宽度】 关于 struct 的字节数计算（对齐）___1478 的博客- CSDN 博客 _struct 字节数 类型 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） char 偏移量必须为 sizeof(char) 即 1 的倍数 int 偏移量必须为 sizeof(int) 即 4 的倍数 float 偏移量必须为 sizeof(float)即 4 的倍数 double 偏移量必须为 sizeof(double) 即 8 的倍数 short 偏移量必须为 sizeof(short) 即 2 的倍数 long 偏移量必须为 sizeof(long) 即 4 的倍数 long long 偏移量必须为 sizeof(long long) 即 8 的倍数 编译器为了提高 CPU 的存储速度， 会对变量的起始地址做了对齐处理 。 结构体成员对齐是可以进行设置的，比如 Visual Studio --> 属性 --> c/c++ --> 代码生成 --> 结构体成员对齐：注意此处修改的必须是 2^ 的整数倍，不然无法对齐。 1 字节（/Zp1） 2 字节（/Zp2） 4 字节（/Zp4） 8 字节（/Zp8） 16 字节（/Zp16） 还可以通过 #pragma pack(n) 来设定变量以 n 字节对齐方式。 n 字节对齐就是说变量存放的起始地址的偏移量有两种情况： 第一、如果 n 大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式， 第二、如果 n 小于该变量的类型所占用的字节数，那么偏移量为 n 的倍数，不用满足默认的对齐方式。 结构的总大小也有个约束条件，分下面两种情况：如果 n 大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为 n 的倍数。 #pragma pack(push) //保存对齐状态 #pragma pack(4)//设定为4字节对齐 struct test{ char m1; double m4; int m3; }; #pragma pack(pop)//恢复对齐状态 // 1 + 4 + 8 + 4 = 16 #include /** * sizeof(Info) = 40 * 变量总和 = 6 + 4 + 8 + 2 + 4 + 1 = 25 * 最大对齐 * 成员个数 = 48 * 为什么是 40 呢？ * MSVC 默认对齐是 8 字节（/Zp8） * 结构体成员对齐公式：（成员偏移，相对于结构体首地址的偏移） * member offset % min(ZpValue, sizeof(member type)) == 0 * 结构体对齐公式： * 对齐后的结构体大小 % max(member type) == 0 */ // 计算结构体的长度 typedef struct _Info { char szValue[6]; // +0 偏移 float fValue; // +8【理论上 float 偏移为 0+6 = +6 偏移，实际上根据结构体对齐 offset % min(8, 4) == 0，offset 为 6 不行，7 也不行，最小为 8，即 8 % 4 == 0】对齐了 2 字节 double dbValue; // +16【以此类推，理论上为 8 + 4（float 占 4 字节） = 12 偏移，实际上 offset % min(8, 8) == 0，offset 最小为 12，13，...，16，即 16 % 8 == 0】对齐了 4 字节 short sValue; // +24【16 + 8（double 占 2 字节） = 24，那么 offset % min(8, 2) == 0，即 24 % 2 == 0】 int nValue; // +28【24 + 2 = 26，那么 offset % min(8, 4) == 0，即 28 % 4 == 0】对齐了 2 字节 char cValue; // +32【28 + 4 = 32，那么 offset % min(8, 1) == 0，即 32 % 1 == 0】 }Info, *pInfo; // 那么就是成员之间的对齐就是 32 + 1（最后的 char 占 1 个字节） = 33，【一共对齐了 8 字节】最后整个结构体也需要对齐。 // 就是 33 % max(member type) == 0，这个结构体最大的是 double 8 字节，即 33 % 8 == 0。33,34,...,40 最小到 40 才能 40 % 8 == 0 int main() { Info info = {\"zhaoc\", 2.22f, 3.33, 222, 0xFFFFFFFF, 'c'}; Info info1; // char c = 'c'; // printf(\"%x\\r\\n\", c); printf(\"%d\\r\\n\", sizeof(info1)); // 40 printf(\"%d\\r\\n\", sizeof(info)); /** &info 【'c' 为 63】 * 7a 68 61 6f zhao == 7a 68 61 6f * 63 00 00 00 c\\0 == 63 00 cc cc * 7b 14 0e 40 float == 7b 14 0e 40 * f6 7f 00 00 对齐 == cc cc cc cc * a4 70 3d 0a double == a4 70 3d 0a * d7 a3 0a 40 double == d7 a3 0a 40 * de 00 00 00 short == de 00 cc cc * ff ff ff ff int == ff ff ff ff * 63 10 63 ed char == 63 cc cc cc * f6 7f 00 00 对齐 == cc cc cc cc * ------还是 visual Studio 的对齐方式更好看一些 * 那么按道理来说一共是 33 字节，为什么是 40 呢？ */ return 0; } 如果上面的 char 数组大小改为 9 呢？结果又是多少【还是 40 ，哈哈哈哈】，怎么对齐的？ 成员对齐了 5 字节，结构体也是对齐了 7 字节。结构体按类型对齐，非数组大小。 // 计算结构体的长度 typedef struct _Info { char szValue[9]; // +0 偏移，相对于结构体首地址的偏移 float fValue; // +12【理论上是 9，对齐了 3 字节】 double dbValue; // +16【理论上和实际上都是 16，不用对齐】 short sValue; // +24【理论上和实际上都是 24，不用对齐】 int nValue; // +28【理论上是 26，对齐了 2 字节】 char cValue; // +32【理论上和实际上都是 32，不用对齐】 }Info, *pInfo; // 那么就是成员之间的对齐就是 32 + 1（最后的 char 占 1 个字节） = 33，最后整个结构体也需要对齐。 // 就是 33 % max(member type) == 0，这个结构体最大的类型还是 double 8 字节，即 33 % 8 == 0。33,34,...,40 最小到 40 才能 40 % 8 == 0 如果 double 改成 long double 那么就是 33 % 16 == 0，需要再加 15 字节，即 48 % 16 == 0 char szValue[99] 呢？【128】 // 计算结构体的长度 typedef struct _Info { char szValue[99]; // +0 偏移 float fValue; // +100【理论上是 99，对齐了 1 字节】 double dbValue; // +104【理论上和实际上都是 104，不用对齐】 short sValue; // +112【理论上和实际上都是 112，不用对齐】 int nValue; // +114【理论上和实际上都是 114，不用对齐】 char cValue; // +120【理论上是 118，对齐了 2 字节】 }Info, *pInfo; // 那么就是成员之间的对齐就是 120 + 1（最后的 char 占 1 个字节） = 121，最后整个结构体也需要对齐。 // 就是 121 % max(member type) == 0，这个结构体最大的类型还是 double 8 字节，即 121 % 8 == 0。121,122,...,128 最小到 128 才能 128 % 8 == 0 补充：嵌套类型（含结构体成员） /** * 规则一：结构体中的第一个成员位置在偏移量 0，之后每个变量的偏移量必须是它本身字节数的整数倍。 * 规则二：如果结构体中嵌套结构体，那么嵌套的结构体的偏移量必须是它最大成员的字节数的整数倍。 * ★规则三：结构体的总偏移量必须是它最大成员字节数的整数倍（包括嵌套的结构体中的最大成员）。★ * 如果一个结构体 B 里嵌套另一个结构体 A，还是以最大成员类型的字节对齐，但是结构体 A 存储起点为 A 内部最大成员整数倍的地方。 * （struct B 里存有 struct A，A 里有 char，int，double 等成员，那 A 应该从 8 的整数倍开始存储。） * 结构体 A 中的成员的对齐规则仍满足自身的规则 * 注意： 1）结构体 A 整体所占的大小为该结构体成员内部最大元素的整数倍，不足补齐。 2）不是直接将结构体 A 的成员直接移动到结构体 B 中。 */ #include using namespace std; struct test1{ char m1; // +0 【偏移】 double m4; // +8 【补齐了 7 字节】 int m3; // +16 ==> 16 + 1 = 17 % 8 == 0 ==> 24 % 8 == 0 }; // 1 + 7 + 8 + 4 = 20 + 4 = 24 struct test2{ char m1; double m4; // 若改为 int 则为1 + 3 + 4 = 8 + 24 = 32 刚好是8 字节的倍数，因为 test1 的最大字节为8，故 sizeof(test2) 为 32 struct test1 test; }; // 1 + 7 + 8 = 16 + 24 = 40 为什么不是和 24 对齐？【就好像前面的数组大小一样】 // 对齐了因为结构体 test2 是以 double 字节对齐的（最大）与结构体成员 test1 的整体大小无关 40 刚好是8 的倍数 /* struct test2 { char m1; //1 + 1 + 1 + 1 + 1 + 3 + 4 = 12 + 24 = 36 + 4 == 40 恰好为 double 字节的倍数 char m2; char m3; char m4; char m5; int m6; struct test1 test; }; */ int main() { cout 指针访问结构体 /** * 比如访问 int nValue 这个成员变量 * 一般来说指针已经指向结构体的首地址，直接 pInfo1 + 28 就可以找到对应的成员变量。 * 实际上还得考虑指针的步进问题，指针定义成什么类型 + （步进）就是什么类型。 * 比如，int * p; p + 28，那么就是 +（步进了） 28 个 int 类型，即 p + 28 * 4 * pInfo1 + 28 那就是 + 了 28 个结构体类型。就超标了，所以要将指针转换为 char * 类型再步进。 * (char *)pInfo1 + 28 指向了 int nValue 成员变量，再将指针转换为 int * 指针，即 * (int *)((char *)pInfo1 + 28)，最后再通过 * 取出对应的值。 */ printf(\"0x%X\\r\\n\", *(int *)((char *)pInfo1 + 28)); 位域 可以定义变量的宽度来告诉编译器，只使用哪些字节。有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为\"位域\"或\"位段\"。所谓\"位域\"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。 // 位域在本质上就是一种结构类型，不过其成员是按二进位分配的。 struct 位域结构名 { 位域列表 }; //其中位域列表的形式为： type [member_name] : width ; ---------- struct bs { int a:8; int b:2; int c:6; }data; // data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。 // 使用 位域变量名.位域名 位域变量名->位域名 元素 描述 type 只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。 member_name 位域的名称。 width 位域中位的数量。宽度必须小于或等于指定类型的位宽度。 #include #include struct { unsigned int age : 3; // 三位二进制可以表示 8 种状态 2^3 次方 000, 001, 010,...,111 } Age; int main() { Age.age = 4; printf(\"Sizeof( Age ) : %d\\n\", sizeof(Age) ); printf(\"Age.age : %d\\n\", Age.age ); Age.age = 7; printf(\"Age.age : %d\\n\", Age.age ); Age.age = 8; // 二进制表示为 1000 有四位，超出 printf(\"Age.age : %d\\n\", Age.age ); return 0; } ---------- warning: unsigned conversion from 'int' to 'unsigned char:3' changes value from '8' to '0' [-Woverflow] ---------- D:\\CPP_Project\\Test1\\cmake-build-debug\\Test1.exe Sizeof( Age ) : 4 Age.age : 4 Age.age : 7 Age.age : 0 对于位域的定义尚有以下几点说明： 一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如： struct bs { unsigned a:4; unsigned :4; /* 空域，该 4 位不能使用*/ unsigned b:4; /* 从下一单元开始存放 */ unsigned c:4 } 在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。 位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，: 后面的数字不能超过这个长度。 位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。 联合体（共用体） 共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。union 共用体占用的内存应足够存储共用体中最大的成员。例如，在下面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。 #include #include union Data { int i; float f; char str[20]; }; int main() { union Data data; printf(\"Memory size occupied by data : %d\\n\", sizeof(data)); return 0; } 枚举 枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。 enum 枚举名 {枚举元素1,枚举元素2,……}; enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; 注意： 第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。 可以在定义枚举类型时改变枚举元素的值： enum season { spring, summer=3, autumn, winter }; // 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5 文件操作 打开文件 您可以使用 fopen() 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型： FILE *fopen( const char *filename, const char *mode ); 模式 描述 r 打开一个已有的文本文件，允许读取文件。read w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件，重新写入。write a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。append r+ 打开一个文本文件，允许读写文件。 w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式： \"rb\", \"wb\", \"ab\", \"rb+\", \"r+b\", \"wb+\", \"w+b\", \"ab+\", \"a+b\" // 读模式的方式打开第一个文件流，并且以二进制流的方式。由于二进制的方式，C 语言不进行任何转换，所以如果在 windows 下，该方式会看到行结尾符由一个 \\r\\n 两个字符组成；在 Linux 下则只有一个 \\n；在苹果机下面则是 \\r；如果以文本方式打开（不加 b 的模式），C 语言在调用 fread 的时候会将文本视图的行尾符统一转化成 \\n，然后在调用 fwrite 的时候再根据操作系统转化成相应的行尾符。 关闭文件 为了关闭文件，请使用 fclose( ) 函数。函数的原型如下： int fclose( FILE *fp ); 如果成功关闭文件，fclose() 函数返回零，如果关闭文件时发生错误，函数返回 EOF 。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。 写文件 下面是把字符写入到流中的最简单的函数： int fputc( int c, FILE *fp ); 函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF 。还可以使用下面的函数来把一个以 null 结尾的字符串写入到流中： int fputs( const char *s, FILE *fp ); 函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF 。您也可以使用 int fprintf(FILE *fp,const char *format, ...) 函数把一个字符串写入到文件中。尝试下面的实例： 注意： 请确保您有可用的 tmp 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。 /tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\\tmp、D:\\tmp 等。 #include #include #include // 写文件 int WriteFile(char * szFilePath, char * szBuffer) { FILE * pFile = NULL; pFile = fopen(szFilePath, \"w\"); if (NULL == pFile) { printf(\"open file failed!\\r\\n\"); fclose(pFile); exit(0); } int nRet = fwrite(szBuffer, (strlen(szBuffer + 1) * sizeof(char)), 1, pFile); fclose(pFile); return nRet; } int main() { // \"D:\\CPP_Project\\Test1\\cmake-build-debug\\text.txt\" WriteFile(\"text.txt\", \"zhaocai mao~\"); system(\"pause\"); return 0; } #include int main() { FILE *fp = NULL; // \"D:\\tmp\\fputsTest.txt\" fp = fopen(\"d:/tmp/fputsTest.txt\", \"w+\"); fprintf(fp, \"This is testing for fprintf...\\n\"); fputs(\"This is testing for fputs...\\n\", fp); fclose(fp); } 读文件 C 库函数 – fseek() | 菜鸟教程 (runoob.com) fseek() 描述 C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset ，参数 offset 意味着从给定的 whence 位置查找的字节数。 声明 下面是 fseek() 函数的声明。 int fseek(FILE *stream, long int offset, int whence) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 offset -- 这是相对 whence 的偏移量，以字节为单位。为正时，向后移动；为负时，向前移动。 whence -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一： |常量|描述| | :---------| :-------------------| |SEEK_SET|文件的开头| |SEEK_CUR|文件指针的当前位置| |SEEK_END|文件的末尾| 返回值 如果成功，则该函数返回零，否则返回非零值。 ftell() 描述 C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置，用来获取文件内部指针(位置指针)距离文件开头的字节数。【返回文件一共有多少个字节】 声明 下面是 ftell() 函数的声明。 long int ftell(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值 该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。 #include int main () { FILE *fp; int len; fp = fopen(\"text.txt\", \"r\"); if( fp == NULL ) { perror (\"打开文件错误\"); return(-1); } fseek(fp, 0, SEEK_END); len = ftell(fp); fclose(fp); printf(\"text.txt 的总大小 = %d 字节\\n\", len); return(0); } // 换行符占 1 字节 \\n ---------- 假设我们有一个文本文件 text.txt，它的内容如下： zhaocai mao ---------- D:\\CPP_Project\\Test1\\cmake-build-debug\\Test1.exe text.txt 的总大小 = 11 字节 rewind() 描述 C 库函数 void rewind(FILE *stream) 设置文件位置为给定流 stream 的文件的开头。用来将位置指针移动到文件开头。 声明 下面是 rewind() 函数的声明。 void rewind(FILE *stream) 参数 stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 返回值 该函数不返回任何值。 fgetc()/fgets() 下面是从文件读取单个字符的最简单的函数： int fgetc( FILE * fp ); fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF 。下面的函数允许您从流中读取一个字符串： char *fgets( char *buf, int n, FILE *fp ); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf ，并在最后追加一个 null 字符来终止字符串。 如果这个函数在读取最后一个字符之前就遇到一个换行符 '\\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 int fscanf(FILE *fp, const char *format, ...) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。 按字节读取 只能读取单字节的字母 #include #include #include // 读文件 char * ReadFile(const char * szFilePath) { FILE *pFile = NULL; char * szReadBuffer = NULL; int nReadFileSize = 0; // 打开文件，需要传入绝对路径 pFile = fopen(szFilePath, \"rb\"); if (NULL == pFile) { printf(\"Open file failed!\\r\\n\"); fclose(pFile); exit(0); } // 计算文件长度 fseek(pFile, 0, SEEK_END); nReadFileSize = ftell(pFile); rewind(pFile); //fseek(pFile, 0, SEEK_SET); // 分配读取缓存大小 szReadBuffer = (char *) malloc((sizeof(char) * nReadFileSize) + 1); if (NULL == szReadBuffer) { printf(\"malloc memory failed!\\r\\n\"); fclose(pFile); exit(0); } printf(\"分配了 %d 字节\\r\\n\", (sizeof(char) * (nReadFileSize)) + 1); printf(\"文件一共 %d 字节\\r\\n\", nReadFileSize); // 初始化内存 /** * 38 和 28 会有不一样的结果 * 38：zhaocai mao dd dd dddd ddddd * 28：zhaocai mao dd dd dddd dddddrogramData * * 为什么就会打印 38 个字符呢？明明只申请了 28 个。 */ memset(szReadBuffer, 0, nReadFileSize + 1); int nResLength = 0; // 记录实际读到的长度 nResLength = fread(szReadBuffer, 1, nReadFileSize,pFile); // 按 1 字节读取 printf(\"读取了 %d 字节\\r\\n\", strlen(szReadBuffer)); /** * 注意这个长度计算在有换行符号的情况下： * - fread() 会计算成 1 字节 * - ftell() 会计算成 2 字节 * * 搞了半天原来是我的 memset 初始化的时候 size 设置为了 nReadFileSize，忘记 + 1 了。 */ printf(\"ftell : %d 字节\\r\\n\", nReadFileSize); printf(\"fread : %d 字节\\r\\n\", nResLength); // 现在的写法在有换行的情况下会读取失败 if (nResLength != nReadFileSize) { printf(\"Read file failed !\\r\\n\"); fclose(pFile); exit(0); } fclose(pFile); return szReadBuffer; } int main() { char * szReadBufferRet = NULL; szReadBufferRet = ReadFile(\"D:\\\\tmp\\\\text.txt\"); //printf(\"%d\\r\\n\", strlen(szReadBufferRet)); printf(\"%s\\r\\n\", szReadBufferRet); free(szReadBufferRet); //system(\"pause\"); return 0; } // 按照字符和行标识读取文本 #include #include // 读文件 void ReadFile(const char * szFilePath) { FILE *pFile = NULL; char c; int nLine = 0; // 用于统计行数 // 打开文件 pFile = fopen(szFilePath, \"rb\"); if (NULL == pFile) { printf(\"Open file failed!\\r\\n\"); fclose(pFile); exit(0); } while ((c = fgetc(pFile)) != EOF) { if ('\\n' == c) { nLine ++; } //putchar(c); printf(\"%c\",c); } printf(\"\\r\\n该文本一共 %d 行~\\r\\n\", nLine); fclose(pFile); return ; } int main() { ReadFile(\"D:\\\\tmp\\\\text.txt\"); //system(\"pause\"); return 0; } 按行读取文本 #include #include #include // 读文件 void ReadFile(const char *szFilePath) { FILE *pFile = NULL; int nReadFileSize = 0; int nLines = 0; // 用于统计行数 char * szReadBuffer = NULL; // 打开文件 pFile = fopen(szFilePath, \"rb\"); if (NULL == pFile) { printf(\"Open file failed!\\r\\n\"); fclose(pFile); exit(0); } // 计算要读取文本的大小 fseek(pFile, 0, SEEK_END); nReadFileSize = ftell(pFile); rewind(pFile); // 将文件内部指针恢复到文件头 // 分配内存，这里是不是可以优化一下每行最多分配多少空间呢？我也不知道 szReadBuffer = (char *) malloc((sizeof(char) * nReadFileSize) + 1); if (NULL == szReadBuffer) { printf(\"malloc memory failed!\\r\\n\"); fclose(pFile); exit(0); } printf(\"分配了 %d 字节\\r\\n\", (sizeof(char) * (nReadFileSize)) + 1); printf(\"文件一共 %d 字节\\r\\n\", nReadFileSize); // 初始化内存空间 memset(szReadBuffer, 0, strlen(szReadBuffer) + 1); while (fgets(szReadBuffer, nReadFileSize + 1, pFile) != NULL) { nLines ++; // 统计行数 printf(\"%s\", szReadBuffer);// 打印文本 } printf(\"\\r\\n该文本一共 %d 行~\\r\\n\", nLines); fclose(pFile); return; } int main() { ReadFile(\"D:\\\\tmp\\\\text.txt\"); //system(\"pause\"); return 0; } ‍ ‍ 错误调试 Debug -- 监视 -- 输入 err,hr 就可以进行调试 ​ 修改文件读取权限 ​ ERROR 输出乱码：程序的入口处 main() 函数中，添加 system(\"chcp 65001 > nul\"); 【可以在渗透的时候使用，比如 CS 输入：chcp 65001 改变编码格式】 将 txt 文本编码格式改成 ANSI：打开记事本-> 文件-> 另存为-> 更改编码格式为 ANSI-> 保存。 (44 条消息) Debug Assertion Failed 问题怎么解决_很萌很蠢的博客-CSDN 博客 1、按 F5 运行你的程序 2、在出错时，选择“重试” 3、按 ALT+7 调出“调用栈”窗口 4、双击从上往下的最近一个自己定义的函数，系统会自动把该函数所在的文件显示出来，此时程序就暂停在光标处。一般来说错误就出在这附近。你可以通过查看变量的值来确认。 无法查找或打开 PDB 文件问题：VS“无法查找或打开 PDB 文件”是怎么回事？如何解决 (biancheng.net) 调试 -- 选项 -- 调试 -- 常规 -- 启用服务器资源支持 调试 -- 选项 -- 调试 -- 字符 -- Microsoft 符号服务器 ​ ​ 练习 练习 1 构造一个书籍信息结构体，并且使用结构体数组声明 100 个元素，编写增删改查 4 个函数 头文件 #include #include #include // 定义书的链表结构 typedef struct _BookNode { char szBookName[100]; int nBookNumber; double dPrice; struct _BookNode *next; // 指向下一节点 }BookNode, *pBookNode; // 定义添加书籍函数（简陋版先以书名作为唯一标识吧！） pBookNode AppendBook(pBookNode head, char *pBookName, int nBookNumber, double dPrice); // 查询书籍 void SearchBook(pBookNode head, char * szBookName); // 显示所有书籍 void DisplayAllBook(pBookNode head); // 修改书籍信息(定价) int ModifyBookInfo(pBookNode head, char * szBookName, double dPrice); // 删除书籍 pBookNode DeleteBook(pBookNode head, char * szBookName); 源码 #include \"main.h\" int main() { //pBookNode == BookNode * pBookNode head = NULL; while (1) { int nOperate; char szBookName[100]; int nBookNumber; double dBookPrice; // 提示信息 printf(\"请选择需要进行的操作：\\r\\n\"); printf(\"1. 添加书籍\\r\\n\"); printf(\"2. 所有书籍\\r\\n\"); printf(\"3. 查找书籍\\r\\n\"); printf(\"4. 修改书籍\\r\\n\"); printf(\"5. 删除书籍\\r\\n\"); // 选择操作 scanf(\"%d\", &nOperate); switch (nOperate) { case 1: { printf(\"请输入书名：\"); scanf(\"%s\", szBookName); printf(\"请输入书号：\"); scanf(\"%d\", &nBookNumber); printf(\"请输入定价：\"); scanf(\"%lf\", &dBookPrice); head = AppendBook(head, szBookName, nBookNumber, dBookPrice); break; } case 2: { DisplayAllBook(head); break; } case 3: { printf(\"请输入书名进行查询：\"); scanf(\"%s\", szBookName); SearchBook(head, szBookName); break; } case 4: { printf(\"请输入要修改的书籍名称：\"); scanf(\"%s\", szBookName); printf(\"请输入更新的定价：\"); scanf(\"%lf\", &dBookPrice); ModifyBookInfo(head, szBookName, dBookPrice); break; } case 5: { printf(\"请输入要删除的书籍名称：\"); scanf(\"%s\", szBookName); DeleteBook(head, szBookName); break; } default: break; } } return 0; } // 添加书籍，后续可以让书号唯一~ pBookNode AppendBook(pBookNode head, char *pBookName, int nBookNumber, double dPrice) { // 定义新的节点和头结点 pBookNode pNewBookNode = NULL; pBookNode pHeadBookNode= head; // 分配内存 pNewBookNode = (pBookNode)malloc(sizeof(BookNode)); if (NULL == pNewBookNode) { printf(\"memory malloc failed!\\r\\n\"); exit(0); } // 如果链表一开始为空，那么新建的就是头节点 if (NULL == pHeadBookNode) { head = pNewBookNode; } else { // 将指针移动到后面进行添加 while (pHeadBookNode->next != NULL) { pHeadBookNode = pHeadBookNode->next; } pHeadBookNode->next = pNewBookNode; } // 添加书籍信息 strcpy(pNewBookNode->szBookName, pBookName); pNewBookNode->nBookNumber = nBookNumber; pNewBookNode->dPrice = dPrice; pNewBookNode->next = NULL; return head; } void SearchBook(pBookNode head, char *szBookName) { pBookNode pHeadBookNode= head; int nFlag = 0; if (NULL == pHeadBookNode) { printf(\"书库为空，请添加书籍后查询~\\r\\n\"); exit(0); } while (pHeadBookNode != NULL) { if (strcmp(pHeadBookNode->szBookName, szBookName) == 0) { nFlag = 1; printf(\"书名：%s\\r\\n书号：%d\\r\\n价格：%lf\\r\\n\", pHeadBookNode->szBookName, pHeadBookNode->nBookNumber, pHeadBookNode->dPrice); } pHeadBookNode = pHeadBookNode->next; } if (nFlag == 0) { printf(\"书库中不存在名为《%s》的书籍~\\r\\n\", szBookName); } free(pHeadBookNode); return ; } void DisplayAllBook(pBookNode head) { pBookNode tmpBookInfoNode = head; if (NULL == tmpBookInfoNode) { printf(\"书库为空，请添加书籍后查看~\\r\\n\"); exit(0); } while (tmpBookInfoNode != NULL) { printf(\"=============================\\r\\n\"); printf(\"书名：%s\\r\\n书号：%d\\r\\n价格：%lf\\r\\n\", tmpBookInfoNode->szBookName, tmpBookInfoNode->nBookNumber, tmpBookInfoNode->dPrice); tmpBookInfoNode = tmpBookInfoNode->next; } printf(\"=============================\\r\\n\"); free(tmpBookInfoNode); return ; } int ModifyBookInfo(pBookNode head, char *szBookName, double dNewPrice) { pBookNode tmpBookInfoNode = head; double dOldPrice = 0; if (NULL == tmpBookInfoNode) { printf(\"书库为空，请添加书籍后修改~\\r\\n\"); exit(0); } while (tmpBookInfoNode != NULL) { if (strcmp(tmpBookInfoNode->szBookName, szBookName) == 0) { dOldPrice = tmpBookInfoNode->dPrice; tmpBookInfoNode->dPrice = dNewPrice; printf(\"《%s》价格由 %lf 更新为 %lf！\\r\\n\", szBookName, dOldPrice, dNewPrice); printf(\"====================\\r\\n\"); printf(\"书名：%s\\r\\n书号：%d\\r\\n价格：%lf\\r\\n\", tmpBookInfoNode->szBookName, tmpBookInfoNode->nBookNumber, tmpBookInfoNode->dPrice); return 1; } tmpBookInfoNode = tmpBookInfoNode->next; } free(tmpBookInfoNode); return 0; } pBookNode DeleteBook(pBookNode head, char *szBookName) { pBookNode tmpBookInfoNode = head; pBookNode tmp = NULL; pBookNode pre = NULL; if (NULL == tmpBookInfoNode) { printf(\"操作失败，书库为空~\\r\\n\"); exit(0); } while (tmpBookInfoNode!= NULL) { if (strcmp(tmpBookInfoNode->szBookName, szBookName) == 0) { tmp = tmpBookInfoNode->next; pre->next = tmp; tmpBookInfoNode->next = NULL; printf(\"《%s》已成功从书库中删除~\\r\\n\", szBookName); return head; } pre = tmpBookInfoNode; tmpBookInfoNode = tmpBookInfoNode->next; } printf(\"删除失败，《%s》不存在~\\r\\n\", szBookName); free(tmpBookInfoNode); free(pre); return head; } 使用预处理指令判断当前处于什么操作系统环境下 编写一个文件加解密程序（Linux）（权限 w:sudo）【异或加密】 #include #include #include // 写文件 int WriteFile(char * szFilePath, char * szBuffer) { FILE * pFile = NULL; pFile = fopen(szFilePath, \"w\"); if (NULL == pFile) { printf(\"open file failed!\\r\\n\"); fclose(pFile); exit(0); } int nRet = fwrite(szBuffer, (strlen(szBuffer + 1) * sizeof(char)), 1, pFile); fclose(pFile); return nRet; } // 读文件 char * ReadFile(const char * szFilePath) { FILE *pFile = NULL; char * szReadBuffer = NULL; int nReadFileSize = 0; // 打开文件，需要传入绝对路径 pFile = fopen(szFilePath, \"rb\"); if (NULL == pFile) { printf(\"Open file failed!\\r\\n\"); fclose(pFile); exit(0); } // 计算文件长度 fseek(pFile, 0, SEEK_END); nReadFileSize = ftell(pFile); rewind(pFile); //fseek(pFile, 0, SEEK_SET); // 分配读取缓存大小 szReadBuffer = (char *) malloc((sizeof(char) * nReadFileSize) + 1); if (NULL == szReadBuffer) { printf(\"malloc memory failed!\\r\\n\"); fclose(pFile); exit(0); } printf(\"分配了 %d 字节\\r\\n\", (sizeof(char) * (nReadFileSize)) + 1); printf(\"文件一共 %d 字节\\r\\n\", nReadFileSize); // 初始化内存 memset(szReadBuffer, 0, nReadFileSize + 1); int nResLength = 0; // 记录实际读到的长度 nResLength = fread(szReadBuffer, 1, nReadFileSize,pFile); // 按 1 字节读取 printf(\"读取了 %d 字节\\r\\n\", strlen(szReadBuffer)); printf(\"ftell : %d 字节\\r\\n\", nReadFileSize); printf(\"fread : %d 字节\\r\\n\", nResLength); if (nResLength != nReadFileSize) { printf(\"Read file failed !\\r\\n\"); fclose(pFile); exit(0); } fclose(pFile); return szReadBuffer; } // 异或加密 void XorCode(char *buffer, int nSize, char key) { for(size_t i=0; i7957?v;79v(( 异或解密后的字符串：zhaocai mao ~~ 练习 2 初步完成贪吃蛇游戏的代码 前人栽树 C 文件读写 | 菜鸟教程 (runoob.com) C 语言实现对文件流的读写工作_W\\Y.的博客-CSDN 博客_c 语言文件流读写 【C 语言】C 语言读取文本文件_贾继康的博客-CSDN 博客_c 读取文本 ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 04:59:08 "},"C++ 基础/CPP - 01 面向对象基础.html":{"url":"C++ 基础/CPP - 01 面向对象基础.html","title":"CPP - 01 面向对象基础","keywords":"","body":"简介 C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。 -- Bjarne Stroustrup 注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。 标准化 发布时间 通称 备注 2017 C++17 第五个C++标准 2017 coroutines TS 协程库扩展 2017 ranges TS 提供范围机制 2017 library fundamentals TS 标准库扩展 2016 concurrency TS 用于并发计算的扩展 2015 concepts TS 概念库，用于优化编译期信息 2015 TM TS 事务性内存操作 2015 parallelism TS 用于并行计算的扩展 2015 filesystem TS 文件系统 2014 C++14 第四个C++标准 2011 - 十进制浮点数扩展 2011 C++11 第三个C++标准 2010 - 数学函数扩展 2007 C++TR1 C++技术报告：库扩展 2006 - C++性能技术报告 2003 C++03 第二个C++标准 1998 C++98 第一个C++标准 关键字 https://www.runoob.com/w3cnote/cpp-keyword-intro.html ​ 三字符组 三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。 三字符组 替换 ??= # ??/ \\ ??' ^ ??( [ ??) ] ??! | ?? { ??> } ??- ~ 左值 & 右值 左值（lvalue）：​==指向内存位置的表达式==被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）==指的是存储在内存中某些地址的数值==。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。 长代码分割 字符串字面值或常量是括在双引号 \"\"​ 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 您可以使用 ** 做分隔符，把一个很长的字符串常量进行分行。 string greeting2 = \"hello, \\ runoob\"; 类型限定符 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： ​auto​ ​register​ ​static​ ​extern​ ​mutable​ ​thread_local (C++11)​ 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 auto 存储类 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。 根据初始化表达式自动推断被声明的变量的类型，如： auto f=3.14; //double auto s(\"hello\"); //const char* auto z = new auto(9); // int* auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型 register 存储类 register 存储类用于定义存储在==寄存器==中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&'​ 运算符（因为它没有内存位置）。 { register int miles; } static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。【==属于类==】 #include // 函数声明 void func(void); static int count = 10; /* 全局变量 */ int main() { while(count--) { func(); } return 0; } // 函数定义 void func( void ) { static int i = 5; // 局部静态变量 i++; std::cout extern 存储类 extern 存储类==用于提供一个全局变量的引用==，全局变量对所有的程序文件都是可见的。当使用 'extern'​ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern​ 来得到已定义的变量或函数的引用。可以这么理解，extern​ 是用来在另一个文件中声明一个全局变量或函数。 ​extern​ 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： #include int count ; extern void write_extern(); int main() { count = 5; write_extern(); } #include extern int count; void write_extern(void) { std::cout mutable 存储类 mutable 说明符仅适用于类的对象，它允许对象的成员替代常量。也就是说，mutable​ 成员可以通过 const 成员函数修改。 thread_local 存储类 使用 thread_local​ 说明符声明的变量==仅可在它在其上创建的线程上访问==。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 ​thread_local​ 说明符可以与 static​ 或 extern​ 合并。 可以将 thread_local​ 仅应用于数据声明和定义，thread_local​ 不能用于函数声明或定义。 以下演示了可以被声明为 thread_local​ 的变量： thread_local int x; // 命名空间下的全局变量 class X { static thread_local std::string s; // 类的 static 成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo() { thread_local std::vector v; // 本地变量 } 类和对象 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 如 Human 类：身高、体重、年龄、行为等都可以抽象出来。 ​ 类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。 class Box { public: double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度 }; // 类名可以当作数据类型来用，相当于自定义的数据类型标识 Box Box1; // 声明 Box1，类型为 Box 成员变量/函数 ​ 类的成员函数：是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。 成员函数可以定义在类定义内部，或者单独使用 范围解析运算符 :: 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。 class Box { public: // 成员变量声明 double length; // 长度 double breadth; // 宽度 double height; // 高度 // 成员函数声明 double getVolume(void); void setLength( double len ); void setBreadth( double bre ); void setHeight( double hei ); }; 修饰符 数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。 成员和类的默认访问修饰符是 private。 class Base { public: // 公有成员：在程序中类的外部是可访问的。 protected: // 受保护成员：成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。 private: // 私有成员：变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 }; 普通成员 静态成员 可以使用 static​ 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。【静态的是属于类的而不是属于对象的~】 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 ::​ 就可以访问。 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。【因为属于类，this​ 指针本质上是一个可变对象~】 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。 构造函数 类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void 构造函数可用于为某些成员变量设置初始值。 默认的构造函数没有任何参数 构造函数也可以带有参数。 使用初始化列表来初始化字段（列表） C++ 类构造函数 & 析构函数 | 菜鸟教程 (runoob.com) #include using namespace std; class Line { public: void setLength(double len); double getLength(void); double getWidthLength(void); Line(); // 无参构造函数 Line(double len); // 这是有参构造函数 Line(double len, double wid); // 测试初始化列表的构造函数 private: double length; double width; }; // 成员函数定义，包括构造函数 Line::Line() { cout 拷贝构造函数 C++ 拷贝构造函数 | 菜鸟教程 (runoob.com) 拷贝构造函数是一种特殊的构造函数，它在创建对象时，==是使用同一类中之前创建的对象来初始化新创建的对象。==拷贝构造函数通常用于： 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。 如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果==类带有指针变量==，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下： classname (const classname &obj) { // 构造函数的主体 } #include using namespace std; class Line { public: int getLength( void ); Line( int len ); // 简单的构造函数 Line( const Line &obj); // 拷贝构造函数 ~Line(); // 析构函数 private: int *ptr; }; // 成员函数定义，包括构造函数 Line::Line(int len) { cout 调用构造函数 调用拷贝构造函数并为指针 ptr 分配内存 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 释放内存 释放内存 析构函数 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~​）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。 ​~TestClass(); // 这是析构函数声明​ 对象数组 This 指针 C++ 中的 this 指针 | 菜鸟教程 (runoob.com) 在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this​ 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。 友元函数没有 this​ 指针，因为友元不是类的成员。只有成员函数才有 this​ 指针。 当我们调用成员函数时，实际上是替某个对象调用它。 成员函数通过一个名为 this​​ 的额外隐式参数来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化 this。 内联函数 C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline​，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline​ 限定符。 在类定义中的定义的函数都是内联函数，即使没有使用 inline​ 说明符。 常函数 ‍ ‍ 流 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 包含 和 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision ），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流（cout） 预定义的对象 cout 是 iostream 类 的一个实例。cout 对象\"连接\"到标准输出设备，通常是显示屏。cout 是与流插入运算符 结合使用的，如下所示： 实例 #include using namespace std; int main( ) { char str[] = \"Hello C++\"; cout 当上面的代码被编译和执行时，它会产生下列结果： Value of str is : Hello C++ 标准输入流（cin） 预定义的对象 cin 是 iostream 类 的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 >> 结合使用的，如下所示： 实例 #include using namespace std; int main( ) { char name[50]; cout > name; cout 标准错误流（cerr） 预定义的对象 cerr 是 iostream 类 的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 cerr 也是与流插入运算符 结合使用的，如下所示： 实例 #include using namespace std; int main( ) { char str[] = \"Unable to read....\"; cerr 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... 标准日志流（clog） 预定义的对象 clog 是 iostream 类 的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。 clog 也是与流插入运算符 结合使用的，如下所示： 实例 #include using namespace std; int main( ) { char str[] = \"Unable to read....\"; clog 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... 通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 endl 插入换行符并刷新输出流。 C++ 中 endl 的本质是什么_xiaofei0859 的博客-CSDN 博客_c++ endl 原因是对于一个函数而言，函数名本身就代表函数的入口地址，而函数名前加 & 也代表函数的入口地址。cout == cout 在 头文件中定义的操纵符有： endl:输出时插入换行符并刷新流 endls：输出时在字符 插入 NULL 作为尾符 flush：刷新缓冲区，把流从缓冲区输出到目标设备，并清空缓冲区 ws：输入时略去空白字符 dec：令 IO 数据按十进制格式 hex：令 IO 数据按十六进制格式 oct：令 IO 数据按八进制格式 :: 作用域运算符 std:: 使用定义在 std 命名空间的名称。 std:: 是个名称空间标示符，C++ 标准库中的函数或者对象都是在 命名空间 std 中定义的，所以我们要使用标准函数库中的函数或对象都要使用 std 来限定。 如： ---------- #include // 这种非标准的库包含就不需要加 std:: 限定 #include // 这种标准的就需要 ---------- #include using std::cout; // 指定命名空间中的特定项目，如使用 std 命名空间中的 cout 部分 using std::endl; // 或者直接：using namespace std; int main() { cout 命名空间 C++ 命名空间 | 菜鸟教程 (runoob.com) 为了解决同名问题，比如有两只猫都叫招财，但是你家的招财和我家的招财应该是两只不同的猫，怎么区分呢？那就是加限定词，如“张三家的”，”李四家的“ 用来区分。 因此，引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的 函数、类、变量 等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。 定义命名空间 命名空间的定义使用关键字 namespace ，后跟命名空间的名称，如下所示： // 定义命名空间 namespace namespace_name { // 代码声明 } // 调用 name::code; // code 可以是变量或函数 #include using namespace std; // 第一个命名空间 namespace first_space { void func(){ cout using 指令 您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。【就近原则】 using std::cout; // 指定命名空间中的特定项目，如使用 std 命名空间中的 cout 部分 不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。 所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。 嵌套的命名空间 命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间。 namespace namespace_name1 { // 代码声明 namespace namespace_name2 { // 代码声明 } } ---------- // 可以通过使用 :: 运算符来访问嵌套的命名空间中的成员 // 访问 namespace_name2 中的成员 using namespace namespace_name1::namespace_name2; // 访问 namespace_name1 中的成员 using namespace namespace_name1; 内存管道 C++ 动态内存 | 菜鸟教程 (runoob.com) C++ 程序中的内存分为两个部分： 栈： 在函数内部声明的所有变量都将占用栈内存。 堆： 这是程序中未使用的内存，在程序运行时可用于动态分配内存。 new 和 delete 运算符 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法： new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点： // 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： double* pvalue = NULL; // 初始化为 null 的指针 if(!(pvalue = new double )) { // 为变量请求内存 cout new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存。 delete pvalue; // 释放 pvalue 所指向的内存 ---------- char* pvalue = NULL; // 初始化为 null 的指针 pvalue = new char[20]; // 为变量请求内存 // 要删除我们刚才创建的数组，语句如下： delete [] pvalue; // 删除 pvalue 所指向的数组 二维数组 int **array // 假定数组第一维长度为 m， 第二维长度为 n // 动态分配空间 array = new int *[m]; for( int i=0; i 三维数组 int ***array; // 假定数组第一维为 m， 第二维为 n， 第三维为h // 动态分配空间 array = new int **[m]; for( int i=0; i 对象数组 TestClass * myTestClassArray = new TestClass[4]; // 定义 TestClass 类数组 delete [] myTestClassArray; // 删除数组 异常处理 ​ 异常 描述 std::exception 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 new 抛出。 std::bad_cast 该异常可以通过 dynamic_cast 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 std::bad_typeid 该异常可以通过 typeid 抛出。 std::logic_error 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。 std::runtime_error 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 C++ 异常处理涉及到三个关键字： try、catch、throw 。 C++ 提供了一系列标准的异常，定义在 中。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 throw 语句的操作数可以是任意的表达式（任何地方），表达式的结果的类型决定了抛出的异常的类型。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。 try { // 保护代码 }catch( ExceptionName e1 ) { // catch 块 }catch( ExceptionName e2 ) { // catch 块 }catch( ExceptionName eN ) { // catch 块 } // 不一定真的处理，取决于你写的异常处理代码，然后程序继续往下执行~ 捕获异常 catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。 try { // 保护代码 }catch( ExceptionName e ) { // 处理 ExceptionName 异常的代码 } 会捕获一个类型为 ExceptionName 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ... try { // 保护代码 }catch(...) { // 能处理任何异常的代码 } 定义新的异常 您可以通过 继承和重载 exception 类 来定义新的异常。 what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。 #include #include using namespace std; struct MyException : public exception { const char * what () const throw () { return \"C++ Exception\"; } }; int main() { try { throw MyException(); }catch(MyException& e) { // 自定义的异常类型，重写了 what() 函数 std::cout 引用 C++ 引用 | 菜鸟教程 (runoob.com) 引用和指针的区别 不存在空引用，引用必须连接到一个合法的内存。 一旦引用被初始化，就不能改变它的值。【就是说只能作为一块空间的引用，不能改变】指针可以随时改变指向的地址（空间）。 引用必须在创建的时候进行初始化，指针可以随时初始化。 引用：就是给同一块内存空间起别名。 变量类型 & = 变量; e.g. #include using namespace std; int main () { // 声明简单的变量 int i; double d; // 声明引用变量 int& r = i; double& s = d; i = 5; cout 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 把引用作为参数 void swap(int& x, int& y); 和用指针是一样的，同样是对地址的值进行操作，会影响实参的值。 把引用作为返回值 C++ 函数可以返回一个引用，方式与返回一个指针类似。 double& setValues(int i) { double& ref = vals[i]; return ref; // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i] } 当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。 int& func() { int q; //! return q; // 在编译时发生错误 static int x; return x; // 安全，x 在函数作用域外依然是有效的 } 文件流 C++ 中的一个标准库 fstream 。 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。【对外输出】 ifstream 该数据类型表示输入文件流，用于从文件读取信息。【从外接收/输入】 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 打开文件 open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); // 第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 #include #include using namespace std; int main () { ofstream outfile; outfile.open(\"file.txt\", ios::out | ios::trunc); outfile > data; cout > data; // 再次读取数据，运行可知每次只会读取到空格或者换行 cout > data; // 再次读取数据 cout 以 空格 或 换行 作为一次流的读取分割符号。 关闭文件 当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void close(); cin 对象的附加函数，比如 getline() 函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。 // 定位到 fileObject 的第 n 个字节（假设是 ios::beg） fileObject.seekg( n ); // 把文件的读指针从 fileObject 当前位置向后移 n 个字节 fileObject.seekg( n, ios::cur ); // 把文件的读指针从 fileObject 末尾往回移 n 个字节 fileObject.seekg( n, ios::end ); // 定位到 fileObject 的末尾 fileObject.seekg( 0, ios::end ); // 和 C 的 fseek() 类似 练习 实现一个基本 NPC 类，具备常规属性及功能(ID,名称，HP,MP，坐标，喊话，攻击技能，移动) 使用 C++ 的输入输出方式完成一个具有加减乘除功能的计算器。 使用 C++ 文件流的方式，将计算过程及结果输出至文件（例如 1 + 2 = 3）（在使用文件流的过程中，使用 new 和 delete 动态分配释放内存。） 根据第二题的计算机，重新编写，计算器的四个函数，使用同一个函数名，根据命名空间不同，具有不同的效果。 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 13:36:54 "},"C++ 基础/CPP - 02 重载.html":{"url":"C++ 基础/CPP - 02 重载.html","title":"CPP - 02 重载","keywords":"","body":" C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载 。 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com) 函数重载 这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。 void print(int i) {} void print(double i) {} void print(char c[]) {} 运算符重载 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。operator 是关键字，它与重载的运算符一起构成函数名。 Box operator+(const Box&); --------- 返回值类型 类名::operator重载的运算符(参数表) {    …… } 可重载的运算符列表 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)， (大于)，=(大于等于) 逻辑运算符 单目运算符 + (正)，-(负)，*(指针)，&(取地址) 自增自减运算符 ++(自增)，--(自减) 位运算符 赋值运算符 =, +=, -=, *=, /= , %= , &=, 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，->(成员访问) “->”运算符是成员访问运算符，这种单目运算符只能被重载为成员函数，,(逗号)，[](下标) 数据类型 类名::operator->(); new 和 delete 只能被重载为类的成员函数，不能重载为友元。而且，无论是否使用关键字 static 进行修饰，重载了的 new 和 delete 均为类的静态成员函数。 不可重载的运算符列表 .：成员访问运算符 .*, ->*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 类外/内重载：this 指针的区别。 单目运算符，类内（成员函数）重载 #include #include #include using namespace std; class MyString { public: int m_nNumberA; int m_nNumberB; char * szStr; public: MyString() {}; MyString(int nNumberA, int nNumberB): m_nNumberA(nNumberA), m_nNumberB(nNumberB) {}; MyString(char * szStr);; MyString operator+(const MyString &objB); }; #include \"main.h\" int main() { MyString objA(11, 22); MyString objB(33, 44); MyString objC = objA + objB; cout szStr = new char [strlen(szStr) + 1]; memset(this->szStr, 0, strlen(szStr) + 1); strcpy(this->szStr, szStr); } MyString MyString::operator+(const MyString &objB) { // 有一个隐含的 this 指针 MyString tmpObj; tmpObj.m_nNumberA = this->m_nNumberA + objB.m_nNumberA; tmpObj.m_nNumberB = this->m_nNumberB + objB.m_nNumberB; return tmpObj; } c++ - overloaded 'operator+' must be a unary or binary operator error - Stack Overflow 重载 'operator+' 必须是一元或二元运算符错误。 overloaded 'operator+' must be a unary or binary operator (has 3 parameters) 听起来您已将运算符声明为成员函数。成员函数采用隐式第一个参数，这意味着您的运算符现在采用三个参数。以下两个办法可以解决此错误： 可以通过将其设为非成员函数。 或者减少一个参数。 前置 ++ 和 后置 ++ 若想要实现 ++(++a) 这种连续自加，就要返回其对象的引用，这样才能保证操作的是同一块内存空间，否则就只是单纯的赋值操作，原来的对象并未被修改。 #include #include #include using namespace std; class MyString { public: int m_nNumberA; int m_nNumberB; char * szStr; public: MyString() {}; MyString(int nNumberA, int nNumberB): m_nNumberA(nNumberA), m_nNumberB(nNumberB) {}; MyString(char * szStr);; MyString operator+(const MyString &objB); MyString operator++(); // 前置 ++ MyString operator--(); MyString operator++(int); // 后置 ++ MyString operator--(int); }; #include \"main.h\" int main() { MyString objA(11, 22); MyString objB(33, 44); MyString objC = objA + objB; cout szStr = new char [strlen(szStr) + 1]; memset(this->szStr, 0, strlen(szStr) + 1); strcpy(this->szStr, szStr); } MyString MyString::operator+(const MyString &objB) { MyString tmpObj; tmpObj.m_nNumberA = this->m_nNumberA + objB.m_nNumberA; tmpObj.m_nNumberB = this->m_nNumberB + objB.m_nNumberB; return tmpObj; } // 前置 ++，先加后用 MyString MyString::operator++() { this->m_nNumberA++; this->m_nNumberB++; return *this; } // 后置 ++，先用后加 MyString MyString::operator++(int) { MyString tmp = *this; this->m_nNumberA++; this->m_nNumberB++; return tmp; } MyString MyString::operator--() { this->m_nNumberA--; this->m_nNumberB--; return *this; } MyString MyString::operator--(int) { MyString tmp = *this; this->m_nNumberA--; this->m_nNumberB--; return tmp; } 下标运算符 [ ] 重载 int main() { // [] 重载测试 int arr[2] = {2, 5}; // 从下标 2 开始，往后 3 个。 char szBuffer1[] = \"zhaocai\"; MyString objF(szBuffer1); MyString objG; objG = objF[arr]; cout szStr[i + arr[0]]; } return tmpStr; } () 运算符重载 函数调用运算符 () 可以被重载用于类的对象。当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数。 只能说明成类的非静态成员函数 函数类型 类名::operator()(参数表) 常量与指针间的转换 warning: ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings]_sober0314的博客-CSDN博客 warning: ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings] - zkfopen - 博客园 (cnblogs.com) // 在C++中， char* p = \"abc\";　　// valid in C, invalid in C++ // 会跳出警告：warning: ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings] //改成下面会通过 warning char* p = (char*)\"abc\"; // OK //或者改成下面： char const *p = \"abc\";　　// OK 字符串常量是不能转化为指针变量的。指针数组中存放的是指针变量，指针变量存放的是右边每一个字符串常量的内存首地址，是指示器。右边则只是字符串常量即字面上“how r u ?\" 这些。指针即地址和常量有本质性的区别。编译器虽然可以编译，但是会给出警告，表明这是不符合规定的。 char *p[3] = { \"how r u ?\", \"i'm fine,thanks.\", \"and u ?\"}; // 建议写成 const char *p[3] = {}; C++ 函数调用运算符 () 重载 | 菜鸟教程 (runoob.com) int main() { // () 重载测试 char szBuffer1[] = \"zhaocai\"; MyString objH(szBuffer1); MyString objI; objI = objH(\"mao\"); cout szStr) + nLength + 1; tmp.szStr = new char [nSumLength]; memset(tmp.szStr, 0, nSumLength); strcat(tmp.szStr, this->szStr); strcat(tmp.szStr, szBuffer); return tmp; } 输入（>>）输出（ 需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。【当然你想创建对象再调用也是可以的~】 C++ 输入输出运算符重载 | 菜鸟教程 (runoob.com) int main() { // 输入输出重载测试 MyString objA; cin >> objA; cout szStr) + nLength + 1; tmp.szStr = new char [nSumLength]; memset(tmp.szStr, 0, nSumLength); strcat(tmp.szStr, this->szStr); strcat(tmp.szStr, szBuffer); return tmp; } // >> 参数需要传地址，不然修改了你也传不出来。形参和实参~ istream &operator>>(istream &cin, MyString &obj) { cin >> obj.m_nNumberA >> obj.m_nNumberB; return cin; } ostream &operator 【注意】：如果需要连续使用 >> 或者 则需要返回流对象。若函数的返回值为 void 则会出现一下错误。 ​ 拷贝构造 深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。 浅拷贝只是对象数据之间的简单赋值（如：b.size = a.size, b.data = a.data）。 如果对象中没有其他的资源（如：堆，文件，系统资源等），即成员不包括指针和引用时，则深拷贝和浅拷贝没有什么区别。==【因为涉及指针的时候，那你简单赋值，指针指向的也是同一个地址。（指针的本质不就是存的值是一个地址吗？那么他们存的值（地址）就是一样的），所以指向同一内存空间】== 如你设计了一个没有类而没有提供它的拷贝构造函数，当用该类的一个对象去给令一个对象赋值时所执行的过程就是浅拷贝。 浅拷贝 #include #include #include using namespace std; class MyString { public: int m_nNumberA; int m_nNumberB; char * szStr; public: MyString() {}; MyString(int nNumberA, int nNumberB): m_nNumberA(nNumberA), m_nNumberB(nNumberB) {}; MyString(char * szStr);; MyString operator=(MyString obj); // 浅拷贝 }; #include \"main.h\" int main() { // 拷贝测试 char szBuffer[] = \"zhaocai\"; MyString objD(szBuffer); MyString objE = objD; return 0; } MyString::MyString(char *szStr) { this->szStr = new char [strlen(szStr) + 1]; memset(this->szStr, 0, strlen(szStr) + 1); strcpy(this->szStr, szStr); } // 浅拷贝 MyString MyString::operator=(MyString obj) { this->m_nNumberA = obj.m_nNumberA; this->m_nNumberB = obj.m_nNumberB; return *this; } ​ 这里 b 的指针 data 和 a 的指针指向了堆上的同一块内存，a 和 b 析构时，b 先把其 data 指向的动态分配的内存释放了一次，而后 a 析构时又将这块已经释放过的内存再释放一次。【对同一块内存多次释放问题】 对同一块内存释放执行 2 次及 2 次以上的释放会造成内存泄露或者是程序 crash！ 深拷贝 #include \"main.h\" int main() { // 深拷贝测试 char szBuffer[] = \"zhaocai\"; MyString objD(szBuffer); // MyString objE = objD; // 这样的话不会调用重载的 = 深拷贝操作，因为这样调用的是拷贝构造函数，而默认情况下拷贝构造函数就是浅拷贝。【规定就是这样的】 // 所以要分开写，先初始化，再赋值。 MyString objE; objE = objD; return 0; } MyString::MyString(char *szStr) { this->szStr = new char [strlen(szStr) + 1]; memset(this->szStr, 0, strlen(szStr) + 1); strcpy(this->szStr, szStr); } // 深拷贝 MyString MyString::operator=(const MyString &obj) { this->m_nNumberA = obj.m_nNumberA; this->m_nNumberB = obj.m_nNumberB; this->szStr = new char [strlen(obj.szStr) + 1]; memset(this->szStr, 0, strlen(obj.szStr) + 1); strcpy(this->szStr, obj.szStr); return *this; } ​ = 运算符重载不调用问题 https://blog.csdn.net/u014583317/article/details/109217780 练习 实现一个字符串类，重载运算符 +（拼接） -（减去子串） *（复制拼接） = （赋值） == （判断相等） 前人栽树 C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com) ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:56 "},"C++ 基础/CPP - 03 继承.html":{"url":"C++ 基础/CPP - 03 继承.html","title":"CPP - 03 继承","keywords":"","body":"继承 面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类。 当创建一个类时，可以不重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 ​ // 基类 class Animal { // eat() 函数 // sleep() 函数 }; //派生类 class Dog : public Animal { // bark() 函数 }; 可以存在多继承 class :,,… { }; 继承中的特点 有 public, protected, private 三种继承方式，它们相应地改变了基类成员的访问属性。【继承方式为最高权限】 public 继承： 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private protected 继承： 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private private 继承： 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private 如果继承时不显示声明是 private，protected，public 继承，则默认是 private 继承，在 struct 中默认 public 继承 但无论哪种继承方式，上面两点都没有改变： private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；【​==其实也就是不能被继承==​】 protected 成员可以被派生类访问。【==可以被继承==】 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 构造函数 & 析构函数在继承中的表现 调用顺序 构造函数：先调用基类（父类）的构造函数，后调用派生类（子类）的构造函数。 析构函数：先调用派生类（子类）的析造函数，后调用基类（父类）的析造函数。 内部类 先基类 -- 内部类 -- 本类 调用了 CA 的构造函数 CA() 调用了 CN 的构造函数 CN() 调用了 CB 的构造函数 CB() 调用了 CB 的构造函数 ~CB() 调用了 CN 的析造函数 ~CN() 调用了 CA 的析造函数 ~CA() ---------- #include using namespace std; class CN { public: CN(); // 普通构造函数 ~CN(); // 析构函数 }; class CA { public: CA(); // 普通构造函数 ~CA(); // 析构函数 void go(); }; class CB :public CA{ public: CN objCN; public: CB(); // 普通构造函数 ~CB(); // 析构函数 void go(); // 重写继承自 CA 的 go() 函数 }; int main() { // 调用顺序测试 //CB objCB1; CB * objCB2 = new CB; //delete objCB2; objCB2->go(); // 没有重写的时候调用的师傅类的，重写后就是调用自己重写的 objCB2->CA::go(); // 重写后还想调用父类的 go() 函数就需要使用作用域 system(\"pause\"); } CA::CA(){ cout 重载和重写 重载：类自身的函数重载。 重写：类之间的继承，重写同名函数。 重写后继续想使用父类的函数可以使用作用域 ::​​​ 子类如果重写了父类的函数，父类的所有重载函数均为失效，只能使用作用域访问。 多继承 调用方法指定，父类有，父类的父类也有~ ​ 需要一层一层的逐步调用 class CA class CB :public CA class CC :public CA class CD :public CB, public CC 菱形继承 同一变量有两个值（副本）【二义性问题】 -- 虚基类解决 virtual​ #include using namespace std; class CN { public: CN(); // 普通构造函数 ~CN(); // 析构函数 }; class CA { public: int nAge; public: CA(); // 普通构造函数 ~CA(); // 析构函数 void go(); void sleep(); }; class CB :public virtual CA{ public: CB(); // 普通构造函数 ~CB(); // 析构函数 void go(); // 重写继承自 CA 的 go() 函数 }; class CC :public virtual CA { public: CC(); // 普通构造函数 ~CC(); // 析构函数 void go(); void sleep(); }; class CD :public CB, public CC { public: CD(); // 普通构造函数 ~CD(); // 析构函数 //void go(); }; int main() { // 调用顺序测试 CD * objCD1 = new CD; objCD1->CC::go(); objCD1->CB::go(); // 重写后还想调用父类的 go() 函数就需要使用作用域 // objCD1->CA::sleep(); // 这样会出错，提示：错误 C2385 对“CA”的访问不明确 objCD1->CB::CA::sleep(); // 需要一步一步的走,CB 是继承的 sleep() 没有重写 objCD1->CC::sleep(); objCD1->CC::CA::sleep(); // // CC 是继承并重写的 sleep()，也能走到 CA objCD1->CB::nAge = 10; //objCD1->CA::nAge = 11; // 这样还会报错 objCD1->CC::nAge = 12; // 同一个变量，存在多个副本，就好像一个人有两个年龄一样，这不合理 // 使用虚基类解决此问题 virtual // class CB :public virtual CA // class CC :public virtual CA // 可以把 virtual 关键字去掉看看效果 cout CB::nAge CC::nAge 调用了 CA 的构造函数 CA() 调用了 CB 的构造函数 CB() 调用了 CA 的构造函数 CA() 调用了 CC 的构造函数 CC() 调用了 CD 的构造函数 CD() 调用了 CC 重写的成员函数 go() 调用了 CB 重写的成员函数 go() 调用了 CA 的成员函数 sleep() 调用了 CC 的成员函数 sleep() 调用了 CA 的成员函数 sleep() 10 12 请按任意键继续. . . ---------- 调用了 CA 的构造函数 CA() 调用了 CB 的构造函数 CB() 调用了 CC 的构造函数 CC() 调用了 CD 的构造函数 CD() 调用了 CC 重写的成员函数 go() 调用了 CB 重写的成员函数 go() 调用了 CA 的成员函数 sleep() 调用了 CC 的成员函数 sleep() 调用了 CA 的成员函数 sleep() 12 12 请按任意键继续. . . Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:56 "},"C++ 基础/CPP - 04 多态.html":{"url":"C++ 基础/CPP - 04 多态.html","title":"CPP - 04 多态","keywords":"","body":"多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 C++ 多态 | 菜鸟教程 (runoob.com) 静态多态 静态多态：（早绑定 | 静态联编），编译时就确定了函数地址 #include using namespace std; class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } int area() { cout area(); // 存储三角形的地址 shape = &tri; // 调用三角形的求面积函数 area shape->area(); system(\"pause\"); return 0; } D:\\CPP_Project\\CppTest\\cmake-build-debug\\CppTest.exe Parent class area : Parent class area : 请按任意键继续. . . 调用函数 area()​​ 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area()​​ 函数在程序编译期间就已经设置好了。 #include using namespace std; class Animal { public: virtual void go() { cout 动态多态（虚函数） 动态多态：（晚绑定 | 动态联编），运行时才确定了函数地址 #include using namespace std; class Animal { public: virtual void go() { // 声明为虚函数 cout 虚函数 在 Shape 类中，area()​​ 的声明前放置关键字 virtual​​ 此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area()​​ 函数。 正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。 虚函数 是在基类中使用关键字 virtual​​ 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为​动态链接​，或​后期绑定​。 纯虚函数 若想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 // pure virtual function virtual int area() = 0; ​= 0​​​ 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。没有具体的实现，即使给出了纯虚函数的实现也会被编译器忽略。抽象类中至少存在一个纯虚函数，存在纯虚函数的类一定是抽象类。 若子类不重写实现父类的纯虚函数，子类本身也会变成抽象类，不能实例化。 虚表（虚函数表） 内存中的大小端序怎么区分（现在基本都是小端的，反着来算就行。） Visual Studio Debug 模式下，未初始化的变量值为 0xCCCCCCCC​，即：-858983460​ 为什么虚表指针（__vfptr​）被定义成一个指向指针数组的指针，而不是直接定义成一个指针数组呢?因为如果仅是一个指针的情况，就无法轻易地修改那个数组里面的内容，因为它并不属于类对象的一部分。属于类对象的，仅是一个指向虚函数表的一个指针 __vfptr​ 而已。【所以多个虚函数并不会影响类的大小及布局，增加一个虚函数，只是简单地向该类对应的虚函数表中增加一项而已，并不会影响到类对象的大小以及布局情况】 类型为 void *​，CPPTest1.exe!Cat::go(void)}​ 如果对 WinDbg​ 比较熟悉，那么应该知道这是一种惯用表示手法，这就是指 Cat::go(void)​ 函数的地址。伪代码大概如下： void* __fun[1] = { &Cat::go }; const void** __vfptr = &__fun[0]; 虚函数指针 __vfptr​ 位于所有的成员变量之前定义。 同一个类的不同实例共用同一份虚函数表。 那么问题就来了！这个虚函数表保存在哪里呢？其实，我们无需过分追究她位于哪里，重点是： 它是编译器在编译时期为我们创建好的，只存在一份 定义类对象时，编译器自动将类对象的 __vfptr​ 指向这个虚函数表 虚表示意图 ​ 单继承且只有父类有虚函数 #include using namespace std; class Animal { public: virtual void go() { // 声明为虚函数 cout go(); system(\"pause\"); return 0; } ​ 使用指针直接调用 #include using namespace std; class Animal { public: virtual void go() { // 声明为虚函数 cout go(); /* 1. 先将 Animal * 强转为 int * 类型：(int *)obj 2. 取出对象指针中的头 4 个字节，因为已经强转为 int * 型了，所以取该地址的值就是取 4 字节的内存，即 *(int *)obj 就是 vfptr 3. 再取虚函数表的 [0] 的地址，就可以直接调用该虚函数 4. 定义一个函数指针，进行调用 */ typedef void(*MyGo) (); MyGo goObj = (MyGo)*(int *)(*(int *)obj); goObj(); //printf(\"0x%04X\\r\\n\", *(int *)obj); // vfptr //printf(\"0x%X\\r\\n\", *(int *)*(int *)obj); // 将地址转换为 int * 指针然后再取值 system(\"pause\"); return 0; } 虚表 Hook 修改函数 Demo C++ 的 __vftable​​ 内存属性是不可写的 我们可以用过 Windows API VirtualProtect​​ 来进行修改权限 一般情况下内存权限可以分为以下几种情况 0 不可访问 1 执行权限 EXECUTE 2 读权限 READ 3 写权限 WRITE 需要包含头文件 #include​​ VirtualProtect function (memoryapi.h) - Win32 apps | Microsoft Learn 【搜索关键词小技巧：VirtualProtect msdn】 BOOL VirtualProtect( [in] LPVOID lpAddress, // 需要 hook 函数的地址 [in] SIZE_T dwSize, // 要更改其访问保护属性的区域的大小，以字节为单位 [in] DWORD flNewProtect, // 修改权限 [out] PDWORD lpflOldProtect // 保存原来的权限用于恢复 ); #include #include using namespace std; class Animal { public: virtual void go() { // 声明为虚函数 cout go(); int nVfptr = *(int *)obj; DWORD dwOldProtect = 0; BOOL bFlag = VirtualProtect((void *)nVfptr, 0x1000, PAGE_EXECUTE_READWRITE, &dwOldProtect); if (bFlag) { *(int *)nVfptr = (int)HookTest; // 函数名就是函数地址 obj->go(); } system(\"pause\"); return 0; } 父类接收子类对象直接析构会出错 #include #include using namespace std; class Animal { public: Animal() { cout go(); delete obj;// 直接 delete 程序会崩溃，需要将基类的析构函数声明为虚析构 system(\"pause\"); return 0; } 如果基类的析构函数不是虚函数，那么将不会调用子类的析构函数，导致内存出错~ Animal 的无参构造函数被调用 Cat 的无参构造函数被调用 Animal 的析构函数被调用 请按任意键继续. . . 纯虚析构 友元 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend​，如下所示： #include using namespace std; class Box { double width; public: friend void printWidth(Box box); // 声明友元函数 friend class BigBox; // 声明友元类 void setWidth(double wid); }; class BigBox { public : void Print(int width, Box &box) { // BigBox 是 Box 的友元类，它可以直接访问 Box 类的任何成员 box.setWidth(width); cout 因为友元函数没有 this​ 指针，则参数要有三种情况： 访问非 static​ 成员时，需要对象做参数 访问 static​ 成员或全局变量时，则不需要对象做参数 如果做参数的对象是全局对象，则不需要对象做参数 可以直接调用友元函数，不需要通过对象或指针 抽象类和接口 要想了解抽象类先看一下抽象方法，抽象方法是一个特殊的方法，只有声明没有具体的实现。抽象方法用 abstract​ 关键字修饰。有抽象方法的类就就是抽象类，抽象类也有 abstract​ 关键字修饰。 -- Java 抽象类（CPP） 可以看做是事物的抽象 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 \"= 0​\" 来指定的 抽象类的存在就是为了继承，所以不能用 private、static、final​ 关键字修饰的来修饰抽象方法 包含抽象方法的类叫做抽象类，但并不是抽象类里只有抽象方法 子类继承了抽象类必须实现父类的抽象方法，如果没有实现，那么子类也将会是抽象类 抽象类是不能定义对象的，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为保护的访问控制权限。 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。 纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现，这就像 Java 的接口一样。 带纯虚函数的类叫​==虚基类==，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。 抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract​ 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。 接口 可以看做是行为的抽象，一种行为规范。 抽象类是一个类，而接口不是类。 接口用关键字 interface​ 来实现，接口指的是调用别人的方法或者函数。接口可以看出 java 是一种对行为的抽象。接口需要注意的是： 接口中可以有变量和方法，并且接口中的变量会被隐式的被 public static final​​ 来修饰（并且只能用 public static final​​ 来修饰），方法会隐式的被 public abstract​​ 来修饰，并且只能用来 public abstract​​ 来修饰。也就是说接口中所有的方法不能有实现方法，也就是说接口中的方法都是抽象方法。 前人栽树 虚函数 | Microsoft Learn C++ 虚函数表 vfptr_蜗牛一步一步往上爬的博客-CSDN博客_vfptr ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:56 "},"C++ 基础/CPP - 05 探索类对象模型（一）.html":{"url":"C++ 基础/CPP - 05 探索类对象模型（一）.html","title":"CPP - 05 探索类对象模型（一）","keywords":"","body":"类空间 如果是一个空类（不含任何成员），那么他的对象占 1 字节【总要有一个空间表示这个对象嘛~】 类也需要和结构体一样也需要对齐 类对象空间里存储了成员变量（静态变量除外） 成员方法属于类，不占用对类对象的空间 派生类自身的大小是 8，以为基类有虚函数，派生类重写了虚函数，那么对象的头 4 字节就是虚表指针【该指针在 x86 下，占 4 字节】 类成员变量位于虚表指针后面开始 ==指针的长度是根据当前所在进程决定的，x86 占 4 字节，x64 占 8 字节。== #include using namespace std; class Animal { public: char cValue; int nValue1; static int nValue2; // 静态变量属于类，不属于对象 public: /*Animal() { cout #include using namespace std; class Animal { public: Animal() { cout 派生类继承 如果派生类是单继承，那么派生类的对象和基类对象地址一致，指向同一空间 如果派生类是多继承，那么派生类的对象和最左侧继承的基类对象地址一致【即第一个继承的~】 那么为什么地址相差是 4 呢？因为 CA 的大小是 4 字节。 基类 CB 的对象是位于派生类（基类 CA）对象地址 + 基类 CA 的空间大小 派生类自己的成员位于两个基类的空间之后 调用任意基类的继承函数时，this​ 指针会自动调整回自己的类的对象空间内，CA 之所以和 CC 是一样的，实际原因是因为 CC 指向了对象头【CC 包含了 CA、CB（两个基类的内容）】 派生类重写基类函数后，调用的就是自己空间内的函数了，因此 this​ 指针不会再调整到基类的对象中。【可以看到 this 指针函数地址一致了】 #include using namespace std; class CA { public: int a; public: CA() { printf(\"CA::CA():%p\\r\\n\", this); } ~CA() {} void goA() { printf(\"CA::goA:%p\\r\\n\", this); } }; class CB { public: int b; public: CB() { printf(\"CB::CB():%p\\r\\n\", this); } ~CB() {} void goB() { printf(\"CB::goB:%p\\r\\n\", this); } }; class CC : public CA, public CB{ public: int c; public: CC() { printf(\"CC::CC():%p\\r\\n\", this); }; ~CC() {}; void goC() { printf(\"CC::goC:%p\\r\\n\", this); } void goB() { printf(\"CC::goB:%p\\r\\n\", this); } }; // 程序的主函数 int main() { cout 4 4 12 CA::CA():004FF820 CB::CB():004FF824 CC::CC():004FF820 CA::go:004FF820 CB::go:004FF824 CC::go:004FF820 请按任意键继续. . . ---------- 4 4 12 CA::CA():00F7F9A0 CB::CB():00F7F9A4 CC::CC():00F7F9A0 CA::goA:00F7F9A0 CC::goB:00F7F9A0 CC::goC:00F7F9A0 请按任意键继续. . . 构造函数 《深度探索 C++ 对象模型》 -- 侯捷（译） ​ 默认构造函数出现的时机 默认情况 #include using namespace std; class CA { public: int a; public: CA() { printf(\"CA::CA():%p\\r\\n\", this); } ~CA() {} }; class CB { public: int b; public: void testB() { printf(\"CB::testB()\\r\\n\"); } }; // 程序的主函数 int main() { CB objCb; system(\"pause\"); return 0; } ​ 默认构造函数在需要的情况下才会生成，否则不会，非必然的。 ​CB::CB() 前面讲过每个 CPP 文件都会编译生成一个中间文件 obj/o 打开 Visual Studio 2017 Developer Command Prompt v15.9.50 ********************************************************************** ** Visual Studio 2017 Developer Command Prompt v15.9.50 ** Copyright (c) 2017 Microsoft Corporation ********************************************************************** C:\\Tools\\Microsoft Visual Studio\\2017\\Enterprise>cd C:\\Users\\zha0cai\\source\\repos\\CPPTest1\\Debug C:\\Users\\zha0cai\\source\\repos\\CPPTest1\\Debug>dumpbin /ALL CPPTest1.obj > test.cpp 导出 CPPTest1.obj​ 文件并搜索，并不能找到 CB::CB​ 说明并没有产生默认构造函数 COFF（common object file format） 有内部类、继承 在 CB 中添加一个内部类 CA，重复上述步骤，可以搜索到 CB::CB​ ，证明生成了 CB::CB()​ 默认构造函数。 #include using namespace std; class CA { public: int a; public: CA() { printf(\"CA::CA():%p\\r\\n\", this); } ~CA() {} }; class CB { public: CA objCA; int b; public: void testB() { printf(\"CB::testB()\\r\\n\"); } }; // 程序的主函数 int main() { CB objCb; system(\"pause\"); return 0; } 有虚函数、虚基类 有虚函数就有虚函数表，对象的头四个字节指向虚函数表 编译器会给对象生产一个默认构造函数，并添加代码，使得前四个字节指向虚函数表 #include using namespace std; class CA { public: int a; public: CA() { printf(\"CA::CA():%p\\r\\n\", this); } ~CA() {} }; class CB { public: //CA objCA; int b; public: virtual void testB() { printf(\"CB::testB()\\r\\n\"); } }; // 程序的主函数 int main() { CB objCb; system(\"pause\"); return 0; } ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:56 "},"C++ 基础/CPP - 06 探索类对象模型（二）.html":{"url":"C++ 基础/CPP - 06 探索类对象模型（二）.html","title":"CPP - 06 探索类对象模型（二）","keywords":"","body":"拷贝构造 基础类型成员 \"拷贝构造\"1 拷贝构造函数也是必要时才会产生 基础数据类型，编译器可以进行一个简单的成员变量初始化，值复制，不需要合成拷贝构造函数【可以用上节课的方法进行搜索测试~】 #include using namespace std; class CA { public: int nCA; }; int main() { // 拷贝构造函数也是必要时才会产生 CA objCA1; objCA1.nCA = 11; CA objCA2 = objCA1; // 基础数据类型，编译器可以进行一个简单的成员变量初始化，值复制，不需要合成拷贝构造函数 cout 内部类成员 CA 仅有基础类型，递归，所以也没有拷贝构造函数 #include using namespace std; class CA { public: int nCA; }; class CB { public: CA objCA; int nCB; }; int main() { CB objCB1; objCB1.nCB = 11; objCB1.objCA.nCA = 12; CB objCB2 = objCB1; cout 写一个显示的拷贝构造 #include using namespace std; class CA { public: int nCA; public: CA() {}; CA(CA & obj) { cout 继承、虚函数、虚基类 都会触发拷贝构造函数 调用分析 堆 -- 动态分配的内存都在堆中 开辟内存是不需要调用构造函数的 #include using namespace std; class CA { public: int nCA; public: CA() { cout CA 的无参构造函数~ CA 的拷贝构造函数~ CA 的拷贝构造函数~ CA 的拷贝构造函数~ 请按任意键继续. . . 无返回的形参 #include using namespace std; class CA { public: int nCA; public: CA() { cout CA 的无参构造函数~ CA 的拷贝构造函数~ CA 的析构函数~ CA 的析构函数~ 请按任意键继续. . . 需要返回的形参 #include using namespace std; class CA { public: int nCA; public: CA() { cout CA 的无参构造函数~ CA 的拷贝构造函数~ CA 的析构函数~ 请按任意键继续. . . 匿名对象（没保留，赋值 =） #include using namespace std; class CA { public: int nCA; public: CA() { cout CA 的无参构造函数~ CA 的拷贝构造函数~ CA 的析构函数~ CATest~ CA 的析构函数~ 请按任意键继续. . . Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 13:41:21 "},"C++ 基础/CPP - 07 探索类对象模型（三）.html":{"url":"C++ 基础/CPP - 07 探索类对象模型（三）.html","title":"CPP - 07 探索类对象模型（三）","keywords":"","body":" 虚函数分析与总结 虚函数调用形式 虚函数不一定就是调用的虚表指针，得看调用形式。 直接使用类对象的时候是使用类里面的函数地址。 指针的时候才会去虚表里面寻址调用。 #include using namespace std; class CA { public: virtual void virtest() { cout : mov %rax,%rcx * 0x00007ff6f5551718 : call 0x7ff6f5553020 * 0x00007ff6f555171d : lea -0x28(%rbp),%rax * 0x00007ff6f5551721 : mov %rax,%rcx * 0x00007ff6f5551724 : call 0x7ff6f5553020 * 0x00007ff6f5551729 : lea -0x30(%rbp),%rax * 0x00007ff6f555172d : mov %rax,%rcx * 0x00007ff6f5551730 : call 0x7ff6f5553020 * * 可以看到，调用的是同一个地址 0x7ff6f5553020 */ obj1.virtest(); obj2.virtest(); obj3.virtest(); CA *pObj1 = new CA; CA *pObj2 = new CA; CA *pObj3 = new CA; pObj1->virtest(); pObj2->virtest(); pObj3->virtest(); system(\"pause\"); return 0; } 虚表寻址 指针长度问题 x86 占四字节，所以是 int *​ CA obj1; // 函数指针，void 可以指向任何类型 typedef void(*fn_vfptr) (); fn_vfptr fnVfptr = (fn_vfptr)*(int *)*(int *)(&obj1); fnVfptr(); x64 站 8 字节，所以使用的是 int64_t *​ 或者 long long​ CA obj1; // 函数指针，void 可以指向任何类型 typedef void(*fn_vfptr) (); fn_vfptr fnVfptr = (fn_vfptr)*(int64_t *)*(int64_t *)(&obj1); fnVfptr(); 虚表指针（__vfptr​）是在实例化的时候才会出现，而虚表在编译的时候就已经生成。 单继承 重写后虚表中的函数地址会发生覆盖 父类用子类对象赋值，依然调用父类的虚函数表。 是因为编译器会把子类中父类的部分切出来给父类，但是虚函数指针不会覆盖而是构造。 ​obj3.virtest();​ ​obj4.virtest();​ 使用的是类的东西，不会去虚表里面寻找【要指针才会找~】 81 #include using namespace std; class CA { public: virtual void virtest1() { cout ce 14 59 00 */ CA *obj1 = new CA; CB *obj2 = new CB; system(\"pause\"); return 0; } ​ #include using namespace std; class CA { public: virtual void virtest1() { cout CA virtest1 CA virtest2 CA virtest3 ---------- CA virtest1 CB virtest2 CA virtest3 多继承 以下代码有几个虚表指针？ 2 个 第一个继承的和子类对象指向同一地址 #include using namespace std; class CA { public: virtual void virtest1() { cout objB 地址：0x8FFB00 objA 地址：0x8FFB00 objN 地址：0x8FFB04 请按任意键继续. . . ​ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:58 "},"C++ 基础/CPP - 08 寄存器基础与函数调用约定.html":{"url":"C++ 基础/CPP - 08 寄存器基础与函数调用约定.html","title":"CPP - 08 寄存器基础与函数调用约定","keywords":"","body":"寄存器基础 概念 计算机常见架构：x86、arm、MIPS 等 触发器 ​ 寄存器 ​ 内存 ​ 8 位处理器雏形 ​ 16 位、32 位、64 位处理器 通用寄存器 8 位 AL BL CL DL AH BH CH DH 16 位（通用寄存器共有 8 个） AX -- 累加器 BX -- 基址寄存器 CX -- 计数寄存器 DX -- 数据寄存器，字的乘、除运算，间接的输入输出 BP -- 基址寄存器，基指针，存储器指针、存取堆栈的指针 SP -- 堆栈指针，堆栈的==栈顶指针== SI -- 变址寄存器，存储器指针、串指令中的==源==操作数指针（用来存放偏移） DI -- 变址寄存器，存储器指针、串指令中的==目的==操作数指针（用来存放偏移） 【段基址，实模式】 32 位（通用寄存器共有 8 个，和 16 一样，多了个 E） EAX EBX ECX EDX EBP ESP ESI EDI 【段选择子，保护模式，段描述符】 64 位 8 位寄存器在 16 位寄存器中，而 16 位寄存器在 32 位寄存器中。或者说：32 位寄存器中，取 0 到 15 位的部分组成 16 位寄存器，16 位寄存器对半分，成为 8 位寄存器。 数据寄存器（通用） 主要用来保存操作数和运算结果等信息，从而节省读取操作数所需要占用总线和访问存储器的时间。 32 位 CPU 有 4 个 32 位的通用寄存器 EAX、EBX、ECX、EDX。对于低 16 位的数据的存取，不会影响高 16 位的数据。 这些低 16 位的寄存器分别命名为：AX、BX、CX 和 DX，这和 16 位 CPU 的命名是一致的。 4 个 16 位寄存器又可分割成 8 个独立的 8 位寄存器（AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL）。 每个寄存器都有自己的名称，可独立存取。 在 16 位 CPU 中，AX、BX、CX 和 DX 不能作为基址和变址寄存器来存放存储单元的地址，但在 32 位 CPU 中，其 32 位寄存器 EAX、EBX、ECX 和 EDX 不仅可传送数据、暂存数据保存算数逻辑运算结果，而且也可作为指针寄存器。所以这些 32 位寄存器更具有通用性。 AH(8 位) AL(8 位) AX(16 位) (AX 和 AL 又称累加器，Accumulator) BH(8 位) BL(8 位) BX(16 位) (BX 又称基址寄存器,唯一作为存储器指针使用寄存器，Base Register) CH(8 位) CL(8 位) CX(16 位) (CX 用于字符串操作，控制循环的次数，CL 用于移位，Count Register) DH(8 位) DL(8 位) DX(16 位) (DX 一般用来做 32 位的乘除法时存放被除数或者保留余数，Data Register) 指针寄存器（通用，Pointer Register） 主要用于存放堆栈内存单元的偏移量，指针寄存器不可分割为 8 位寄存器。 SP -- 堆栈指针 (存放==栈顶==地址，Stack Pointer) BP -- 基址指针 (存放堆栈基址偏移，Base Pointer) 变址寄存器（通用，Index Register） 主要用于存放存储单元在段内的偏移量，变址寄存器不可分割为 8 位寄存器。 SI -- 变址寄存器，存储器指针、串指令中的==源==操作数指针（用来存放偏移） DI -- 变址寄存器，存储器指针、串指令中的==目的==操作数指针（用来存放偏移） 段寄存器（非通用） 段寄存器是根据内存分段的管理模式而设置的。内存单元的==物理地址==由段寄存器的值和一个偏移量组合而成，这样可以用两个较少位数的值组合成一个可访问的较大物理空间的内存地址。【物理地址 = 段寄存器的值 + 偏移量】 16 位：【段基址，实模式】 32 位：【段选择子，保护模式，段描述符】 实方式：前 4 个段寄存器 CS、DS、ES 和 SS 与 16 位 CPU 中所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为 \"段值：偏移量\"​ 的形式。为访问某内存端内的数据，必须使用该段寄存器和存储单元的偏移量。 保护方式：在此方式下，情况要复杂的多，装入段寄存器的不再是段值，而是称为 \"选择子（Selector）\"​ 的某个值。 16 位 ES -- 附加段寄存器 CS -- 代码段寄存器 SS -- 堆栈段寄存器 DS -- 数据段寄存器 32 位在 16 位的基础上增加两个 FS -- 附加段寄存器 GS -- 附加段寄存器 CS 为代码段寄存器【存段地址】，还有个与 CS 息息相关的寄存器叫 IP​​，为指令指针寄存器【存偏移地址】。 ​IP​​、EIP​​（Instruction Pointer）是存放下次将要执行的指令在代码段中的偏移量。 32 位中由于每个段的最大范围为 64K，所以，EIP 中的高 16 位肯定都为 0，此时，相当于只用其低 16 位的 IP 来反映程序中指令的执行次序。 控制寄存器（非通用） IP -- 指令指针，32 位就是 EIP FLAG -- 标志寄存器，32 位就是 EFlags 标志寄存器（非通用） 进位标志 CF （Carry Flag），记录运算时最高有效位产生的进位值。 奇偶标志 PF （Parity Flag），用来为机器中传送信息时可能产生的代码出错情况提供检验条件。当结果操作数中 1 的个数为偶数时置 1，否则置 0。 辅助进位标志 AF （Auxiliary Carry Flag），记录运算时第 3 位（半个字节）产生的进位值。 零标志 ZF （Zero Flag），运算结果为 0 时 ZF 位置 1，否则置 0。 符号标志 SF （Sign Flag），记录运算结果的符号。结果为负时置 1，否则置 0。 溢出标志 OF （Overflow Flag），在运算过程中，如操作数超出了机器可表示数的范围称为溢出。溢出时 OF 位置 1，否则置 0。 追踪标志 TF（Trap Flag），当追踪标志 TF 被置为 1 时，CPU 进入单步执行方式，即每执行一条指令，产生一个单步中断请求，这种方式主要用于程序的调试。指令系统中没有专门的指令来改变标志位 TF 的值。 中断允许标志 IF（Interrupt-enable Flag），中断允许标志 IF 是用来决定 CPU 是否响应 CPU 外部的可屏蔽中断发出的中断请求。但不管该标志位何值，CPU 都必须响应 CPU 外部的不可屏蔽中断所发出的中断请求，以及 CPU 内部产生的中断请求。 当 IF=1 时，CPU 可以响应 CPU 外部的可屏蔽中断发出的中断请求； 当 IF=0 时，CPU 不响应 CPU 外部的可屏蔽中断发出的中断请求。 CPU 的指令系统中也有专门的指令来改变标志位 IF 的值。 方向标志 DF（Direction Flag），方向标志 DF 用来决定在串操作指令执行时有关指针寄存器发生调整的方向。在微机的指令系统汇总，还提供了专门的指令来改变标志位 DF 的值。 32位 标志寄存器增加的标志位 ​I/O​ 特权标志 IOPL（I/O​ Privilege Level） I/O​ 特权标志用两位二进制来表示，也称为 I/O​ 特权级字段。该字段指定了要求执行 I/O​ 指令的特权级。如果当前的特权级别在数值上小于等于 IOPL 的值，那么，该 I/O​ 指令可执行，否则将发生一个保护异常。 嵌套任务标志 NT（Nested Task），嵌套任务标志 NT 用来控制中断返回指令 IRET 的执行。具体规定如下： 当 NT=0 时，用堆栈中保存的值恢复 EFLAGS、CS 和 EIP，执行常规的中断返回操 当 NT=1 时，通过任务转换实现中断返回 重启动标志 RF（Restart Flag），重启动标志 RF 用来控制是否接受调试故障。 RF=0 时，表示“接受”调试故障，否则拒绝。在成功执行完一条指令后，处理机把 RF 置为 0，当接受到一个非调试故障时，处理机就把它置为 1。 虚拟 8086 方式标志 VM（Virtual 8086 Mode） 如果该标志的值为 1，则表示处理机处于虚拟 8086 方式下的工作状态，否则，处理机处于一般保护方式下的工作状态。 64 位 CPU 寄存器 x86-64CPU 在向后兼容的同时，更主要的是注入了全新的特性，特别的：x86-64 有两种工作模式，32 位 OS 既可以跑在传统模式中，把 CPU 当成 i386 来用；又可以跑在 64 位的兼容模式中，更加神奇的是，可以在 32 位的 OS 上跑 64 位的应用程序。 x86-64 中，所有的寄存器都是 64 位，相对 32 位的 x86 来说，标识符发生了变化，比如：从原来的 ebp 变成了 rbp。为了向后兼容，ebp 依然可以使用，不过指向了 rbp 的低 32 位。 x86-64 寄存器的变化，不仅体现在位数上，更加体现在寄存器数量上。新增加寄存器 r8 到 r15。加上 x86 原有的 8 个，一共 16 个寄存器。寄存器集成在 CPU 上，存取速度比存储器快了好几个数量级，寄存器多了，gcc 就可以更多的寄存器，替换之前的存储器堆栈使用，从而大大提升性能。寄存器的用途一般都涉及到函数调用，x86-64 有 16 个 64 位寄存器，分别是： rax -- 作为函数返回值使用 rbx rcx rdx rsi rdi rbp rsp -- 栈指针寄存器，指向栈顶 r8 r9 r10 r11 r12 r13 r14 r15 rdi，rsi，rdx，rcx，r8，r9 用作函数参数，依次对应第 1 参数，第 2 参数。。。 rbx，rbp，r10，r11，r12，r13，14，r15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改。 8086 ​ 在 8086 启动或者复位(CPU 刚开始运作)后，CS = FFFFH, IP = 0000H​​，即最开始是从 CS = FFFFH​​ 开始读取指令的 函数调用约定 call 调用函数，call address。 push pop ret jmp 地址跳转，jmp address。 函数调用流程： # 调用 call address (如：12345) push stack 下一行的地址【入栈 EIP】 jmp 12345【jmp 到 call 的地址】 # 函数结束，返回 ret 【函数结束】 pop eip 【将调用前入栈的下一行的地址出栈】 jmp eip 【jmp 到该地址】 栈（相对较小） 局部变量 参数 返回地址 每个空间：地址:值​ ，如 16 位就是 2 字节地址，2 字节值。 虚拟内存 属于进程自己的 x86：32 根地址线，4 GB，只能用 3 GB，内核占 1 GB x64：64 根地址线，x64 CPU 限制了只提供 48 位可用，共 256 TB。 Windows 只能用 44 位，即 16 TB。 linux/windows 64位CPU内存限制_lionzl的博客-CSDN博客 1TB = 1024 GB = 2^40 bit 1GB = 1024 MB = 2^30 bit 1MB = 1024 KB = 2^20 bit 1KB = 1024 bit = 2^10 bit 2^10 = 1024 bit = 1KB 2^20 = 1024 KB = 1MB = 2^10 * 1024 bit 2^0 = 1 2^1 = 2 2^2 = 4 2^3 = 8 2^4 = 16 2^5 = 32 2^6 = 64 2^7 = 128 2^8 = 256 2^9 = 512 2^10 = 1024 调用约定 x86 _cdecl c/c++ 基本调用约定​​​，调用方平栈，不定参数的函数可以使用，参数通过堆栈传递。 _stdcall win32​​​，被调方平栈，不定参数的函数无法使用，参数默认全部通过堆栈传递。 1. 参数是从右往左传递的，也是放在堆栈中。 2. 函数的堆栈平衡操作是由被调用函数执行的。 3. 在函数名的前面用下划线修饰，在函数名的后面由 @ 来修饰并加上栈需要的字节数的空间（_sumExample@8）。 _fastcall32 被调方平栈，不定参数的函数无法使用，前两个参数放入(ECX​​​, EDX​​​)，剩下的参数压栈保存。 表明了参数应该放在寄存器中，而不是在栈中，VC 编译器采用调用约定传递参数时，最左边的两个不大于 4 个字节（DWORD）的参数分别放在 ecx 和 edx 寄存器。当寄存器用完的时候，其余参数仍然从右到左的顺序压入堆栈。像浮点值、远指针和 __int64 类型总是通过堆栈来传递的。 _thiscall 类函数传参使用​​ x64 _fastcall64 被调方平栈，不定参数的函数无法使用，前四个参数放入(RCX​​, RDX​​, R8​​, R9​​)，剩下的参数压栈保存。 System V：类 Linux 系统默认约定，前八个参数放入(RDI​,RSI​, RDX​, RCX​, R8​, R9​)，剩下的参数压栈保存。 当栈顶指针 esp 小于栈底指针 ebp 时，就形成了栈帧，栈帧中可以寻址的数据有局部变量，函数返回地址，函数参数等。不同的两次函数调用，所形成的栈帧也不相同，当由一个函数进入另一个函数时，就会针对调用的函数开辟出其所需的栈空间，形成此函数的独有栈帧，而当调用结束时，则清除掉它所使用的栈空间，关闭栈帧，该过程通俗的讲叫做栈平衡。而如果栈在使用结束后没有恢复或过度恢复，则会造成栈的上溢或下溢，给程序带来致命错误。-- https://www.cnblogs.com/LyShark/p/15901950.html 栈结构在内存中占用一段连续存储空间，通过 esp 与 ebp 这两个栈指针寄存器来保存当前栈起始地址与结束地址，每 4 个字节保存一个数据。 堆栈的操作都是对一个字进行操作的，所以参数都是 4 个字节的。 Win32 API函数绝大部分都是采用 __stdcall​​ 调用约定的。WINAPI 其实也只是 __stdcall​​ 的一个别名而已。 #include using namespace std; void test() { cout > (0EE103Ch) 00EE2568 push offset string \"test\" (0EE9B30h) 00EE256D mov eax,dword ptr [__imp_std::cout (0EED0D4h)] 00EE2572 push eax 00EE2573 call std::operator > (0EE11A9h) 00EE2578 add esp,8 00EE257B mov ecx,eax 00EE257D call dword ptr [__imp_std::basic_ostream >::operator test(); 009E25F1 call test (09E1208h) system(\"pause\"); 009E25F6 mov esi,esp 009E25F8 push offset string \"pause\" (09E9B38h) 009E25FD call dword ptr [__imp__system (09ED1CCh)] 009E2603 add esp,4 009E2606 cmp esi,esp 009E2608 call __RTC_CheckEsp (09E1294h) return 0; 009E260D xor eax,eax ---------- test(); 00EE25F1 call test (0EE1208h) system(\"pause\"); 00EE25F6【一会函数 return esp 寄存器地址里面存的就是这个地址】 mov esi,esp ​ 009E25F1 call test (09E1208h) ---------- 009E1208 jmp test (09E2540h) ---------- void test() { 009E2540 push ebp 009E2541 mov ebp,esp 009E2543 sub esp,0C0h 009E2549 push ebx 009E254A push esi 009E254B push edi 009E254C mov edi,ebp 009E254E xor ecx,ecx 009E2550 mov eax,0CCCCCCCCh 009E2555 rep stos dword ptr es:[edi] 009E2557 mov ecx,offset _80A111C0_CPPTest1@cpp (09EF066h) 009E255C call @__CheckForDebuggerJustMyCode@4 (09E1389h) cout > (09E103Ch) 009E2568 push offset string \"test\" (09E9B30h) 009E256D mov eax,dword ptr [__imp_std::cout (09ED0D4h)] 009E2572 push eax 009E2573 call std::operator > (09E11A9h) 009E2578 add esp,8 009E257B mov ecx,eax 009E257D call dword ptr [__imp_std::basic_ostream >::operator _cdecl 参数顺序问题 #include using namespace std; // 参数是从右往左传的 void _cdecl test(int nNumberA, int nNumberB) { cout test(0xFFFFFFFF, 0xEEEEEEEE); 006925F1 push 0EEEEEEEEh // 压栈 006925F6 push 0FFFFFFFFh 006925F8 call test (0691442h) 006925FD add esp,8 // 平栈 system(\"pause\"); 00692600 mov esi,esp 00692602 push offset string \"pause\" (0699B38h) 00692607 call dword ptr [__imp__system (069D1CCh)] 0069260D add esp,4 00692610 cmp esi,esp 00692612 call __RTC_CheckEsp (0691294h) return 0; 00692617 xor eax,eax ------ 压栈和平栈时 esp 的变化，为什么压栈是降低的？ ESP = 00B3F904 // esp 初始状态 006925F1 push 0EEEEEEEEh // 压栈 ESP = 00B3F900 006925F6 push 0FFFFFFFFh ESP = 00B3F8FC 006925F8 call test (0691442h) // 在主函数看来 esp 没变化，函数内自平衡 ESP = 00B3F8FC 006925FD add esp,8 // 平栈，主调函数负责栈平衡 ESP = 00B3F904 // esp 又恢复初始状态了~ // 为什么是平 8 x86 push 4 字节 x64 push 8 字节 1. 都是整字节压栈的 2. 若压进去的字节超出，就会造成缓冲区溢出漏洞 void _cdecl test(int nNumberA, int nNumberB) { 00692540 push ebp 00692541 mov ebp,esp 00692543 sub esp,0C0h 00692549 push ebx 0069254A push esi 0069254B push edi 0069254C mov edi,ebp 0069254E xor ecx,ecx 00692550 mov eax,0CCCCCCCCh 00692555 rep stos dword ptr es:[edi] 00692557 mov ecx,offset _80A111C0_CPPTest1@cpp (069F066h) 0069255C call @__CheckForDebuggerJustMyCode@4 (0691389h) cout > (069103Ch) 00692568 push offset string \"test\" (0699B30h) 0069256D mov eax,dword ptr [__imp_std::cout (069D0D4h)] 00692572 push eax 00692573 call std::operator > (06911A9h) 00692578 add esp,8 0069257B mov ecx,eax 0069257D call dword ptr [__imp_std::basic_ostream >::operator _stdcall #include #include using namespace std; int main() { // MessageBox(NULL, L\"zhaocai\", L\"__stdcall\", MB_OK); system(\"pause\"); return 0; } 对比上面的 _cdcel 的 test()​ 函数，可以看到 _stdcall 的 MessageBox()​ 函数并没有进行堆栈平衡的平栈操作。 MessageBox(NULL, L\"zhaocai\", L\"__stdcall\", MB_OK); 00F01831 mov esi,esp 00F01833 push 0 00F01835 push offset string L\"__stdcall\" (0F07CE8h) 00F0183A push offset string L\"zhaocai\" (0F07BE8h) 00F0183F push 0 00F01841 call dword ptr [__imp__MessageBoxW@16 (0F0B098h)] 00F01847 cmp esi,esp 00F01849 call __RTC_CheckEsp (0F0123Ah) system(\"pause\"); 00F0184E mov esi,esp 00F01850 push offset string \"pause\" (0F07B40h) 00F01855 call dword ptr [__imp__system (0F0B17Ch)] 00F0185B add esp,4 // 平栈 00F0185E cmp esi,esp 00F01860 call __RTC_CheckEsp (0F0123Ah) return 0; 00F01865 xor eax,eax _fastcall 32 位：前两位使用寄存器，edx，ecx 64 为：前四位使用寄存器，rcx，rdx，r8，r9 #include #include using namespace std; // 参数是从右往左传的，第 1，2 个参数会放到寄存器里面。 void _fastcall test(int nNumberA, int nNumberB, int nNumberC, int nNumberD) { cout test(0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC, 0xDDDDDDDD); 00F32601 push 0DDDDDDDDh 00F32606 push 0CCCCCCCCh 00F3260B mov edx,0BBBBBBBBh 00F32610 mov ecx,0AAAAAAAAh // 第 1，2 个参数直接放到了寄存器中 00F32615 call test (0F31172h) system(\"pause\"); 00F3261A mov esi,esp 00F3261C push offset string \"pause\" (0F39B38h) 00F32621 call dword ptr [__imp__system (0F3D1CCh)] 00F32627 add esp,4 00F3262A cmp esi,esp 00F3262C call __RTC_CheckEsp (0F31294h) return 0; 00F32631 xor eax,eax ---------- EAX = 00F3F0F2 EBX = 0065A000 ECX = AAAAAAAA // 参数 1 EDX = BBBBBBBB // 参数 2 ESI = 00F31023 EDI = 005EF968 EIP = 00F32540 ESP = 005EF890 EBP = 005EF968 EFL = 00000246 ---------- void _fastcall test(int nNumberA, int nNumberB, int nNumberC, int nNumberD) { 00F32540 push ebp 00F32541 mov ebp,esp 00F32543 sub esp,0D8h 00F32549 push ebx 00F3254A push esi 00F3254B push edi 00F3254C push ecx 00F3254D lea edi,[ebp-18h] 00F32550 mov ecx,6 00F32555 mov eax,0CCCCCCCCh 00F3255A rep stos dword ptr es:[edi] 00F3255C pop ecx 00F3255D mov dword ptr [nNumberB],edx //dword ptr [ebp-14h],edx，这里如果是 + 基本都是参数 00F32560 mov dword ptr [nNumberA],ecx //dword ptr [ebp-8],ecx， - 的话基本是局部变量 00F32563 mov ecx,offset _F1BB1F3A_CPPTest1@cpp (0F3F0F2h) 00F32568 call @__CheckForDebuggerJustMyCode@4 (0F31389h) _thiscall ​ecx,[ebp-0Ch]​ #include #include using namespace std; // _thiscall class Test { public: int a; public: int seta(int a) { this->a = a; return a; }; }; int main() { Test testObj; testObj.seta(888); system(\"pause\"); return 0; } testObj.seta(888); 009C215F push 378h 009C2164 lea ecx,[testObj] 009C2167 call Test::seta (09C143Dh) # 把显示符号名关掉，就是这样的表现形式： testObj.seta(888); 009C215F push 378h 009C2164 lea ecx,[ebp-0Ch] // 这就是将 obj 放到寄存器，然后传到类内作为 this 指针使用 009C2167 call 009C143D public: int seta(int a) { 009C1F00 push ebp 009C1F01 mov ebp,esp 009C1F03 sub esp,0CCh 009C1F09 push ebx 009C1F0A push esi 009C1F0B push edi 009C1F0C push ecx 009C1F0D lea edi,[ebp-0Ch] 009C1F10 mov ecx,3 009C1F15 mov eax,0CCCCCCCCh 009C1F1A rep stos dword ptr es:[edi] 009C1F1C pop ecx 009C1F1D mov dword ptr [ebp-8],ecx //dword ptr [this],ecx 009C1F20 mov ecx,9CF0F2h 009C1F25 call 009C1389 this->a = a; 009C1F2A mov eax,dword ptr [ebp-8] //eax,dword ptr [this] 009C1F2D mov ecx,dword ptr [ebp+8] //ecx,dword ptr [a] 009C1F30 mov dword ptr [eax],ecx return a; 009C1F32 mov eax,dword ptr [ebp+8] //eax,dword ptr [a] }; 前人栽树 梦回----32位CPU和64位CPU的通用寄存器 - 古I月 - 博客园 (cnblogs.com) 《C++反汇编与逆向分析技术揭秘》 参数传递和命名约定 | Microsoft Learn Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:58 "},"C++ 基础/CPP - 09 探索对象模型（四）.html":{"url":"C++ 基础/CPP - 09 探索对象模型（四）.html","title":"CPP - 09 探索对象模型（四）","keywords":"","body":" 数据语义学 作用域 就近原则，先定义原则 ​::​ 全局作用域 类内的 typedef 最好放到最前面，可以避免成员函数类型冲突。 #include #include using namespace std; typedef string zhaocai; class CA { public: void func1(zhaocai var); public: int nA; zhaocai var1; typedef int zhaocai; // func1(zhaocai var) 声明放到这之后就可以 zhaocai var2; // 就近原则 }; int main() { system(\"pause\"); return 0; } void CA::func1(zhaocai var) { } ​ 类成员存储 静态成员和普通成员的存储空间 #include #include using namespace std; class CA { public: int nA; int nB; int nC; static int nsA; static int nsB; static int nsC; }; int CA::nsA = 0; int CA::nsB = 0; int CA::nsC = 0; int main() { CA obj; cout 12 obj,nA： 0xB5F830 obj,nB： 0xB5F834 obj,nC： 0xB5F838 obj,nsA：0xBDC46C obj,nsB：0xBDC470 obj,nsC：0xBDC474 请按任意键继续. . . 使用 x32_dbg 打开，\"D:\\xxx\\VSProjects\\CPPTest1\\Debug\\CPPTest1.exe\" ​ 单继承 对象和父类子对象指向同一空间，先摆放父类成员变量，再摆放子类成员变量 // 可以看到在内存中是连续的 16 cb1Obj.nCA1: 0x4FF9D0 cb1Obj.nCA2: 0x4FF9D4 cb1Obj.nCB1: 0x4FF9D8 cb1Obj.nCB2: 0x4FF9DC 请按任意键继续. . . #include #include using namespace std; class CA { public: int nCA1; int nCA2; }; class CB : public CA { public: int nCB1; int nCB2; }; int main() { CB cb1Obj; cout 子类有虚函数，父类没有：子类的虚函数直接放在头部。 子类没有虚函数，父类有：父类的虚函数直接继承过来，放在头部。 子类有虚函数，父类也有虚函数：子类、父类共用虚表 #include #include using namespace std; class CA { public: int nCA1; int nCA2; virtual void test() { cout ​ 多继承 单多继承 #include #include using namespace std; class CA1 { public: int nCA11; int nCA12; virtual void test() { cout 0x00CFFE60 // obj 64 9b 4b 00 // CB 和 CA1 共用的虚表指针 aa aa aa aa bb bb bb bb 70 9b 4b 00 // CA2 的虚表指针 cc cc cc cc dd dd dd dd ee ee ee ee ff ff ff ff ​ 多-多继承 #include #include using namespace std; class CN { public: int nCN11; int nCN12; virtual void testCN() { cout 0x0133FCA4 // obj 4c 9c f0 00 // CB 和 CA1 的虚表指针 48 9d f0 00 // 因为虚基类的存在，空指针 aa aa aa aa // CA1 的成员变量 -- 第一个继承的类的成员 bb bb bb bb // CA1 的成员变量 3c 9d f0 00 // CA2 的虚表指针 50 9d f0 00 // 因为虚基类的存在，空指针 cc cc cc cc // CA2 的成员变量 -- 第二个继承的类的成员 dd dd dd dd // CA2 的成员变量 ee ee ee ee // CB 的成员变量 -- 本类的成员 ff ff ff ff // CB 的成员变量 44 9d f0 00 // CN 的虚表指针 -- 虚基类的成员 77 77 77 77 // CN 的成员变量 88 88 88 88 // CN 的成员变量 ​ CB 和第一个继承的 CA1 共用一个虚表 其余类独自一个虚表 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 13:54:27 "},"C++ 基础/CPP - 10 探索对象模型（五）.html":{"url":"C++ 基础/CPP - 10 探索对象模型（五）.html","title":"CPP - 10 探索对象模型（五）","keywords":"","body":" 函数与对象总结 成员函数和全局函数 cb1Obj.testCB(110); 00A8195F push 6Eh // 传递参数 00A81961 lea ecx,[cb1Obj] // thiscall 把对象用 ecx 传递，给类内用作 this 指针 00A81964 call CB::testCB (0A81497h) func(&cb1Obj, 110); 00A81969 push 6Eh // 传递参数 00A8196B lea eax,[cb1Obj] // 把对象地址取出放入 eax 寄存器 00A8196E push eax // 把 eax 压栈，作为参数 _cdecl 00A8196F call func (0A81492h) 00A81974 add esp,8 // 平栈 #include #include using namespace std; class CB { public: int nCB1; void testCB(int nNum) { nCB1 += nNum; } }; void func(CB *obj, int nNum) { obj->nCB1 += nNum; } int main() { CB cb1Obj; cb1Obj.testCB(110); func(&cb1Obj, 110); printf(\"cb1Obj.testCB: 0x%X\\r\\n\", &CB::testCB); printf(\"func: 0x%X\\r\\n\", func); system(\"pause\"); return 0; } 是否使用指针 使用指针可能会产生多态 #include #include using namespace std; class CB { public: int nCB1; virtual void testCB() { cout testCB(); system(\"pause\"); return 0; } 不会产生多态，因此没有必要去访问虚函数表，动态寻址，直接访问固定地址 cb1Obj.testCB(); 007B2527 lea ecx,[cb1Obj] // this 007B252A call CB::testCB (07B14C9h) ---------- 在可能会产生多态的情况下，使用虚表指针，需要在虚函数表里面查找函数地址进行调用 pCB->testCB(); 005A27BE mov eax,dword ptr [ebp-1Ch] 005A27C1 mov edx,dword ptr [eax] 005A27C3 mov esi,esp 005A27C5 mov ecx,dword ptr [ebp-1Ch] 005A27C8 mov eax,dword ptr [edx] 005A27CA call eax 005A27CC cmp esi,esp 005A27CE call 005A12F3 虚函数内调用虚函数 -- 隐式 this​ this 指针调用虚函数 -- 显示 this​ 类内 ::​ 作用域下调用虚函数 -- 类内函数的固定地址 静态成员函数【属于类，不属于对象】 -- 类内函数的固定地址，不管是否使用指针访问 `cb1Obj.testCB3(); 006E2797 call CB::testCB3 (06E14E7h)`​ pCB->testCB3(); 006E27DB call CB::testCB3 (06E14E7h)​ testCB2(); 00DA1EC3 mov eax,dword ptr [ebp-8] // ebp-8 == this 00DA1EC6 mov edx,dword ptr [eax] 00DA1EC8 mov esi,esp 00DA1ECA mov ecx,dword ptr [ebp-8] 00DA1ECD mov eax,dword ptr [edx+4] 00DA1ED0 call eax 00DA1ED2 cmp esi,esp 00DA1ED4 call 00DA12F3 this->testCB2(); 00DA1ED9 mov eax,dword ptr [ebp-8] 00DA1EDC mov edx,dword ptr [eax] 00DA1EDE mov esi,esp 00DA1EE0 mov ecx,dword ptr [ebp-8] 00DA1EE3 mov eax,dword ptr [edx+4] 00DA1EE6 call eax 00DA1EE8 cmp esi,esp 00DA1EEA call 00DA12F3 CB::testCB2(); 00DA1EEF mov ecx,dword ptr [ebp-8] 00DA1EF2 call 00DA14E2 #include #include using namespace std; class CB { public: int nCB1; virtual void testCB1() { cout testCB2(); CB::testCB2(); } virtual void testCB2() { cout testCB3(); system(\"pause\"); return 0; } 编译器 vcall #include #include using namespace std; class CB { public: int nCB1; virtual void testCB1() { printf(\"CB vir testCB1 this:0x%X\\r\\n\", this); } virtual void testCB2() { printf(\"CB vir testCB2 this:0x%X\\r\\n\", this); } static void testCB3() { printf(\"CB static testCB3\\r\\n\"); } }; int main() { CB* pCB = new CB; pCB->testCB1(); pCB->testCB2(); printf(\"CB vir testCB1 :0x%X\\r\\n\", &CB::testCB1); printf(\"CB vir testCB1 :0x%X\\r\\n\", &CB::testCB2); system(\"pause\"); return 0; } printf(\"CB vir testCB1 :0x%X\\r\\n\", &CB::testCB1); 00F41ABF push offset CB::`vcall'{0}' (0F414F6h) 00F41AC4 push offset string \"CB vir testCB1 :0x%X\\r\\n\" (0F49EDCh) 00F41AC9 call _printf (0F414ECh) 00F41ACE add esp,8 ---------- CB vir testCB1 this:0xBDFC60 CB vir testCB2 this:0xBDFC60 CB vir testCB1 :0xF414F6 CB vir testCB1 :0xF41500 请按任意键继续. . . 类的构造过程 单继承 地址都一样，因为共用空间。 #include #include using namespace std; class CA { public: CA() { printf(\"CA obj:0x%X\\r\\n\", this); } }; class CB : public CA{ public: CB() { printf(\"CB obj:0x%X\\r\\n\", this); } }; class CC : public CB{ public: CC() { printf(\"CC obj:0x%X\\r\\n\", this); } }; int main() { CC ccObj; system(\"pause\"); return 0; } CA obj:0x6FF743 CB obj:0x6FF743 CC obj:0x6FF743 请按任意键继续. . . 构造函数过程 CC ccObj; 00261A5F lea ecx,[ccObj] // 把对象地址作为 this 指针传入 ecx 中，传入类内 00261A62 call CC::CC (026150Fh) // 调用 CC 构造函数~ ---------- 0026150F jmp CC::CC (0261BF0h) // 跳转表 ---------- class CC : public CB{ public: CC() { 00261BF0 push ebp 00261BF1 mov ebp,esp 00261BF3 sub esp,0CCh 00261BF9 push ebx 00261BFA push esi 00261BFB push edi 00261BFC push ecx 00261BFD lea edi,[ebp-0Ch] 00261C00 mov ecx,3 00261C05 mov eax,0CCCCCCCCh 00261C0A rep stos dword ptr es:[edi] 00261C0C pop ecx 00261C0D mov dword ptr [this],ecx // 将 exc （对象地址）放入 this 指针（成员变量） 00261C10 mov ecx,offset _80A111C0_CPPTest1@cpp (026F0F2h) 00261C15 call @__CheckForDebuggerJustMyCode@4 (0261406h) 00261C1A mov ecx,dword ptr [this] // thiscall ecx 给 CB 一个自己的子对象 00261C1D call CB::CB (0261442h) // 调用 CB 的构造函数 printf(\"CC obj:0x%X\\r\\n\", this); 00261C22 mov eax,dword ptr [this] 00261C25 push eax 00261C26 push offset string \"CC obj:0x%X\\r\\n\" (0269EC0h) 00261C2B call _printf (02614ECh) 00261C30 add esp,8 } 00261C33 mov eax,dword ptr [this] 00261C36 pop edi 00261C37 pop esi 00261C38 pop ebx 00261C39 add esp,0CCh 00261C3F cmp ebp,esp 00261C41 call __RTC_CheckEsp (02612F3h) 00261C46 mov esp,ebp 00261C48 pop ebp 00261C49 ret ---------- 00261442 jmp CB::CB (0261FA0h) F11 跟进 CB，逻辑和结构基本与 CC 的一致 ---------- class CB : public CA{ public: CB() { 00261FA0 push ebp 00261FA1 mov ebp,esp 00261FA3 sub esp,0CCh 00261FA9 push ebx 00261FAA push esi 00261FAB push edi 00261FAC push ecx 00261FAD lea edi,[ebp-0Ch] 00261FB0 mov ecx,3 00261FB5 mov eax,0CCCCCCCCh 00261FBA rep stos dword ptr es:[edi] 00261FBC pop ecx 00261FBD mov dword ptr [this],ecx 00261FC0 mov ecx,offset _80A111C0_CPPTest1@cpp (026F0F2h) 00261FC5 call @__CheckForDebuggerJustMyCode@4 (0261406h) 00261FCA mov ecx,dword ptr [this] 00261FCD call CA::CA (026150Ah) // 调用 CA 的构造函数 ---------- 0026150A jmp CA::CA (0261B90h) ---------- class CA { public: CA() { 00261B90 push ebp 00261B91 mov ebp,esp 00261B93 sub esp,0CCh 00261B99 push ebx 00261B9A push esi 00261B9B push edi 00261B9C push ecx 00261B9D lea edi,[ebp-0Ch] 00261BA0 mov ecx,3 00261BA5 mov eax,0CCCCCCCCh 00261BAA rep stos dword ptr es:[edi] 00261BAC pop ecx 00261BAD mov dword ptr [this],ecx 00261BB0 mov ecx,offset _80A111C0_CPPTest1@cpp (026F0F2h) 00261BB5 call @__CheckForDebuggerJustMyCode@4 (0261406h) printf(\"CA obj:0x%X\\r\\n\", this); 00261BBA mov eax,dword ptr [this] 00261BBD push eax 00261BBE push offset string \"CA obj:0x%X\\r\\n\" (0269B30h) 00261BC3 call _printf (02614ECh) 00261BC8 add esp,8 } 00261BCB mov eax,dword ptr [this] // 按照调用约定，eax、rax 都是返回值，所以将 this 指针放到 eax 进行返回 00261BCE pop edi 00261BCF pop esi 00261BD0 pop ebx 00261BD1 add esp,0CCh 00261BD7 cmp ebp,esp 00261BD9 call __RTC_CheckEsp (02612F3h) 00261BDE mov esp,ebp 00261BE0 pop ebp 00261BE1 ret // 返回到 CB 中 析构函数过程 #include #include using namespace std; class CA { public: CA() { printf(\"CA obj:0x%X\\r\\n\", this); } ~CA() { printf(\"CA~\\r\\n\"); } }; class CB : public CA{ public: CB() { printf(\"CB obj:0x%X\\r\\n\", this); } ~CB() { printf(\"CB~\\r\\n\"); } }; class CC : public CB{ public: CC() { printf(\"CC obj:0x%X\\r\\n\", this); } ~CC() { printf(\"CC~\\r\\n\"); } }; int main() { CC *ccObj = new CC; delete ccObj; system(\"pause\"); return 0; } delete ccObj; 00CB1DAD mov eax,dword ptr [ccObj] 00CB1DB0 mov dword ptr [ebp-0F8h],eax 00CB1DB6 cmp dword ptr [ebp-0F8h],0 00CB1DBD je __$EncStackInitStart+0AAh (0CB1DD4h) 00CB1DBF push 1 00CB1DC1 mov ecx,dword ptr [ebp-0F8h] 00CB1DC7 call CC::`scalar deleting destructor' (0CB1523h) // 调用 CC 的析构函数 00CB1DCC mov dword ptr [ebp-100h],eax 00CB1DD2 jmp __$EncStackInitStart+0B4h (0CB1DDEh) 00CB1DD4 mov dword ptr [ebp-100h],0 ---------- 00CB1523 jmp CC::`scalar deleting destructor' // 从跳转表，跳转到 CC 的析构函数中 ---------- CPPTest1.exe!CC::`scalar deleting destructor'(unsigned int): 00CB2390 push ebp 00CB2391 mov ebp,esp 00CB2393 sub esp,0CCh 00CB2399 push ebx 00CB239A push esi 00CB239B push edi 00CB239C push ecx 00CB239D lea edi,[ebp-0Ch] 00CB23A0 mov ecx,3 00CB23A5 mov eax,0CCCCCCCCh 00CB23AA rep stos dword ptr es:[edi] 00CB23AC pop ecx 00CB23AD mov dword ptr [this],ecx 00CB23B0 mov ecx,dword ptr [this] 00CB23B3 call CC::~CC (0CB1514h) // 调用 CC 的析构函数 00CB23B8 mov eax,dword ptr [ebp+8] 00CB23BB and eax,1 00CB23BE je __$EncStackInitStart+31h (0CB23CEh) 00CB23C0 push 1 00CB23C2 mov eax,dword ptr [this] 00CB23C5 push eax 00CB23C6 call operator delete (0CB10A0h) 00CB23CB add esp,8 00CB23CE mov eax,dword ptr [this] 00CB23D1 pop edi 00CB23D2 pop esi 00CB23D3 pop ebx 00CB23D4 add esp,0CCh 00CB23DA cmp ebp,esp 00CB23DC call __RTC_CheckEsp (0CB12F3h) 00CB23E1 mov esp,ebp 00CB23E3 pop ebp ---------- 00CB150A jmp CA::CA (0CB1B90h) 00CB150F jmp CC::CC (0CB1BF0h) 00CB1514 jmp CC::~CC (0CB22A0h) 00CB1519 jmp CA::~CA (0CB2070h) 00CB151E jmp CB::~CB (0CB2130h) 00CB1523 jmp CC::`scalar deleting destructor' (0CB2390h) ---------- ~CC() { 00CB22A0 push ebp 00CB22A1 mov ebp,esp 00CB22A3 sub esp,0CCh 00CB22A9 push ebx 00CB22AA push esi 00CB22AB push edi 00CB22AC push ecx 00CB22AD lea edi,[ebp-0Ch] 00CB22B0 mov ecx,3 00CB22B5 mov eax,0CCCCCCCCh 00CB22BA rep stos dword ptr es:[edi] 00CB22BC pop ecx 00CB22BD mov dword ptr [this],ecx // 执行 CC 的析构函数 00CB22C0 mov ecx,offset _80A111C0_CPPTest1@cpp (0CBF0F2h) 00CB22C5 call @__CheckForDebuggerJustMyCode@4 (0CB1406h) printf(\"CA~\\r\\n\"); 00CB22CA push offset string \"CC~\\r\\n\" (0CB9D70h) 00CB22CF call _printf (0CB14ECh) 00CB22D4 add esp,4 } 00CB22D7 mov ecx,dword ptr [this] // 将 this 指针放到 ecx 中 00CB22DA call CB::~CB (0CB151Eh) // 调用 CB 的析构函数 00CB22DF pop edi 00CB22E0 pop esi 00CB22E1 pop ebx 00CB22E2 add esp,0CCh 00CB22E8 cmp ebp,esp 00CB22EA call __RTC_CheckEsp (0CB12F3h) 00CB22EF mov esp,ebp 00CB22F1 pop ebp 00CB22F2 ret ---------- 进入到 CB 的析构函数 ~CB() { 00152130 push ebp 00152131 mov ebp,esp 00152133 sub esp,0CCh 00152139 push ebx 0015213A push esi 0015213B push edi 0015213C push ecx 0015213D lea edi,[ebp-0Ch] 00152140 mov ecx,3 00152145 mov eax,0CCCCCCCCh 0015214A rep stos dword ptr es:[edi] 0015214C pop ecx 0015214D mov dword ptr [this],ecx // 执行 CB 的析构函数 00152150 mov ecx,offset _80A111C0_CPPTest1@cpp (015F0F2h) 00152155 call @__CheckForDebuggerJustMyCode@4 (0151406h) printf(\"CB~\\r\\n\"); 0015215A push offset string \"CB~\\r\\n\" (0159EDCh) 0015215F call _printf (01514ECh) 00152164 add esp,4 } 00152167 mov ecx,dword ptr [this] 0015216A call CA::~CA (0151519h) // 调用 CA 的析构函数 0015216F pop edi 00152170 pop esi 00152171 pop ebx 00152172 add esp,0CCh 00152178 cmp ebp,esp 0015217A call __RTC_CheckEsp (01512F3h) 0015217F mov esp,ebp 00152181 pop ebp 00152182 ret // 返回到 CC 的析构函数中 ---------- 进入到 CA 的析构函数 ~CA() { 00152070 push ebp 00152071 mov ebp,esp 00152073 sub esp,0CCh 00152079 push ebx 0015207A push esi 0015207B push edi 0015207C push ecx 0015207D lea edi,[ebp-0Ch] 00152080 mov ecx,3 00152085 mov eax,0CCCCCCCCh 0015208A rep stos dword ptr es:[edi] 0015208C pop ecx 0015208D mov dword ptr [this],ecx // 执行 CA 的析构函数 00152090 mov ecx,offset _80A111C0_CPPTest1@cpp (015F0F2h) 00152095 call @__CheckForDebuggerJustMyCode@4 (0151406h) printf(\"CA~\\r\\n\"); 0015209A push offset string \"CA~\\r\\n\" (0159D70h) 0015209F call _printf (01514ECh) 001520A4 add esp,4 // 平栈返回~ } 001520A7 pop edi 001520A8 pop esi 001520A9 pop ebx 001520AA add esp,0CCh 001520B0 cmp ebp,esp 001520B2 call __RTC_CheckEsp (01512F3h) 001520B7 mov esp,ebp 001520B9 pop ebp 001520BA ret // 返回到 CB 的析构函数中 CA obj:0x95BFD8 CB obj:0x95BFD8 CC obj:0x95BFD8 CC~ CB~ CA~ 请按任意键继续. . . new 构造 重载的 new 关键字先进行 malloc 开辟空间，返回缓冲区指针 再调用类固定地址的构造函数 #include #include using namespace std; class CA { public: CA() { printf(\"CA obj:0x%X\\r\\n\", this); } ~CA() { printf(\"CA~\\r\\n\"); } }; class CB : public CA{ public: CB() { printf(\"CB obj:0x%X\\r\\n\", this); } ~CB() { printf(\"CB~\\r\\n\"); } }; class CC : public CB{ public: CC() { printf(\"CC obj:0x%X\\r\\n\", this); } ~CC() { printf(\"CC~\\r\\n\"); } }; int main() { CC *ccObj = new CC; delete ccObj; system(\"pause\"); return 0; } new 反汇编 CC *ccObj = new CC; 00151D54 push 1 // 空对象的大小就是 1 00151D56 call operator new (0151140h) // 可以看到 new 关键字是通过 operator 重载而来的，F11 跟进 00151D5B add esp,4 00151D5E mov dword ptr [ebp-0ECh],eax 00151D64 mov dword ptr [ebp-4],0 00151D6B cmp dword ptr [ebp-0ECh],0 00151D72 je __$EncStackInitStart+5Dh (0151D87h) 00151D74 mov ecx,dword ptr [ebp-0ECh] 00151D7A call CC::CC (015150Fh) // 调用固定地址的类构造函数 ---------- 重载的 new 的跳转表 00151140 jmp operator new (01528E0h) ---------- new 函数源码 _CRT_SECURITYCRITICAL_ATTRIBUTE void* __CRTDECL operator new(size_t const size) { 001528E0 push ebp 001528E1 mov ebp,esp 001528E3 push ecx for (;;) { if (void* const block = malloc(size)) 001528E4 mov eax,dword ptr [size] 001528E7 push eax 001528E8 call _malloc (0151069h) // 可以看到 new 也是通过 malloc 分配内存空间的 001528ED add esp,4 001528F0 mov dword ptr [ebp-4],eax 001528F3 cmp dword ptr [ebp-4],0 001528F7 je operator new+1Eh (01528FEh) { return block; 001528F9 mov eax,dword ptr [ebp-4] 001528FC jmp operator new+42h (0152922h) } if (_callnewh(size) == 0) 001528FE mov ecx,dword ptr [size] 00152901 push ecx 00152902 call __callnewh (01512B7h) 00152907 add esp,4 0015290A test eax,eax 0015290C jne operator new+40h (0152920h) { if (size == SIZE_MAX) 0015290E cmp dword ptr [size],0FFFFFFFFh 00152912 jne operator new+3Bh (015291Bh) { __scrt_throw_std_bad_array_new_length(); 00152914 call __scrt_throw_std_bad_array_new_length (01514ABh) } 00152919 jmp operator new+40h (0152920h) else { __scrt_throw_std_bad_alloc(); 0015291B call __scrt_throw_std_bad_alloc (015113Bh) } } // The new handler was successful; try to allocate again... } 00152920 jmp operator new+4h (01528E4h) } 00152922 mov esp,ebp 00152924 pop ebp 00152925 ret malloc 实现 new CC* ccObj2 = (CC *)malloc(sizeof(CC)); // 只是开辟了空间，并没有调用 CC 的构造函数 ccObj2->CC::CC(); // 需要手动的调用一下 CC 的构造函数 CC* ccObj2 = (CC *)malloc(sizeof(CC)); 007B2095 mov esi,esp 007B2097 push 4 007B2099 call dword ptr [__imp__malloc (07BD1D0h)] // 开辟空间 007B209F add esp,4 007B20A2 cmp esi,esp 007B20A4 call __RTC_CheckEsp (07B12F3h) 007B20A9 mov dword ptr [ccObj2],eax ---------- 手动调用 CC 的构造函数 ccObj2->CC::CC(); 00321C2C mov ecx,dword ptr [ccObj2] 00321C2F call CC::CC (032154Bh) ​ delete 析构 先调用析构函数 再调用 free 释放内存 00A7219E call CC::`scalar deleting destructor' (0A7155Ah) ---------- jmp 00A7155A jmp CC::`scalar deleting destructor' (0A71E20h) ---------- CPPTest1.exe!CC::`scalar deleting destructor'(unsigned int): 00A71E20 push ebp 00A71E21 mov ebp,esp 00A71E23 sub esp,0CCh 00A71E29 push ebx 00A71E2A push esi 00A71E2B push edi 00A71E2C push ecx 00A71E2D lea edi,[ebp-0Ch] 00A71E30 mov ecx,3 00A71E35 mov eax,0CCCCCCCCh 00A71E3A rep stos dword ptr es:[edi] 00A71E3C pop ecx 00A71E3D mov dword ptr [this],ecx 00A71E40 mov ecx,dword ptr [this] 00A71E43 call CC::~CC (0A71550h) // 先调用 CC 的析构函数 00A71E48 mov eax,dword ptr [ebp+8] 00A71E4B and eax,1 00A71E4E je __$EncStackInitStart+31h (0A71E5Eh) 00A71E50 push 4 00A71E52 mov eax,dword ptr [this] 00A71E55 push eax 00A71E56 call operator delete (0A710A0h) // 再调用重载的 delete 00A71E5B add esp,8 00A71E5E mov eax,dword ptr [this] 00A71E61 pop edi 00A71E62 pop esi 00A71E63 pop ebx 00A71E64 add esp,0CCh 00A71E6A cmp ebp,esp 00A71E6C call __RTC_CheckEsp (0A712F3h) 00A71E71 mov esp,ebp 00A71E73 pop ebp ---------- 00A710A0 jmp operator delete (0A741E0h) ---------- _CRT_SECURITYCRITICAL_ATTRIBUTE void __CRTDECL operator delete(void* const block, size_t const) noexcept { 00A741E0 push ebp 00A741E1 mov ebp,esp operator delete(block); 00A741E3 mov eax,dword ptr [block] 00A741E6 push eax 00A741E7 call operator delete (0A710D7h) 00A741EC add esp,4 } 00A741EF pop ebp 00A741F0 ret delete 源码 _CRT_SECURITYCRITICAL_ATTRIBUTE void __CRTDECL operator delete(void* const block, size_t const) noexcept { 00E341E0 push ebp 00E341E1 mov ebp,esp operator delete(block); 00E341E3 mov eax,dword ptr [block] 00E341E6 push eax 00E341E7 call operator delete (0E310D7h) 00E341EC add esp,4 } 00E341EF pop ebp 00E341F0 ret free 实现 //delete ccObj2; ccObj2->~CC(); free(ccObj2); Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:58 "},"C++ 基础/CPP - 11 函数模板和类模板.html":{"url":"C++ 基础/CPP - 11 函数模板和类模板.html","title":"CPP - 11 函数模板和类模板","keywords":"","body":" 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 每个容器都有一个单一的定义，比如 ​向量​，我们可以定义许多不同类型的向量，比如 vector 或 ​vector ​。 您可以使用模板来定义函数和类。 函数模板 定义 存在与函数模板的同名函数，访问的时候需要加作用域 T 被替换成 int、double、string 等等，但是类型要一致，如返回值和参数 对实参进行强制类型转换 ​Add(10, static_cast255.5);​ 显式指定参数类型 ​Add(10, 255.5);​ 函数模板重载，重载后需要选一个参数的类型作为返回值 template ret-type func-name(parameter list) { // 函数的主体 // type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 } #include #include using namespace std; template T Add(T const& a, T const& b) { // 可以接收很多類型，如 int、double、string 等 return a + b; } // 函数模板重载 template T2 Add(T1 const& a, T2 const& b) { return a + b; } int main() { int i = 39; int j = 20; cout 非类型函数模板参数 非类型模板参看，顾名思义，模板参数不限定于类型，普通的数值（ Nontype Template Parameters）也可作为模板参数。 非类型模板参数可以是：参数列表，类型，普通类型【除了浮点型和类对象】。 它可以是常整数（包括enum枚举类型）或者指向外部链接对象的指针。 ​A.cpp​ 中如何引用 B.cpp​ 中的全局变量，在 A.hpp​ 中使用 extern​ 关键字对外部变量加以引用。 #include #include using namespace std; // 或者直接指定默认值 //template //Add(200) template T Add(T tValue) { return tValue + nNum; } int main() { int i = 39; cout (200) template // ERROR： 浮点数不可作为非类型模板参数 double process(double v) { return v * VAL; } template // ERROR：类对象不能作为非类型模板参数 class MyClass { } 改成指针可以通过编译 template double process(const double& x) { return x * (*PVAL); } template class MyClass { ... } // 使用 double val = 10; double res = process(20); // ERROR: 表达式必须含有常量值 MyClass x; // ERROR: 模板参数不能引用非外部实体 const char* s = \"hello\"; MyClass x; // ERROR: 表达式必须含有常量值 有一个问题，怎么查看 nNum 的值？ nNum 被定义为编译时确定的表达式常量，不能在运行时进行查看。 非类型模板参数在编译期间就已经实例化，所以其模板实参必须是常量表达式。 类模板（泛型） 定义 泛型编程 -- 主要解决代码复用问题 根据类型进行实例化 template class class-name { // type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。 } //e.g template class CA { public: void test(T tValue); } 如定义一个 Stack 类 #include #include #include #include #include using namespace std; template class Stack { private: vector elems; // 元素 public: void push(T const&); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const{ // 如果为空则返回真。 return elems.empty(); } }; template void Stack::push (T const& elem) { // 追加传入元素的副本 elems.push_back(elem); } template void Stack::pop () { if (elems.empty()) { throw out_of_range(\"Stack<>::pop(): empty stack\"); } // 删除最后一个元素 elems.pop_back(); } template T Stack::top () const { if (elems.empty()) { throw out_of_range(\"Stack<>::top(): empty stack\"); } // 返回最后一个元素的副本 return elems.back(); } int main() { try { Stack intStack; // int 类型的栈 Stack stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout 模板全特化 // 全特化 e.g template <> class CA { public: void test(std::string tValue); } 模板偏（局部）特化 #include #include using namespace std; // 主模板 template class CA { }; template class CA { public: int nNumA; int nNumB; CA(T a, T b):nNumA(a), nNumB(b) { cout obj(14, 14); system(\"pause\"); return 0; } 前人栽树 C++ 模板 | 菜鸟教程 (runoob.com) C++基础——非类型模板参数_五道口纳什的博客-CSDN博客 C++模板进阶操作 —— 非类型模板参数、模板的特化以及模板的分离编译2021dragon的博客-CSDN博客非类型模板 ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:58 "},"C++ 基础/CPP - 12 函数模板和类模板（总结）.html":{"url":"C++ 基础/CPP - 12 函数模板和类模板（总结）.html","title":"CPP - 12 函数模板和类模板（总结）","keywords":"","body":"模板类函数继承调用问题 this 指针显示调用 实例化后调用 模板没有实例化直接是没有意义的 严重性 代码 说明 项目 文件 行 禁止显示状态 错误 C3861 “TestCA”: 找不到标识符 CPPTest1 D:\\xxx\\VSProjects\\CPPTest1\\CPPTest1.cpp 20 ---------- #include #include using namespace std; // 主模板 template class CA { public: void TestCA() { cout class CB : public CA{ public: int nNumA; public: void TestCB() { //TestCA(); // 调用失败 this->TestCA(); // this 显示调用 CB::TestCA(); // 实例化显示调用 }; }; int main() { CB objCB; objCB.TestCB(); system(\"pause\"); return 0; } 模板的一些补充 typename 用来显示的指示后面的是类型 e.g：声明一个 ​T::SubType *​ 的指针 ptr typename T::SubType * ptr​ 如果没有 typename​ 关键字就变成了 T 作用域下 SubType 变量 * ptr 变量 零初始化 函数 #include #include using namespace std; template void tfunc() { T x = T(); // 模板函数零初始化 cout (); system(\"pause\"); return 0; } 类 #include #include using namespace std; template class CA { public: T x; CA():x() { // 模板成员参数初始化列表零初始化 cout obj; system(\"pause\"); return 0; } 引用类型不会转换指针 #include #include using namespace std; template T const & Max(T const tValue1, T const tValue2) { return tValue1 > tValue2 ? tValue1 : tValue2; } int main() { // 引用类型不会转化指针 // 非引用类型会从 char[] 转换成 char * 【类型退化】 // char[5] Max(\"test\", \"fail\"); // char[5] char[8] Max(\"test\", \"zhaocai\"); // T const & Max(T const tValue1, T const tValue2) 函数参数类型改成这个就可以通过 // char[5] string string szBuffer; Max(\"test\", szBuffer); // 这个类型不符始终无法通过 system(\"pause\"); return 0; } 模板分开在头文件和实现直接包含头文件不能使用，需要实例化 声明和实现都要放到头文件【即放到同一地方】 新的 C++ 标准可以使用 export​ 导出模板关键字 模板类的继承 C++14 后 -- 变量模板 #include using namespace std; template T tValue; // tValue 变量也可以任何类型了 int main() { tValue = 100; cout T tValue[count]; // tValue 变量也可以作为数组 for (int i=0; i[i] = i; // 一个 int 型的大小为 10 的数组 } 静态模板成员 template class CA { public: template static W st_Value; }; template template W CA::st_Value = 0; 可变参模板 #include #include using namespace std; void func() {} // 递归终止条件 template void func(T head, Types ... res) { cout (1, 2, 3, 4, 5, 6); system(\"pause\"); return 0; } 如果没有终止函数的话，因为可变参数 res...​ 是不断递减的 ​ 模版不支持在局部函数中声明定义或使用 自动类型推导，必须推导出一致的数据类型 T，才可以使用模板必须要确定出 T 的数据类型，才可以使用。 模板类本身未指定所使用的数据类型，不能单独编译模板类的实现。 只用在使用模板类的阶段，指定了模板中的数据类型，编译器才能正常编译。因此，在实际开发中，必须把实现全部写在头文件里面，把声明和实现分开的做法不可取。 在 C++ 中，在编译阶段才确定对象所占用的空间。模板类只有被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。然后根据套用的类型进行编译。套用不同类型的模板类实际上就是两个不同的类型，因此这两个类型的共同成员函数实质上也不是同一个函数，仅仅是具有相似的功能。因此，模板类在套用不同类型以后，会被编译出不同的代码。 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 13:51:47 "},"C++ 基础/CPP - 现代 C++ 基础（一）.html":{"url":"C++ 基础/CPP - 现代 C++ 基础（一）.html","title":"CPP - 现代 C++ 基础（一）","keywords":"","body":"​ 所谓现代 C++（即所谓的 Modern C++）指的是 C++11 及之后的版本，目前最新版本是 C++20，这期间一共有 C++11、C++14、C++17 三个版本。 变量 变量类型获取 typeid(变量名).name() 自动类型推导 int nNum1; decltype(nNum1) nNum2 = 0 // decltype(nNum1) 通过 nNum1 推导出类型，相当于 int 类型。decltype(nNum1) == int ---------- auto nNum3 = nNum2 // 也可以进行类型推导 nullptr nullptr​ 出现的目的是为了替代 NULL​。在某种意义上来说，传统 C++ 会把 NULL​、0​ 视为同一种东西，这取决于编译器如何定义 NULL​，有些编译器会将 NULL​ 定义为 ((void*)0)​，有些则会直接将其定义为 0​。 C++ 不允许直接将 void *​ 隐式转换到其他类型。但如果编译器尝试把 NULL​ 定义为 ((void*)0)​，那么在下面这句代码中： char *ch = NULL; 没有了 void *​ 隐式转换的 C++ 只好将 NULL​ 定义为 0​。而这依然会产生新的问题，将 NULL​ 定义成 0​ 将导致 C++​ 中重载特性发生混乱。 void foo(char*); void foo(int); 那么 foo(NULL);​ 这个语句将会去调用 foo(int)​，从而导致代码违反直觉。 ​nullptr​ 的类型为 nullptr_t​，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。 函数返回类型后置 auto test()->int { // 即 int test() {}, auto 仅仅是占位用 return 1213; } 结合函数指针使用 ​typedef 函数返回类型 (*指针变量)(参数类型，参数类型...)​ #include #include using namespace std; auto test1()->int { return 23333; } // typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 typedef int (*pfunc)(); auto test2()->int(*)() { // int(*)() 函数指针 return test1; // 返回一个函数指针，指向 test1 的 } int main() { cout 前人栽树 欢迎回到 C++ - 现代 C++ | Microsoft Learn https://github.com/changkun/modern-cpp-tutorial https://changkun.de/modern-cpp/ ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:58 "},"C++ 基础/CPP - 现代 C++ 基础（二）.html":{"url":"C++ 基础/CPP - 现代 C++ 基础（二）.html","title":"CPP - 现代 C++ 基础（二）","keywords":"","body":"引用变量 左值：一般情况下拥有特定内存，并且声明周期较长的称为左值。 右值：一般生命周期较短且临时存在的就称为右值。如：函数的运行结果或表达式中间变量。 左值可以放在赋值号 =​ 的左右两边，右值只能放在赋值号 =​ 的右边。 变量可以是左值，也可以为右值，但常量只能是右值。 右值只能被 ​const​ 类型的引用所指向；而左值可以被 const​ 或 ​非 const​ 类型引用指向。 一般右值是不能取地址的 &​ 字符串是左值 引用 左值引用 &​ 右值引用 &&​ 万能引用 #include #include using namespace std; template T foo(T && i) { cout 完美转发 #include #include using namespace std; template void foo(T i) { cout void foo_forwarding(T && i) { // const T & i，也是可以传递右值引用的，但是那样就不能修改它的值了 foo(i); foo(static_cast(i)); // 和下面标准库提供的函数是一样的 foo(std::forward(i)); } int main() { foo_forwarding(123); system(\"pause\"); return 0; } Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。 [capture](parameters)->return-type{body} // [capture] 捕获列表 // parameters 参数，形参 // -> return-type 不就是函数返回类型后置吗 // body 代码块 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。 在 Lambda 表达式内可以访问当前作用域的变量，这是 Lambda 表达式的闭包（Closure）行为。 与 JavaScript 闭包不同，C++ 变量传递有传值和传引用的区别。可以通过前面的 []​ 来指定： [] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, &y] // x 以传值方式传入（默认），y 以引用方式传入。 [&] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [&, x] // x 显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, &z] // z 显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于 [=]​ 或 [&]​ 的形式，lambda 表达式可以直接使用 this 指针。但是，对于 []​ 的形式，如果要使用 this 指针，必须显式传入： [this]() { this->someFunc(); }(); #include #include using namespace std; int main() { int x = 2; int y = 3; // func 相当于函数指针 auto func = [x, &y](int a, int b)->int { //x += 1; 会报错，表达式必须是可修改的左值 y += 1; return x * y + a + b; }; cout 断言 assert 事实上，它居然是个宏，并且作用并非\"报错\"。 在经过对其进行一定了解之后，对其作用及用法有了一定的了解，assert() 的用法像是一种\"契约式编程\"。 在函数开始处检验传入参数的合法性 每个 assert 只检验一个条件，因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败 不能使用改变环境的语句，因为 assert 只在 DEBUG 个生效，如果这么做，会使用程序在真正运行时遇到问题 assert 和后面的语句应空一行，以形成逻辑和视觉上的一致感 有的地方，assert 不能代替条件过滤 运行时断言 #include #include using namespace std; int main() { char* szBuffer = nullptr; assert(szBuffer != nullptr); system(\"pause\"); return 0; } 编译期断言 #include #include #define FLAG 0; using namespace std; int main() { static_assert(FLAG != 0); system(\"pause\"); return 0; } tuple 元组 std::tuple - cppreference.com #include #include #include using namespace std; std::tuple test() { return std::make_tuple(12, 7.5, \"hello tuple\"); } int main() { auto [x, y, z] = test(); cout 别名 类型别名，别名模板 (C++11 起) - cppreference.com 类型别名是指代【先前定义的类型】的名字（与 typedef 类似）。 别名模版是指代一族类型的名字。 using identifier attr(optional) = type-id ; template using identifier attr(optional) = type-id ; ---------- attr - optional sequence of any number of attributes identifier - the name that is introduced by this declaration, which becomes either a type name (1) or a template name (2) template-parameter-list - template parameter list, as in template declaration type-id - abstract declarator or any other valid type-id (which may introduce a new type, as noted in type-id). The type-id cannot directly or indirectly refer to identifier. Note that the point of declaration of the identifier is at the semicolon following type-id. e.g template struct Alloc { }; template using Vec = vector>; // type-id is vector> Vec v; // Vec is the same as vector> typedef unsigned int uint_t; // 被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。 // 重定义 unsigned int typedef unsigned int uint_t; using uint_t = unsigned int; // 重定义 std::map typedef std::map map_int_t; using map_int_t = std::map; //在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。 ---------- /* C++98/03 */ template struct func_t { typedef void (*type)(T, T); }; // 使用 func_t 模板 func_t::type xx_1; /* C++11 */ template using func_t = void (*)(T, T); // 使用 func_t 模板 func_t xx_2; 从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。 ---------- 函数指针举例 typedef void (*p_fptr)(int); // 定义一个函数指针 p_fptr 等价于 using fn = void(*)(int) // fn == p_fptr 可以称之为模板别名 ---------- 使用 using 给模板起别名 template using type_t = T; // ... type_t i; // type_t 实例化后的类型和它的模板参数类型等价。这里，type_t 将等价于 int。 ---------- #include #include using namespace std; template using int_map = std::map(int, T); // int_map == std::map(int, T) int main() { int_map ins; system(\"pause\"); return 0; } SHE 异常 #include #include using namespace std; int main() { __try { int x = 100; int y = 0; x = x / y; } __except (EXCEPTION_EXECUTE_HANDLER) { cout 其他 修改编译器 C++ 版本 ​ if/switch 中的 init-statement 【待初始化的判断条件】需要 C++ 17 后才支持。【错误 C2429】 前人栽树 C++ 函数 | 菜鸟教程 (runoob.com) C/C++ 断言 - Visual Studio (Windows) | Microsoft Learn C++11使用using定义别名（替代typedef） (biancheng.net) Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:58 "},"C++ 基础/CPP - 现代 C++ 基础（三）.html":{"url":"C++ 基础/CPP - 现代 C++ 基础（三）.html","title":"CPP - 现代 C++ 基础（三）","keywords":"","body":"列表初始化 #include using namespace std; typedef struct _Info { string szStr; int nValue; }Info, *PInfo; Info GetInfo() { return { \"hello\", 110 }; } int main() { Info info = GetInfo(); cout 类相关 一些初始操作 class CA { public： CA() = delete; // 删除默认构造函数 CA() = default; // 使用默认的构造函数 new = delete; // 那么 CA *pObj = new CA; 将会失效 } 联合体 Union union MyUnion { MyUnion(); // 加强型 uni31on ~MyUnion(); string szStr; // 存在非基础类型，需要构造和析构函数 } 实现一个模板数组 ``` # 智能指针 > 引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。 > > C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 `std::shared_ptr`​ / `std::unique_ptr`​ / `std::weak_ptr`​，使用它们需要包含头文件 ``​。 > > **注意：** > > * **引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。** > * **引用计数，有多少个指针指向这块内存** ## `std::shared_ptr` > ​`std::shared_ptr`​ 是一种共享式智能指针，它能够记录多少个 `shared_ptr`​ 共同指向一个对象，从而消除显式的调用 `delete`​，当引用计数变为零的时候就会将对象自动删除。 > > 但还不够，因为使用 `std::shared_ptr`​ 仍然需要使用 `new`​ 来调用，这使得代码出现了某种程度上的不对称。 > > ​`std::make_shared`​ 就能够用来消除显式的使用 `new`​，所以 `std::make_shared`​ 会分配创建传入参数中的对象， 并返回这个对象类型的 `std::shared_ptr`​ 指针。 ```cpp auto pointer auto pointer = std::make_shared(10); strong refs #include #include using namespace std; int main() { //auto pointer = new int(10); std::shared_ptr objA(new int(110)); // + objA shared_ptr 110 [1 strong refs] [default] std::shared_ptr auto pointer = std::make_shared(111); cout objB(objA); // 执行这句之后 // + objA shared_ptr 110 [2 strong refs] [default] std::shared_ptr // + objB shared_ptr 110 [2 strong refs] [default] std::shared_ptr std::shared_ptr objC(new int(0)); // + objC shared_ptr 0 [1 strong ref] [default] std::shared_ptr objC = objA; // + objC shared_ptr 110 [3 strong refs] [default] std::shared_ptr system(\"pause\"); return 0; } ​std::shared_ptr​ 可以通过 get()​ 方法来获取原始指针，通过 reset()​ 来减少一个引用计数， 并通过 use_count()​ 来查看一个对象的引用计数。【智能指针】 auto pointer = std::make_shared(10); auto pointer2 = pointer; // 引用计数 +1 auto pointer3 = pointer; // 引用计数 +1 int *p = pointer.get(); // 这样不会增加引用计数 std::unique_ptr​ ​std::unique_ptr​ 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全。 std::unique_ptr pointer = std::make_unique(10); // make_unique 从 C++14 引入 std::unique_ptr pointer2 = pointer; // 非法 ​make_unique​ 并不复杂，C++11 没有提供 std::make_unique​，可以自行实现： template std::unique_ptr make_unique( Args && ...args ) { // 右值引用 return std::unique_ptr( new T( std::forward(args)... ) ); } 至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的博客中提到原因是因为『被他们忘记了』。 既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move​ 将其转移给其他的 unique_ptr​。 std::unique_ptr p1(std::make_unique()); std::unique_ptr p2(std::move(p1)); std::weak_ptr​ 为了 解决std::shared_ptr​ 依然存在着资源无法释放的问题。需要使用到 std::weak_ptr​ 是一种弱引用（相比较而言 std::shared_ptr​ 就是一种强引用）。弱引用不会引起引用计数增加。 无法释放 e.g struct A; struct B; struct A { std::shared_ptr pointer; ~A() { std::cout pointer; ~B() { std::cout (); auto b = std::make_shared(); a->pointer = b; b->pointer = a; } 运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b​，这使得 a,b​ 的引用计数均变为了 2，而离开作用域时，a,b​ 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 a,b​ 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露。下断点调试可以看到，已经炸裂了... #include #include using namespace std; struct A; struct B; struct A { std::shared_ptr pointer; ~A() { std::cout pointer; ~B() { std::cout (); // + a shared_ptr {pointer=empty } [1 strong ref] [{_Storage={_Value={pointer=empty } } }] std::shared_ptr auto b = std::make_shared(); // + b shared_ptr {pointer=empty } [1 strong ref] [{_Storage={_Value={pointer=empty } } }] std::shared_ptr a->pointer = b; // + a shared_ptr {pointer=shared_ptr {pointer=empty } [2 strong refs] [{_Storage={_Value={pointer=empty } } }] } [1 strong ref] [{_Storage={_Value={pointer=shared_ptr {pointer=empty } [2 strong refs] [{_Storage={_Value={pointer=empty } } }] } } }] std::shared_ptr // + a->pointer shared_ptr {pointer=empty } [2 strong refs] [{_Storage={_Value={pointer=empty } } }] std::shared_ptr b->pointer = a; // + b shared_ptr {pointer=empty } [2 strong refs] [{_Storage={_Value={pointer=empty } } }] std::shared_ptr // + b shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{...}] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{...}] } [2 strong refs] [{_Storage={_Value={...} } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } } }] } } }] } } }] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr {...} [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [2 strong refs] [] } [2 strong refs] [{_Storage={...} }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr [2 strong refs] [{...}] } } }] } } }] } [2 strong refs] [{_Storage={_Value={pointer=shared_ptr {pointer=shared_ptr {pointer=shared_ptr [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } } }] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } } }] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] } [ strong refs] [] std::shared_ptr system(\"pause\"); return 0; } ​ 使用 std::weak_ptr​ ​ 在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。 ​std::weak_ptr​ 没有 *​ 运算符和 ->​ 运算符，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr​ 是否存在，其 expired()​ 方法能在资源未被释放时，会返回 false​，否则返回 true​；除此之外，它也可以用于获取指向原始对象的 std::shared_ptr​ 指针，其 lock()​ 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr​ 指针，进而访问原始对象的资源，否则返回 nullptr​。 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 05:10:58 "}}