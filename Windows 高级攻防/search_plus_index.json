{"./":{"url":"./","title":"Windows 高级攻防","keywords":"","body":"前言 这个 readme 我还没想好怎么写。。。 基础阶段 C/C++ 程序设计 01 环境配置 02 基础知识 ​ ​ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-09-20 22:49:10 "},"C 语言程序设计/01 - 环境和编译.html":{"url":"C 语言程序设计/01 - 环境和编译.html","title":"01 环境和编译","keywords":"","body":"环境 Win 10 专业版虚拟机 激活地址：https://www.bbsmax.com/A/QW5Y0pneJm/ 系统安装完毕后，首先以管理员身份打开 CMD 命令行窗口，按下 Win +X，选择命令提示符(管理员)。 说明：kms.xspace.in 是 kms 服务器地址，可能会失效，如果激活失败，可以自行搜索 kms 服务器地址，将 kms.xspace.in 替换成新的地址即可，比如换 kms.03k.org，参考可用的 kms 激活服务器有哪些。 # 公开地址有： kms.loli.best kms.cangshui.net kms.iaini.net kms.huengyamm.xyz kms.kuretru.com kms.03k.org 还有其他服务器，可以自行查找。 Win10 专业版用户请依次输入： slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato 觉得不安全激活后可以随便修改 kms 激活服务器地址：如 slmgr /skms zhaocai 按 Win + R 键，输入框输入 slmgr.vbs -xpr 打开，查看激活到期时间的相关信息 slmgr /upk，是卸载keyslmgr /ckms，是密钥管理服务计算机名称清除slmgr /rearm，是重置计算机的授权状态 https://baike.baidu.com/item/KMS/66195 https://zhuanlan.zhihu.com/p/152269085 7zip\\010Editor\\OllyICE\\x96dbg 7zip 直接解压安装 010Editor 直接运行 OllyICE 直接解压运行 ‪C:\\Tools\\OllyICE\\OllyDBG.EXE x96dbg 直接解压运行 ‪C:\\Tools\\x96dbg\\release\\x32\\x32dbg.exe C:\\Tools\\x96dbg\\release\\x64\\x64dbg.exe IDA 解压 -- 安装 -- 输入 SN 一直下一步就 ok。 SN：qY2jts9hEJGy ​ ​ Visual Studio 2017 Enterprise: NJVYC-BMHX2-G77MM-4XJMR-6Q8QF Professional: KBJFW-NXHK6-W4WJM-CRMQB-G3CDH 工作负荷 ​ 选择安装 使用 C++ 的桌面开发 √ ​ 通用 Windows 平台开发 （后期再使用） Visual Studio 扩展开发 √ 默认勾选即可 单个组件（默认即可） ​ ​ 等待安装完成，输入帮助 -- 注册产品。 MFC 应用创建 基于对话框 - 静态库中使用 MFC ​ 运行库安装 解压安装，默认推荐即可。 汇编金手指 直接使用 Kali 安装 略 前言 使用 C 语言的理由和应用领域 一些 C 的历史、标准、特性介绍。 可移植、更强的操作性、广泛 操作系统、编译器、游戏、嵌入式、桌面程序 C 语言的标准 K&RC 标准 C89/C90 C99 C11 编译过程 C 语言编译 源码（.c/.cpp）：编写 c or cpp 源码 编译（.obj/.o）源程序通过翻译程序加工以后生成的机器语言程序。【编译器（Compiler）】 连接（.exe）：其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件【系统提供的组件（比如标准库）结合起来，这些组件都是程序运行所必须的。】。完成链接的过程也需要一个特殊的软件，叫做 链接器（Linker） 。例如我们要在屏幕中输出字符，这必须调用系统提供的库才能够实现。可执行程序。 完整的编译步骤 ​ GCC 参数详解 | 菜鸟教程 (runoob.com) 预处理（预处理头文件、宏） sudo gcc -E hello.c -o hello.i 编译（c --> 汇编） sudo gcc -S hello.i -o hello.s 汇编（汇编语言 --> 二进制） sudo gcc -c hello.s -o hello.o 【注】-C 和 -c 的区别，前者会直接完成链接变成可执行文件。 链接（二进制文件 --> 可执行文件） sudo gcc hello.o -o hello 在 Linux 中是没有文件后缀这样的概念的（一切皆文件），只是起标识作用。 进制和位 进制 十六进制：0 ~ 9 A B C D E F 十进制：0~ 9 八进制：0 ~ 7 二进制：0 ~ 1 直接上计算器就完事了 ~ 位 操作系统位数：x86、x64 分别对应 32 位和 64 位。 QWORD 64 位 FWORD 48 位 DWORD 32 位 WORD 16 位 BYTE 8 位 BIT 1 位 Visual Studio & CLion 基本使用 四种运行库编译选项的区别 静态编译、动态编译（编译出来可能会缺少 xx 库） Visual Studio 中 MD 与 MT 的区别及运行库类型选择 - 知乎 (zhihu.com) MT 与 MD 的区别 /MT： 是 multithread-static version，是多线程静态版本的意思，项目会使用运行时库的多线程静态版本，编译器会将 LIBCMT.lib 放入 .obj 文件中，以便链接器使用 LIBCMT.lib 解析外部符号； /MTd： 是定义了 _DEBUG 和 /MT，是 /MT 类型的 debug 版本； /MD： 是 multithread-dll version，是多线程 dll 版本的意思，项目会使用运行时库的多线程动态 dll 版本，编译器会将 MSVCRT.lib 放入 .obj 文件中，在编译项目时，它会静态链接 MSVCRT.lib，但在实际运行过程中，它会链接使用 MSVCR90.dll； MDd： 是定义了 _DEBUG 和 /MD，是 /MD 类型的 debug 版本； 总起来说，/MD 类型表示运行时库不集成，生成的文件小，程序运行时动态加载对应的 dll；/MT 类型表示运行时库**集成**，生成的文件较大，在链接时将 C/C++ 运行时库集成到程序中。【写 那东西 的时候静态编译就好了】 ​ ​ 运行、Debug 就是常规调试了。就是可以看内存、变量值、运行步骤、调用关系之类的。 碎碎念 <> 在系统标准库里面寻找 \" \" 优先在本目录寻找，就比如自己写的宏 # pragma once 库预处理，多次包含也只会编译保留一份。 调试 F5 运行 F9 下断点 F10 单步执行 F11 单步步入 编译器 编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。一个现代编译器的主要工作流程：源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables) 连接器 在 C 语言中，一个重要的思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。但是连接器一般是与 C 编译器分离的，连接器如何做到把若干个 C 源程序合并成一个整体呢？链接过程就是空间分配过程。 连接器的输入是一组目标模块和库文件。连接器的输出是一个载入模块。连接器读入目标模块和库文件，同时生成载入模块。对每个目标模块中的每个外部对象，连接器都要检查载入模块，看是否已有同名的外部对象。如果没有，连接器就将该外部对象添加到载入模块中；如果有，连接器就要开始处理命名冲突。除了外部对象之外，目标模块还可能包括了对其他模块中的外部对象的引用。 CLion 参考 IDEA 使用。 前人栽树 编译链接过程YancyKahn 的博客-CSDN 博客编译链接过程 什么是编译、链接、编译程序 - 知乎 (zhihu.com) ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-09-25 14:47:23 "},"C 语言程序设计/02 - 基础数据类型与输入输出.html":{"url":"C 语言程序设计/02 - 基础数据类型与输入输出.html","title":"02 基础数据类型与输入输出","keywords":"","body":"数据类型 序号 类型与描述 1 基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。 2 枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 3 void 类型：类型说明符 void 表明没有可用的值。 4 派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。数组类型和结构类型统称为聚合类型。 整数 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小： #include #include int main() { printf(\"int 存储大小 : %lu \\n\", sizeof(int)); return 0; } %lu 为 32 位无符号整数，详细说明查看 C 库函数 - printf()。 当您在 Linux 上编译并执行上面的程序时，它会产生下列结果： int 存储大小 : 4 浮点类型 下表列出了关于标准浮点类型的存储大小、值范围和精度的细节： 类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位有效位 double 8 字节 2.3E-308 到 1.7E+308 15 位有效位 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位有效位 头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值： #include #include int main() { printf(\"float 存储最大字节数 : %lu \\n\", sizeof(float)); printf(\"float 最小值: %E\\n\", FLT_MIN ); printf(\"float 最大值: %E\\n\", FLT_MAX ); printf(\"精度值: %d\\n\", FLT_DIG ); return 0; } %E 为以指数形式输出单、双精度实数，详细说明查看 C 库函数 - printf()。 void 类型 void 类型指定没有可用的值。它通常用于以下三种情况下： 序号 类型与描述 1 函数返回为空C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void类型为 void 的指针代表对象的地址，而不是类型。**例如，内存分配函数 void malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。** 字符串 字符串是使用空字符 \\0 结尾的一维字符数组。因此，\\0 是用于标记字符串的结束。空字符（Null character ）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。 char szString[8] = \"zhaocai\"; // 内存 7a 68 61 6f 63 61 69 00 （对应的是字母的 ascii 码） // 可以对比一下 szBuffer[7] 和 szBuffer[8] 输出的区别。 char szBuffer[7] = \"zhaocai\"; // 会显示乱码 char *szBuffer = \"zhaocai\"; char site[8] = {'z', 'h', 'a', 'o', 'c', 'a', 'i', '\\0'}; wchar_t szWbuffer[] = L\"zhaocai\"; C 编译器会在初始化数组时，自动把 \\0 放在字符串的末尾。 字符串需要有结束符标识，数组需要自行添加结束符 \\00。 调试 -- 窗口 -- 内存 -- 内存，就可以查看内存。 ​ char 1 字节 wchar_t 2 字节 #include #include int main() { // char 1 字节，wchar_t 2 字节 char szBuffer[] = \"zhaocai\"; // 7a 68 61 6f 63 61 69 00 wchar_t szWbuffer[] = L\"zhaocai\"; // 7a 00 68 00 61 00 6f 00 63 00 61 00 69 00 00 00 // 可以看大 wchar_t 每一个字符都是占两个字节的。7a 00 ... system(\"pause\"); return 0; } ​ 数组的名字就是首地址 == 指针 strlen 计算字符串实际长度（没算结束符） 序号 函数 & 目的 1 strcpy(s1, s2);复制字符串 s2 到字符串 s1。 2 strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1);返回字符串 s1 的长度。 4 strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回大于 0。 5 strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 auto 类型（自动类型） http://c.biancheng.net/view/6984.html 定义变量 变量类型 变量名 = 值; 变量类型 变量名 = 表达式; 命名规则 英文字符或下划线开始 不能包含空格、标点符号、类型说明符和运算符 不能是关键字、大小写区分 推荐驼峰命名法 匈牙利命名法 关键字 auto ：声明自动变量 break：跳出当前循环 case：开关语句分支 char ：声明字符型变量或函数返回值类型 const ：声明只读变量 continue：结束当前循环，开始下一轮循环 default：开关语句中的“默认”分支 do ：循环语句的循环体 double ：声明双精度浮点型变量或函数返回值类型 else ：条件语句否定分支（与 if 连用） enum ：声明枚举类型 extern：声明变量或函数是在其它文件或本文件的其他位置定义 float：声明浮点型变量或函数返回值类型 for：一种循环语句 goto：无条件跳转语句 if:条件语句 int： 声明整型变量或函数 long ：声明长整型变量或函数返回值类型 register：声明寄存器变量 return ：子程序返回语句（可以带参数，也可不带参数） short ：声明短整型变量或函数 signed：声明有符号类型变量或函数 sizeof：计算数据类型或变量长度（即所占字节数） static ：声明静态变量 struct：声明结构体类型 switch :用于开关语句 typedef：用以给数据类型取别名 unsigned：声明无符号类型变量或函数 union：声明共用体类型 void ：声明函数无返回值或无参数，声明无类型指针 volatile：说明变量在程序执行中可被隐含地改变 while ：循环语句的循环条件 bool _Bool & 取地址符 全局变量 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。 保存在内存的全局存储区中，占用静态的存储单元。因为全局变量存储在静态数据区。 在静态数据区，内存中所有的字节默认值都是 0x00 局部变量 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。 形参也是局部变量。 保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。 静态变量（static） 只初始化一次：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。 共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。 常量变量（const） const 是 constant 的简写，用来定义常量，它限定一个变量不允许被改变，产生静态作用。const 最开始推出的目的是为了取代预编译指令，取长补短。是 只读变量，且是在编译运行阶段使用的。 const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。 修饰普通类型变量 如果不想让编译器察觉到上面到对 const 的操作，我们可以在 const 前面加上 volatile 关键字。 volatile 关键字跟 const 对应相反，是易变的，容易改变的意思。所以不会被编译器优化，编译器也就不会改变对 a 变量的操作。那么就可以通过取地址来改变变量的值。 const int a = 7; int *p = (int*)&a; *p = 8; 修饰指针变量 const 修饰指针变量有以下三种情况。【就近原则】 如果 const 后面是一个类型，则跳过最近的原子类型，修饰后面的数据**。**（原子类型是不可再分割的类型，如 int, short , char，以及 typedef 包装后的类型） A: const 修饰指针指向的内容，则内容为不可变量。【值不可变】 const int *p = 8; B: const 修饰指针，则指针为不可变量。【指向的地址不可变】 int a = 8; int* const p = &a; *p = 9; // 正确 int b = 7; p = &b; // 错误 C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。【值和指向的地址都不可变】 int a = 8; const int * const p = &a; 参数传递和函数返回值 普通变量做为形参可以不用 const 修饰，毕竟传过来的只是值而不是内存地址。 参数为指针时，const 可以防止指针被意外篡改 。 对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。 void Cmf(const Test& _tt) const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。 const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。 const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。 修饰类成员函数 const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。 const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。 https://www.runoob.com/w3cnote/cpp-const-keyword.html 初始化局部变量和全局变量 局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。 定义全局变量时，系统会自动对其初始化，如下所示： 数据类型 初始化默认值 int 0 char '\\0' float 0 double 0 pointer NULL 输入输出 格式化输入\\输出 ‍ %c 字符 %s 字符串 %d int %f double %e double %lld long long %x 十六进制 %X 大写的十六进制整数 %p 指针 \\ 转义字符 转义序列 含义 \\\\ \\ 字符 \\' ' 字符 \\\" \" 字符 \\? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 scanf 只能接收 4 字节，double 需要 8 字节，需要 %lf 接收。 scanf 错误：项目 - 属性 - C/C++ - 预处理器 - 预处理器定义 - 编辑。在最后一行加上 _CRT_SECURE_NO_WARNINGS 4996 错误主要是使用了不安全函数造成的(高版本的 vs 会报错) 可以在预处理添加 1. _CRT_SECURE_NO_WARNINGS 也可以可以通过 在文件最开始位置添加，消除错误 #pragma warning(disable:4996) 或者在项目创建的时候取消掉“安全开发生命周期检查”的选项 ​ 练习 前人栽树 菜鸟教程 - C 数据类型 菜鸟教程 - static 关键字 _CRT_SECURE_NO_WARNINGS ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-09-25 12:53:49 "},"C 语言程序设计/03 - 运算符.html":{"url":"C 语言程序设计/03 - 运算符.html","title":"03 运算符","keywords":"","body":"算术运算符 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A-- 将得到 9 ++a：先加后用 a++：先用后加 --b：先用后减 b--：先用后减 逻辑运算符 运算符 描述 实例 && 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A && B) 为假。 | | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 （A | | B）为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A && B) 为真。 关系运算符 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 为假。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 > 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A > B) 为假。 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A >= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A >= B) 为假。 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A 位运算符 运算符 描述 实例 & 按位与操作，按二进制位进行\"与\"运算。 | 按位或运算符，按二进制位进行\"或\"运算。 ^ 异或运算符，按二进制位进行\"异或\"运算。0\\^0\\=0;0\\^1\\=1;1\\^0\\=1;1\\^1\\=0;相同取 0，相异与 1。 两个数异或出来的第三个数，这三个数两两异或可以得到另一个数。 ~ 取反运算符，按二进制位进行\"取反\"运算。 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。 >> 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。 高位是 1 就左边补 1，高位是 0 就左边补 0。假设 A = 60，即 A = 0011 1100。A >> 2 ，右移两位 0000 1111 。 与 或 异或：相同取 0，相异与 1。 p q p & q p | q p ^ q 0 0 0 0 0 1 1 1 1 0 0 1 0 1 1 1 0 0 1 1 ‍ 左移：右边补 0 ，如 101011 左移 3 位：011000。 右移：高位是 1 就左边补 1，高位是 0 就左边补 0。 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C = A 相当于 C = C A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A 左移且赋值运算符 C >>= 右移且赋值运算符 C >>= 2 等同于 C = C >> 2 &= 按位与且赋值运算符 C &= 2 等同于 C = C & 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 = 按位或且赋值运算符 三目运算符和 sizeof 运算符 描述 实例 sizeof() 返回变量的大小。 sizeof(a) 将返回 4 字节，其中 a 是整数 int。 & 返回变量的地址。 &a; 将给出变量的实际地址。 * 指向一个变量。 *a; 将指向一个变量。 ? : 条件表达式 如果条件为真 ? 则值为 X : 否则值为 Y C 中运算符的优先级 自己写代码，遇事不决加括号。看别人代码需要注意。 类别 运算符 结合性 后缀 () [] -> . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* & sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 > 从左到右 关系 >= 从左到右 相等 == != 从左到右 位与 AND & 从左到右 位异或 XOR ^ 从左到右 位或 OR 逻辑与 AND && 从左到右 逻辑或 OR 条件 ?: 从右到左 赋值 = += -= *= /= %=>>= = 逗号 , 从左到右 练习 异或加密基本逻辑 #include int main() { // 两两异或可以得到第三个数，那么就可以用其中一个做 key ，得到另一个实现简单异或加密 char a = 'a'; char flag = 'g'; char ret = a ^ flag; printf(\"进行异或出来的值：%X\\r\\n\" \"原来的值和加密值异或得到的加密 key：%c\\r\\n\" \"原来的第一个值：%c \\r\\n\", ret, a ^ ret, flag ^ ret); return 0; } #defind 和 const 的区别 #defind 是常量，是宏在预处理阶段就会被简单的直接替换成对应的值。【若是表达式不会考虑优先级，所以记得加括号】。宏是直接替换，宏定义不会进行类型检查，不额外分配内存。 #include // 宏是直接替换，宏定义不会进行类型检查，不额外分配内存 #define Max(a, b) a > b ? a : b #define Num 2+3 int main() { char arrStr1[10] = { 'm', 'o', 'b', '\\0' }; char arrStr2[10] = \"mob\"; int ret1 = Max(1, 2); // 直接替换，所以等价于 2+3/2.0，并不是预期的 5 / 2.0 float ret2 = Num / 2.0; int const ret3 = 15; // ret3 = 17; const 只读常量不允许修改，修改则会报错 int len1 = strlen(arrStr1); int len2 = strlen(arrStr2); int len3 = sizeof(arrStr1); int len4 = sizeof(arrStr2); printf(\"%d \\n\", len1); printf(\"%d \\n\", len2); printf(\"%d \\n\", len3); printf(\"%d \\n\", len4); printf(\"%s \\n\", arrStr1); printf(\"%s \\n\", arrStr2); printf(\"%d \\n\", ret1); // 输出为 3.500000 printf(\"%f \\n\", ret2); return 0; } // 输出结果如下 3 3 10 10 mob mob 2 3.500000 const 也是常量，是变量的修饰符，是只读变量。 关键字 `const` 定义的是变量不是常量， 而是去改变一个变量的存储类，**把该变量所占的内存变为只读**。这就是变量的值不允许改变的常变量。该常量带有数据类型，编译运行的时候起作用存在**类型检查**。 一年大约有3.156*10^7秒。编写一个程序，提示用户输入年龄，然后显示该年龄对应的秒数。 #include #include #include // 没有考虑出生日期，平年闰年，统一按照 365 天算 int main() { float age = 0; printf(\"请输入您的年龄：\\n\"); scanf(\"%f\", &age); printf(\"您在地球上一共度过了 %f 秒。\\n\", (age * 3.156 * pow(10, 7))); system(\"pause\"); return 0; } 前人栽树 https://www.runoob.com/cprogramming/c-operators.html ‍ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-09-25 15:01:39 "},"C 语言程序设计/04 - 选择结构与顺序结构.html":{"url":"C 语言程序设计/04 - 选择结构与顺序结构.html","title":"04 选择结构与顺序结构","keywords":"","body":"判断 ​ 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if...else 语句 一个 if 语句 后可跟一个可选的 else 语句 ，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 【注】上一节的三目运算符 ?: 其实也属于判断。 顺序结构 按照编码顺序执行。 选择结构 switch case 注意 break; switch(表达式) { case 常量表达式 1:语句 1; break; case 常量表达式 2:语句 2; ... default:语句 n + 1; } // 没有 break 的话就会顺序执行接下来的 case // case 的语句最好 {} 起来比较清晰，如下： switch(表达式) { case 常量表达式 1: { 语句 1; } break; case 常量表达式 2: { 语句 2; } ... default: { 语句 n + 1; } } default 默认执行。 循环 ​ ‍ 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。for(索引初始化; 判断条件; 改变条件) {} do...while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。【先执行一次再判断条件，即至少执行一次】 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 size_t for( ; ; ) {} 等价于 while (true) {} 控制语句 控制语句 描述 break 语句 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。 continue 语句 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。【结束本次，继续下次】 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 flag: goto flag; ------------------------------------ #include int main() { zhaocai1: printf(\"去找 zhaocai 1 号。\\r\\n\"); goto zhaocai1; // 向前跳转 // 向后跳转 goto zhaocai; printf(\"去找 zhaocai\\r\\n\"); printf(\"去找 zhaocai\\r\\n\"); printf(\"去找 zhaocai\\r\\n\"); zhaocai: printf(\"没有找到招财 zhaocai\\r\\n\"); return 0; } 练习 循环打印 0 - 100（分别使用 while/dowhile/for/goto 实现） #include #include int main() { for (int i = 0; i 输入三个数，打印最小的那个数 #include #include int main() { printf(\"请输入 3 个数，用空格间隔：\\r\\n\"); int ret = 0; int i, j, k; scanf(\"%d %d %d\", &i, &j, &k); if (i > j) { ret = i; }else { ret = j; } printf(\"最大的数是：%d \\r\\n\", ((ret > k) ? ret : k)); system(\"pause\"); return 0; } 输入小写字母，转换成大写字母输出 #include #include int main() { char a; printf(\"请输入一个小写字母：\"); scanf(\"%c\", &a); //a += 32; a -= 32; printf(\"对应的大写字母是：%c \\r\\n\",a); system(\"pause\"); return 0; } 输入一个字符，判断字符是大写还是小写 #include #include int main() { char a; printf(\"请输入一个字母：\"); scanf(\"%c\", &a); if (a >= 'a' && a = 'A' && a 输入一个数，判断这个数是否为偶数 #include #include int main() { int a; printf(\"请输入一个数字：\"); scanf(\"%d\", &a); if (a % 2 == 0) { printf(\"%d 是偶数。\\r\\n\", a); } else { printf(\"%d 是奇数。\\r\\n\", a); } system(\"pause\"); return 0; } 使用 if 语句与 switch 语句分别实现一个具有加减乘除功能的计算器（略） 计算 0 - 100 的加法(0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 ...) #include #include int main() { int ret = 0, i = 100; while (i > 0) { ret += i; i--; } printf(\"0 ~ 100 的和是：%d\\r\\n\", ret); system(\"pause\"); return 0; } 打印乘法口诀 例如： 1 * 1 = 1 2 * 1 = 2 2* 2 = 4 #include #include int main() { int i = 1; int j = 1; for (i = 1; i 上网查询如何生成随机数，实现一个生成 10 以内随机数，并且猜数字的游戏 打印一个菱形（略） * *** ***** ******* ***** *** * 使用*打印一个三角形（略） * *** ***** ******* ********* 前人栽树 https://www.runoob.com/cprogramming/c-loops.html Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-09-25 15:04:52 "},"C 语言程序设计/05 - 函数、数组与指针.html":{"url":"C 语言程序设计/05 - 函数、数组与指针.html","title":"05 函数、数组与指针","keywords":"","body":"函数 函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 return_type function_name( parameter list ); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的。 C 语言的函数需要声明在前，使用在后，一般是将声明写到头文件中。#inlcude “your.h” 函数定义 // 需要改变实参得值的时候形参就需要用指针 * 或者取地址 &。 return_type function_name( parameter list ) { body of the function } 返回类型： 一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void 。 函数名称： 这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数： 参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体： 函数主体包含一组定义函数执行任务的语句。 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 可变参数 #include #include #include // 第一个参数表示参数的个数 int Add(int a, ...) { va_list v1; va_start(v1, a); int tmp = 0; for (int i = 0; i 数组 数组的声明并不是声明一个个单独的变量，比如 zhaocai0、zhaocai1、...、zhaocai99，而是声明一个数组变量，比如 zhaocai，然后使用 zhaocai[0]、zhaocai[1]、...、zhaocai[99] 来代表一个个单独的变量。【当然你也可以声明一个数组，从下标 [1] 开始使用】 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 数组变量名就是首地址，例如 int a[] --> 默认情况下：a == a[0] == 首地址 不管是一维数组还是多维数组其存储结构都是顺序存储形式，即数组中的元素是按一定顺序依次存放在内存中的一块连续的内存空间中(地址连续）。 ​ 数组声明 // 一维数组，arraySize 必须是一个大于零的整数常量 type arrayName [ arraySize ]; // 二维数组，相当于一维数组得每一个元素也是一个一维数组 type arrayName [ arraySize1 ][ arraySize2 ]; // 多维数组 type arrayName [size1][size2]...[sizeN]; ​ int a[3][4] = { {0, 1, 2, 3} , /* 初始化索引号为 0 的行 */ {4, 5, 6, 7} , /* 初始化索引号为 1 的行 */ {8, 9, 10, 11} /* 初始化索引号为 2 的行 */ }; // 访问 int val = a[2][3]; #include #include int main() { // 初始化数组 char szBuffer[8] = {'a', [5] = 'h', 'b'}; char *p = szBuffer; printf(\"数组的首地址是：%p\\r\\n\", p); for (int i=0; i ​ 在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念： 概念 描述 多维数组 C 支持多维数组。多维数组最简单的形式是二维数组。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C 允许从函数返回数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。char *p;char szBuffer[] = {};p = szBuffer; 数组形式的形参声明 // 方式 1 指针形式 void myFunction(int *param) {} // 方式 2 指定大小 void myFunction(int param[size]) {} // 方式 3 不指定大小 void myFunction(int param[]) {} 返回值是数组 C 语言不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。 int * myFunction() {...} #include #include #include /* 要生成和返回随机数的函数 */ int * getRandom( ) { static int r[10]; int i; /* 设置种子 */ srand( (unsigned)time( NULL ) ); for ( i = 0; i 指针 每一个变量都有一个内存位置，每一个内存位置都定义了可使用 & 运算符访问的地址。而指针可以指向任意内存地址。指针也就是内存地址，指针变量是用来存放内存地址的变量。 就像其他变量或常量一样，在使用指针存储其他变量地址之前，必须对其进行声明。 指针声明：type *var_name; type 是指针的基类型，它必须是一个有效的 C 数据类型。 var_name 是指针变量的名称。 用来声明指针的星号 *。 ​ 指针使用：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。【* 是取值的，& 是取地址的】 #include int main () { int var = 20; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ char szBuffer[] = \"zhaocai\"; char *cp = szBuffer; ip = &var; /* 在指针变量中存储 var 的地址 */ printf(\"var 变量的地址：%p\\n\", &var ); /* 在指针变量中存储的地址 */ printf(\"ip 指针变量存储的地址：%p\\n\", ip ); /* 使用指针访问值 */ printf(\"*ip 变量的值：%d\\n\", *ip ); /* 数组的变量名就是首地址 */ printf(\"szBuffer 数组变量的地址: %p\\n\", &szBuffer); /* 在指针变量中存储的地址 */ printf(\"cp 指针变量存储的地址: %p\\n\", cp ); /* 使用指针访问值 */ printf(\"*cp 变量的值: %c\\n\", *cp ); return 0; } NULL 指针：在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯，不然的话会是随机值，很危险。赋为 NULL 值的指针被称为空指针。NULL 指针是一个定义在标准库中的值为零的常量。 概念 描述 指针的算术运算 可以对指针进行四种算术运算：++、--、+、- 指针数组 可以定义用来存储指针的数组。 指向指针的指针 C 允许指向指针的指针。 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 从函数返回指针 C 允许函数返回指针到局部变量、静态变量和动态内存分配。 指针的运算 指针指向（存放）的是一个地址，地址是用数来表示的，既然是数那肯定可以进行算数运算咯。 ++、--、+、-、+=、-=、==、>、 指针的每一次递增，它其实会指向下一个元素的存储单元。 指针的每一次递减，它都会指向前一个元素的存储单元。 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节 #include const int MAX = 3; int main () { int var[] = {10, 100, 200}; int i, *ptr; /* 指针中的数组地址 */ ptr = var; // 也可以这样循环遍历数组 //while (ptr 指针数组 用来存储指针的数组，理论上数组存什么取决于数组定义的类型。 // 指向字符串的指针数组 const char *names[] = {\"Zara Ali\", \"Hina Ali\", \"Nuha Ali\", \"Sara Ali\"} // 指向整型的指针数组 #include const int MAX = 3; int main () { int *var[] = {10, 100, 200}; for (int i = 0; i 指向指针的指针 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。【就是说指针指向的地址里面存的也是地址】 ​ 多级指针声明：type **var_name; #include const int MAX = 3; int main () { int var = 110; int *p1 = &var; int **p2 = &p1; printf(\"直接通过 var 获取变量 var 的值： %d\\r\\n\",var); printf(\"通过一级指针 *p1 获取变量 var 的值： %d\\r\\n\",*p1); printf(\"通过二级指针 **p2 获取变量 var 的值：%d\\r\\n\",**p2); printf(\"===================================\\r\\n\"); printf(\"* 是取值，& 是取地址\\r\\n\"); printf(\"一级指针 *p1 的地址是 p1： %p\\r\\n\",p1); printf(\"二级指针 **p2 的地址是 p2： %p\\r\\n\",p2); printf(\"二级指针 **p2 里面存的值是“一个地址”，该地址就是 p1 的地址： %p\\r\\n\",*p2); return 0; } 指针在函数中的使用 传递指针给函数：只需要简单地声明函数参数为指针类型即可。 从函数返回指针：int * myFunction(){} register 关键字（有机会能使变量使用到寄存器 register int a） --> 寄存器。暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在 CPU 的寄存器中，以加快其存储速度。 // 32 位寄存器 eax ebx ecx edx esi edi esp ebp eip eflags // 64 位寄存器 练习 计算一个一维数组的总和 int nArr[10] = {12,158,14,12,16,8,152,12,3,55}; 计算一个二位数组中每一个一位数组的平均值 int nArr2[4][3] = { {12,15,12}, {15,33,99}, {88,77,44}, {99, 55, 75} }; 找出一个一维数组中最大的值 int nArr[10] = {12,158,14,12,16,8,152,12,3,55}; 使用指针获取该数组中最大的数（int nArr[5] = {12,15,33,555,1};） 计算(char szStr[] = \"this is a c string\";)字符串的长度，并且输出 若封装函数用 sizeof 计算的话注意一个坑，形参和实参。 当将数组作为实参传递到另一个函数中时，另一个函数的形参相当于一个指针变量， 因为将数组的名作为实参时，就是将数字的首地址作为实参，所以在 test 函数中输出的 sizeof(arr) 其实得到的是一个整型数组的长度(所占的字节数)，所以结果是 8, 再用其除以 int 所占的字节数(4), 结果就是 2 。 (这样是得不到准确的数组的长度的，建议的操作是在定义数组的函数中计算数组的长度,，在以实参的形式传递出去，这样其他的函数变可以获得数组的长度) 将下列两个字符串进行拼接，并且输出 char szStrA[] = \"zhaocai\"; char szStrB[] = \"在学 C 语言\"; 输出提示并且接收两个字符串，对比是否一致，并且输出结果 输出提示并且接收用户名和密码，拼接成一个字符串输出 实现加减乘除函数 用递归实现（0 + 1 + 2 ... 100） 使用指针编写字符串处理库 字符串长度计算函数 strlen 字符串对比函数 strcmp 字符串拷贝函数 strcpy 字符串拼接函数 strcat 字符串切割函数 strslic 字符串子串搜索 strstr 字符串子串总数 StrSubCount #include #include const int MAX = 3; // 计算平均值的函数 double getAverage(int *nArr, int size) { int sum = 0; for (int i=0; i // 第五题的内存信息，可以看到数组最后会自动加上 \\00 结束符，也算数组长度。【这点和字符串不一样】 szStr = {char [19]} [0] = {char} 116 't' [1] = {char} 104 'h' [2] = {char} 105 'i' [3] = {char} 115 's' [4] = {char} 32 ' ' [5] = {char} 105 'i' [6] = {char} 115 's' [7] = {char} 32 ' ' [8] = {char} 97 'a' [9] = {char} 32 ' ' [10] = {char} 99 'c' [11] = {char} 32 ' ' [12] = {char} 115 's' [13] = {char} 116 't' [14] = {char} 114 'r' [15] = {char} 105 'i' [16] = {char} 110 'n' [17] = {char} 103 'g' [18] = {char} 0 '\\000' length = {int} 19 #include // 递归求和函数 int sum(int N) { // 结束条件 if (N == 0) { return 0; } else { return N + sum(N-1); } } int main () { // 题目 10 int n = 100; printf(\"0 ~ 100 的和：%d\\r\\n\", sum(n)); return 0; } D:\\Program Files (x86)\\JetBrains\\Toolbox\\apps\\CLion\\ch-0\\222.4167.35\\bin\\mingw\\x86_64-w64-mingw32\\include\\string.h #include // 计算字符串长度，不包括 '\\0' 结束符 size_t myStrlen(const char *szBuffer) { register char *tmp = szBuffer; int count = 0; if (NULL == szBuffer || '\\0' == *tmp) { return 0; } while (*tmp != '\\0') { tmp++; count++; } return count; /*register char *tmp = szBuffer; while (*tmp++); return (tmp - szBuffer -1);*/ } // 字符串比较，str1 > str2 返回正数，str1 0) { return 1; }else if (*str1 - *str2 0); if (n > 0) { if (*s1 == '\\0') return -1; if (*--s2 == '\\0') return 1; return (unsigned char) *s1 - (unsigned char) *s2; } } return 0; } // 字符串复制 char * myStrcpy(char * dest, const char *src) { /*register char * str1 = dest; while (*str1++ = *src++) { } return dest;*/ register char *str1 = dest; if (NULL == str1 || NULL == src) { return NULL; } while ('\\0' != *src) { *str1++ = *src++; } *str1 = '\\0'; return dest; } // 字符串拼接 strcat char *myStrcat(char *dest, const char *str) { /*register char *s1 = dest; while (*s1++ != '\\0') *//*EMPTY*//* ; s1--; while (*s1++ = *str++) *//*EMPTY*//* ; return dest;*/ register char * src = str; if (NULL == str || '\\0' == *str) { return dest; } while (*dest != '\\0') { dest++; } while (*src != '\\0') { *dest++ = *src++; } *dest = '\\0'; return dest; /*int nLength1 = myStrlen(dest); int nLength2 = myStrlen(str); for (size_t i=0; i nLength) { return NULL; } int size = end - start; for (size_t i=0; i nLength) return -1; for (size_t i=0; i 前人栽树 C 指针 | 菜鸟教程 (runoob.com) C 数组 | 菜鸟教程 (runoob.com) C 函数 | 菜鸟教程 (runoob.com) C 语言如何计算数组的长度_i.czy 的博客-CSDN 博客_c 语言求数组长度 length How do I read the source code for a C library in CLion - Stack Overflow C 标准库 实现-阿里云开发者社区 (aliyun.com) C 标准库 实现 - wuyudong - 博客园 (cnblogs.com) 在调试器中查看变量的内存 - Visual Studio (Windows) | Microsoft Docs Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2022-09-25 15:06:48 "}}