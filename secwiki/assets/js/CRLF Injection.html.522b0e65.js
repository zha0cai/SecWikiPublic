"use strict";(self.webpackChunkone_piece=self.webpackChunkone_piece||[]).push([[822],{7708:(e,a)=>{a.A=(e,a)=>{const n=e.__vccOpts||e;for(const[e,t]of a)n[e]=t;return n}},7811:(e,a,n)=>{n.r(a),n.d(a,{comp:()=>T,data:()=>k});var t=n(4754);const s=n.p+"assets/img/image-20230909000341-tbvkdtx.b0ab3347.png",l=n.p+"assets/img/image-20230909000411-31n0mdq.20503128.png",i=n.p+"assets/img/image-20230909000442-nqhipr8.ab564c6a.png",o=n.p+"assets/img/image-20230909000540-9v0grtx.1db86263.png",c=n.p+"assets/img/image-20230909002323-2j0geaf.9a0082c3.png",r=(0,t.Fv)('<h1 id="crlf" tabindex="-1"><a class="header-anchor" href="#crlf"><span>CRLF</span></a></h1><p>CRLF 是”回车 + 换行”（<code>\\r\\n</code>​）的简称。<strong><mark>在 HTTP 协议中，HTTP Header 与 HTTP Body 是用两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显示出来。</mark></strong> 所以，一旦我们能够控制 HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话 Cookie 或者 HTML 代码，所以 CRLF Injection 又叫 <strong>HTTP Response Splitting</strong>，简称 <strong>HRS</strong>。</p><p>HRS 是比 XSS 危害更大的安全问题，具体是为什么，我们往下看。</p><p>对于 HRS 最简单的利用方式是注入两个 <code>\\r\\n</code>​，之后在写入 xss 代码，来构造一个 xss。</p><p>举个例子，一般网站会在 HTTP 头中用 <code>Location: http://baidu.com</code> ​这种方式来进行 302 跳转，所以我们能控制的内容就是 Location:后面的 XXX 某个网址。</p><p>所以一个正常的 302 跳转包是这样：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>HTTP/1.1 302 Moved Temporarily\nDate: Fri, 27 Jun 2014 17:52:17 GMT\nContent-Type: text/html\nContent-Length: 154\nConnection: close\nLocation: http://www.sina.com.cn\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但如果我们输入的是</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>http://www.sina.com.cn%0aSet-cookie:JSPSESSID%3Dwooyun\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注入了一个换行，此时的返回包就会变成这样：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>HTTP/1.1 302 Moved Temporarily \nDate: Fri, 27 Jun 2014 17:52:17 GMT \nContent-Type: text/html \nContent-Length: 154 \nConnection: close \nLocation: http://www.sina.com.cn \nSet-cookie: JSPSESSID=wooyun\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',11),d={href:"http://test.sina.com.cn/?url=xxx",target:"_blank",rel:"noopener noreferrer"},p=(0,t.Lk)("code",null,"xxx",-1),m=(0,t.Fv)('<div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>http://test.sina.com.cn/?url=%0d%0a%0d%0a<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>1</span> <span class="token special-attr"><span class="token attr-name">onerror</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">xss</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span></span></span></span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们的返回包就会变成这样：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>HTTP/1.1 302 Moved Temporarily \nDate: Fri, 27 Jun 2014 17:52:17 GMT \nContent-Type: text/html \nContent-Length: 154 \nConnection: close \nLocation:\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>1</span> <span class="token special-attr"><span class="token attr-name">onerror</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">xss</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span></span></span></span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之前说了<strong>浏览器会根据第一个 CRLF 把 HTTP 包分成头和体，然后将体显示出来</strong>。于是我们这里 <code>&lt;img&gt;</code>​ 这个标签就会显示出来，造成一个 XSS。</p><p>为什么说是无视浏览器 filter 的，这里涉及到另一个问题。</p><p>浏览器的 Filter 是浏览器应对一些反射型 XSS 做的保护策略，当 url 中含有 XSS 相关特征的时候就会过滤掉不显示在页面中，所以不能触发 XSS。</p><p>怎样才能关掉 filter？<strong><mark>一般来说用户这边是不行的，只有数据包中 http 头含有 X-XSS-Protection 并且值为 0 的时候，浏览器才不会开启 filter。</mark></strong></p><p>说到这里应该就很清楚了，HRS 不正是注入 HTTP 头的一个漏洞吗，我们可以将 <code>X-XSS-Protection:0</code>​ 注入到数据包中，再用<strong>两个 CRLF</strong> 来注入 XSS 代码，这样就成功地绕过了浏览器 filter，并且执行我们的反射型 XSS。</p><p>所以说 HRS 的危害大于 XSS，因为它能绕过一般 XSS 所绕不过的 filter，并能产生会话固定漏洞。</p><p>我们来一个真实案例吧。</p><p>新浪某分站含有一个 url 跳转漏洞，危害并不大，于是我就想到了 CRLF Injection，当我测试</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>http://xxx.sina.com.cn/?url=%0a%0d%0a%0d%3Cimg%20src=1%3E\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>的时候，发现图片已经输出在页面中了，说明 CRLF 注入成功了：</p><p>​<img src="'+s+'" alt="image" loading="lazy">​</p><p>那么我们试试 XSS 看看：</p><p>​<img src="'+l+'" alt="image" loading="lazy">​</p><p>看控制台，果然被 XSS Filter 拦截了。</p><p>那么我们就注入一个 <code>X-XSS-Protection:0</code>​​ 到数据包中，看看什么效果：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>http://192.168.238.129:8080/%0aX-XSS-Protection:%200%0a%0d%0a%0d&lt;img%20src=1%20onerror=alert(/xss/)&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​<img src="'+i+'" alt="image" loading="lazy"></p><p>@mramydnei 还想到了一个利用字符编码来绕过 XSS Filter 的方法，当编码是 <code>is-2022-kr</code>​ 时浏览器会忽略 <code>%0f</code>​，这样我们在 onerror 后面加个 <code>%0f</code>​ 就能绕过 filter，前提是注入一个 <code>&lt;meta charset=ISO-2022-KR&gt;</code>​​：</p><p>​<img src="'+o+'" alt="image" loading="lazy">​</p><p>当然，在 <code>Location:</code>​ 这里注入只有 webkit 内核浏览器才能够利用，其他浏览器可能会跳转、出错。不过对于 chrome 的使用量来说，危害已经足够了。</p><p>如何修复 HRS 漏洞，当然是过滤 <code>\\r</code>​ 、<code>\\n</code>​ 之类的换行符，避免输入的数据污染到其他 HTTP 头。</p><h1 id="poc" tabindex="-1"><a class="header-anchor" href="#poc"><span>POC</span></a></h1><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>Payload: http://your-ip:8080/%0d%0aSet-Cookie:%20a=1，可注入 Set-Cookie 头\n\n%0d%0a%0d%0a&lt;meta%20charset=ISO-2022-KR&gt;&lt;img%20src=1%20onerror%0f=alert(1)&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​<img src="'+c+'" alt="image" loading="lazy">​</p><h1 id="bottle-http-头注入" tabindex="-1"><a class="header-anchor" href="#bottle-http-头注入"><span>Bottle HTTP 头注入</span></a></h1>',28),u={href:"https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html",target:"_blank",rel:"noopener noreferrer"},g=(0,t.Fv)('<div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>res.set_header(&#39;Location&#39;, urljoin(request.url, url))\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中使用了一个 urljoin，将当前 url 和我传入的 path 进行了一次&quot;join&quot;，经过这个操作事情就变得很微妙了：<code>Location</code> ​头一定有一个值。这种情况下，浏览器就不会渲染页面，会直接跳转到 Location 头指向的地址。也就是说，如果我要利用 CRLF 构造 XSS 的话，这里是不会触发的。</p><p>回想上面提到过的新浪的那个 CRLF，那个漏洞的 <code>Location</code> ​是可以为空的，如果浏览器发现 <code>Location</code> ​为空就不会进行跳转，进而渲染了后面注入的 HTML，造成 XSS。</p><p>那么本文这里怎么处理？</p><p>当时我提出了使用 <code>\\0</code>​ 来阻止 PHP 返回 <code>Location</code>​ 头的方法。因为 PHP 的 header 函数一旦遇到 <code>\\0</code>​、<code>\\r</code>​、<code>\\n</code>​ 这三个字符，就会抛出一个错误，此时 <code>Location</code>​ 头便不会返回，浏览器也就不会跳转了。</p><p>其实当时我还想出来一个方法：在 PHP 没有关闭 <code>display_errors</code>​ 的情况下，只要在 header 位置的前面某处构造一个错误，一旦有错误信息在 header 前被输出，header 函数也就不会执行了 -- 原因是我们不能在 HTTP 体已经输出的情况下再输出 HTTP 头。</p><h1 id="前人栽树" tabindex="-1"><a class="header-anchor" href="#前人栽树"><span>前人栽树</span></a></h1>',7),h={href:"https://www.leavesongs.com/PENETRATION/Sina-CRLF-Injection.html",target:"_blank",rel:"noopener noreferrer"},v=(0,t.Lk)("p",null,"‍",-1),b={},T=(0,n(7708).A)(b,[["render",function(e,a){const n=(0,t.g2)("ExternalLinkIcon");return(0,t.uX)(),(0,t.CE)("div",null,[r,(0,t.Lk)("p",null,[(0,t.eW)("这个时候这样我们就给访问者设置了一个 SESSION，造成一个“会话固定漏洞”。 当然，HRS 并不仅限于会话固定，通过注入两个 CRLF 就能造成一个无视浏览器 Filter 的反射型 XSS。 比如一个网站接受 url 参数 "),(0,t.Lk)("a",d,[(0,t.eW)("http://test.sina.com.cn/?url=xxx"),(0,t.bF)(n)]),(0,t.eW)("，"),p,(0,t.eW)("​ 放在 Location 后面作为一个跳转。如果我们输入的是：")]),m,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.Lk)("a",u,[(0,t.eW)("Bottle HTTP 头注入漏洞探究 | 离别歌 (leavesongs.com)"),(0,t.bF)(n)])])]),g,(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.Lk)("a",h,[(0,t.eW)("新浪某站 CRLF Injection 导致的安全问题 | 离别歌 (leavesongs.com)"),(0,t.bF)(n)])])]),v])}]]),k=JSON.parse('{"path":"/websec/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/CRLF%20Injection.html","title":"CRLF Injection","lang":"zh-CN","frontmatter":{"title":"CRLF Injection","description":"CRLF CRLF 是”回车 + 换行”（\\\\r\\\\n​）的简称。在 HTTP 协议中，HTTP Header 与 HTTP Body 是用两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显示出来。 所以，一旦我们能够控制 HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话 Cookie 或者 HTML ...","head":[["meta",{"property":"og:url","content":"https://github.com/zha0cai/SecWikiPublic/websec/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/CRLF%20Injection.html"}],["meta",{"property":"og:site_name","content":"One-Piece"}],["meta",{"property":"og:title","content":"CRLF Injection"}],["meta",{"property":"og:description","content":"CRLF CRLF 是”回车 + 换行”（\\\\r\\\\n​）的简称。在 HTTP 协议中，HTTP Header 与 HTTP Body 是用两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显示出来。 所以，一旦我们能够控制 HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话 Cookie 或者 HTML ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Mr.zha0cai"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CRLF Injection\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.zha0cai\\",\\"url\\":\\"https://github.com/zha0cai\\"}]}"]]},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.95,"words":1485},"filePathRelative":"websec/安全漏洞/CRLF Injection.md","autoDesc":true}')}}]);